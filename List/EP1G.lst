
AVRASM ver. 2.1.30  C:\Users\YJW\Desktop\EP1G\List\EP1G.asm Fri Mar 26 08:13:56 2021

C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1090): warning: Register r5 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1091): warning: Register r4 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1092): warning: Register r7 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1093): warning: Register r6 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1094): warning: Register r9 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1095): warning: Register r8 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1096): warning: Register r11 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1097): warning: Register r10 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1098): warning: Register r13 already defined by the .DEF directive
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1099): warning: Register r12 already defined by the .DEF directive
                 
                 
                 ;CodeVisionAVR C Compiler V3.12 Advanced
                 ;(C) Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Build configuration    : Release
                 ;Chip type              : ATmega128
                 ;Program type           : Application
                 ;Clock frequency        : 16.000000 MHz
                 ;Memory model           : Small
                 ;Optimize for           : Size
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External RAM size      : 0
                 ;Data Stack size        : 1024 byte(s)
                 ;Heap size              : 0 byte(s)
                 ;Promote 'char' to 'int': No
                 ;'char' is unsigned     : Yes
                 ;8 bit enums            : No
                 ;Global 'const' stored in FLASH: Yes
                 ;Enhanced function parameter passing: Yes
                 ;Enhanced core instructions: On
                 ;Automatic register allocation for global variables: On
                 ;Smart register allocation: On
                 
                 	#define _MODEL_SMALL_
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega128
                 	#pragma AVRPART MEMORY PROG_FLASH 131072
                 	#pragma AVRPART MEMORY EEPROM 4096
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	#define CALL_SUPPORTED 1
                 
                 	.LISTMAC
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU RAMPZ=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU XMCRA=0x6D
                 	.EQU XMCRB=0x6C
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __SRAM_START=0x0100
                 	.EQU __SRAM_END=0x10FF
                 	.EQU __DSTACK_SIZE=0x0400
                 	.EQU __HEAP_SIZE=0x0000
                 	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDBMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ANDWMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ANDI R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD2N
                 	ANDI R26,LOW(@0)
                 	ANDI R27,HIGH(@0)
                 	ANDI R24,BYTE3(@0)
                 	ANDI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORBMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ORWMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ORI  R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD2N
                 	ORI  R26,LOW(@0)
                 	ORI  R27,HIGH(@0)
                 	ORI  R24,BYTE3(@0)
                 	ORI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+(@1))
                 	LDI  R31,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1M
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	LDI  R22,BYTE3(2*@0+(@1))
                 	LDI  R23,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	LDI  R24,BYTE3(2*@0+(@1))
                 	LDI  R25,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+(@2))
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+(@3))
                 	LDI  R@1,HIGH(@2+(@3))
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+(@3))
                 	LDI  R@1,HIGH(@2*2+(@3))
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	LDS  R22,@0+(@1)+2
                 	LDS  R23,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+(@2)
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+(@3)
                 	LDS  R@1,@2+(@3)+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	LDS  R24,@0+(@1)+2
                 	LDS  R25,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	STS  @0+(@1)+2,R22
                 	STS  @0+(@1)+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTB1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRB
                 	.ENDM
                 
                 	.MACRO __PUTW1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRW
                 	.ENDM
                 
                 	.MACRO __PUTD1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRD
                 	.ENDM
                 
                 	.MACRO __PUTBR0MN
                 	STS  @0+(@1),R0
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+(@1),R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+(@1),R@2
                 	STS  @0+(@1)+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTBSR
                 	STD  Y+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	PUSH R26
                 	PUSH R27
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMRDW
                 	POP  R27
                 	POP  R26
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EX
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	CALL __EEPROMRDD
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __GETBRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	LD   R@0,X
                 	.ENDM
                 
                 	.MACRO __GETWRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	LD   R@0,X+
                 	LD   R@1,X
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	ST   Z,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRR0
                 	MULS R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBRRU0
                 	MUL  R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBNWRU
                 	LDI  R26,@2
                 	MUL  R26,R@0
                 	MOVW R30,R0
                 	MUL  R26,R@1
                 	ADD  R31,R0
                 	.ENDM
                 
                 ;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
                 	.DEF _rx_wr_index0=R5
                 	.DEF _rx_rd_index0=R4
                 	.DEF _rx_counter0=R7
                 	.DEF _rx_buffer_overflow0=R6
                 	.DEF _mRcvErrFlag0=R9
                 	.DEF _rx_wr_index1=R8
                 	.DEF _rx_rd_index1=R11
                 	.DEF _rx_counter1=R10
                 	.DEF _rx_buffer_overflow1=R13
                 	.DEF _mRcvErrFlag1=R12
                 
                 	.CSEG
                 	.ORG 0x00
                 
                 ;START OF CODE MARKER
                 __START_OF_CODE:
                 
                 ;INTERRUPT VECTORS
000000 940c 00bd 	JMP  __RESET
000002 940c 0000 	JMP  0x00
000004 940c 0000 	JMP  0x00
000006 940c 0000 	JMP  0x00
000008 940c 0000 	JMP  0x00
00000a 940c 0000 	JMP  0x00
00000c 940c 0000 	JMP  0x00
00000e 940c 0000 	JMP  0x00
000010 940c 0000 	JMP  0x00
000012 940c 0000 	JMP  0x00
000014 940c 0000 	JMP  0x00
000016 940c 0000 	JMP  0x00
000018 940c 0000 	JMP  0x00
00001a 940c 0000 	JMP  0x00
00001c 940c 0791 	JMP  _timer1_ovf_isr
00001e 940c 0000 	JMP  0x00
000020 940c 0612 	JMP  _timer0_ovf_isr
000022 940c 0000 	JMP  0x00
000024 940c 057e 	JMP  _usart0_rx_isr
000026 940c 0000 	JMP  0x00
000028 940c 0000 	JMP  0x00
00002a 940c 0000 	JMP  0x00
00002c 940c 0000 	JMP  0x00
00002e 940c 0000 	JMP  0x00
000030 940c 0000 	JMP  0x00
000032 940c 0000 	JMP  0x00
000034 940c 0000 	JMP  0x00
000036 940c 0000 	JMP  0x00
000038 940c 0000 	JMP  0x00
00003a 940c 0000 	JMP  0x00
00003c 940c 051c 	JMP  _usart1_rx_isr
00003e 940c 0000 	JMP  0x00
000040 940c 0000 	JMP  0x00
000042 940c 0000 	JMP  0x00
000044 940c 0000 	JMP  0x00
                 
                 _VolArray:
000046 0b05
000047 1a12
000048 3328
000049 4a3f      	.DB  0x5,0xB,0x12,0x1A,0x28,0x33,0x3F,0x4A
00004a 5d55
00004b 7c6d
00004c 968a
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1146): warning: .cseg .db misalignment - padding zero byte
00004d 00a0      	.DB  0x55,0x5D,0x6D,0x7C,0x8A,0x96,0xA0
                 _DacArray:
00004e 0000
00004f 4120
000050 0000
000051 41a0      	.DB  0x0,0x0,0x20,0x41,0x0,0x0,0xA0,0x41
000052 0000
000053 41f0
000054 cccd
000055 4220      	.DB  0x0,0x0,0xF0,0x41,0xCD,0xCC,0x20,0x42
000056 3333
000057 4153
000058 851f
000059 4187      	.DB  0x33,0x33,0x53,0x41,0x1F,0x85,0x87,0x41
00005a 3d71
00005b 41aa
00005c 8f5c
00005d 41ce      	.DB  0x71,0x3D,0xAA,0x41,0x5C,0x8F,0xCE,0x41
00005e 8f5c
00005f 41f4
000060 999a
000061 420d      	.DB  0x5C,0x8F,0xF4,0x41,0x9A,0x99,0xD,0x42
000062 0000
000063 4220
000064 999a
000065 425f      	.DB  0x0,0x0,0x20,0x42,0x9A,0x99,0x5F,0x42
                 _tbl10_G100:
000066 2710
000067 03e8
000068 0064
000069 000a      	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
00006a 0001      	.DB  0x1,0x0
                 _tbl16_G100:
00006b 1000
00006c 0100
00006d 0010
00006e 0001      	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0
                 
                 ;GLOBAL REGISTER VARIABLES INITIALIZATION
                 __REG_VARS:
00006f 0000
000070 0000      	.DB  0x0,0x0,0x0,0x0
000071 0000
000072 0000      	.DB  0x0,0x0,0x0,0x0
000073 0000      	.DB  0x0,0x0
                 
                 _0x60003:
000074 0198
000075 019b
000076 01a9
000077 01c5      	.DB  LOW(_IPC1_RCV_MODE),HIGH(_IPC1_RCV_MODE),LOW(_IPC1_RCV_RUN),HIGH(_IPC1_RCV_RUN),LOW(_IPC1_RCV_DOSE),HIGH(_IPC1_RCV_DOSE),LOW(_IPC1_RCV_VOLTAGE),HIGH(_IPC1_RCV_VOLTAGE)
000078 01dd
000079 01ee
00007a 0202
00007b 021e      	.DB  LOW(_IPC1_RCV_DEPTH),HIGH(_IPC1_RCV_DEPTH),LOW(_IPC1_RCV_SPEED),HIGH(_IPC1_RCV_SPEED),LOW(_IPC1_RCV_ELCOUNT),HIGH(_IPC1_RCV_ELCOUNT),LOW(_IPC1_RCV_FLAG),HIGH(_IPC1_RCV_FLAG)
00007c 0224
00007d 0241
00007e 0244
00007f 0247      	.DB  LOW(_IPC1_RCV_EL_MAP),HIGH(_IPC1_RCV_EL_MAP),LOW(_IPC1_RCV_MOTOR_POS1),HIGH(_IPC1_RCV_MOTOR_POS1),LOW(_IPC1_RCV_MOTOR_POS2),HIGH(_IPC1_RCV_MOTOR_POS2),LOW(_IPC1_RCV_ERROR),HIGH(_IPC1_RCV_ERROR)
                 _0x6001E:
000080 026e
000081 027b
000082 0287
000083 0293      	.DB  LOW(_IPC1_SND_MODE),HIGH(_IPC1_SND_MODE),LOW(_IPC1_SND_RUN),HIGH(_IPC1_SND_RUN),LOW(_IPC1_SND_DOSE),HIGH(_IPC1_SND_DOSE),LOW(_IPC1_SND_VOLTAGE),HIGH(_IPC1_SND_VOLTAGE)
000084 029f
000085 02ab
000086 02b7
000087 02c3      	.DB  LOW(_IPC1_SND_DEPTH),HIGH(_IPC1_SND_DEPTH),LOW(_IPC1_SND_SPEED),HIGH(_IPC1_SND_SPEED),LOW(_IPC1_SND_ELCOUNT),HIGH(_IPC1_SND_ELCOUNT),LOW(_IPC1_SND_FLAG),HIGH(_IPC1_SND_FLAG)
000088 02d3
000089 02f5
00008a 0309
00008b 031d      	.DB  LOW(_IPC1_SND_EL_MAP),HIGH(_IPC1_SND_EL_MAP),LOW(_IPC1_SND_MOTOR_POS1),HIGH(_IPC1_SND_MOTOR_POS1),LOW(_IPC1_SND_MOTOR_POS2),HIGH(_IPC1_SND_MOTOR_POS2),LOW(_IPC1_SND_ERROR),HIGH(_IPC1_SND_ERROR)
                 _0x6002F:
00008c 03b1
00008d 03df
00008e 03f9
00008f 03fc      	.DB  LOW(_IPC0_RCV_MODE),HIGH(_IPC0_RCV_MODE),LOW(_IPC0_RCV_RUN),HIGH(_IPC0_RCV_RUN),LOW(_IPC0_RCV_DOSE),HIGH(_IPC0_RCV_DOSE),LOW(_IPC0_RCV_VOLTAGE),HIGH(_IPC0_RCV_VOLTAGE)
000090 03ff
000091 0402
000092 0405
000093 0408      	.DB  LOW(_IPC0_RCV_DEPTH),HIGH(_IPC0_RCV_DEPTH),LOW(_IPC0_RCV_SPEED),HIGH(_IPC0_RCV_SPEED),LOW(_IPC0_RCV_ELCOUNT),HIGH(_IPC0_RCV_ELCOUNT),LOW(_IPC0_RCV_FLAG),HIGH(_IPC0_RCV_FLAG)
000094 0414
000095 0417
000096 0424
000097 0431      	.DB  LOW(_IPC0_RCV_EL_MAP),HIGH(_IPC0_RCV_EL_MAP),LOW(_IPC0_RCV_MOTOR_POS1),HIGH(_IPC0_RCV_MOTOR_POS1),LOW(_IPC0_RCV_MOTOR_POS2),HIGH(_IPC0_RCV_MOTOR_POS2),LOW(_IPC0_RCV_ERROR),HIGH(_IPC0_RCV_ERROR)
                 _0x6003D:
000098 0448
000099 044e
00009a 0453
00009b 0458      	.DB  LOW(_IPC0_SND_MODE),HIGH(_IPC0_SND_MODE),LOW(_IPC0_SND_RUN),HIGH(_IPC0_SND_RUN),LOW(_IPC0_SND_DOSE),HIGH(_IPC0_SND_DOSE),LOW(_IPC0_SND_VOLTAGE),HIGH(_IPC0_SND_VOLTAGE)
00009c 045d
00009d 0467
00009e 0462
00009f 046c      	.DB  LOW(_IPC0_SND_DEPTH),HIGH(_IPC0_SND_DEPTH),LOW(_IPC0_SND_SPEED),HIGH(_IPC0_SND_SPEED),LOW(_IPC0_SND_ELCOUNT),HIGH(_IPC0_SND_ELCOUNT),LOW(_IPC0_SND_FLAG),HIGH(_IPC0_SND_FLAG)
0000a0 0478
0000a1 047d
0000a2 0482
0000a3 0487      	.DB  LOW(_IPC0_SND_EL_MAP),HIGH(_IPC0_SND_EL_MAP),LOW(_IPC0_SND_MOTOR_POS1),HIGH(_IPC0_SND_MOTOR_POS1),LOW(_IPC0_SND_MOTOR_POS2),HIGH(_IPC0_SND_MOTOR_POS2),LOW(_IPC0_SND_ERROR),HIGH(_IPC0_SND_ERROR)
                 _0x2080060:
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1183): warning: .cseg .db misalignment - padding zero byte
0000a4 0001      	.DB  0x1
                 _0x2080000:
0000a5 4e2d
0000a6 4e41
0000a7 4900
0000a8 464e      	.DB  0x2D,0x4E,0x41,0x4E,0x0,0x49,0x4E,0x46
C:\Users\YJW\Desktop\EP1G\List\EP1G.asm(1186): warning: .cseg .db misalignment - padding zero byte
0000a9 0000      	.DB  0x0
                 
                 __GLOBAL_INI_TBL:
0000aa 000a      	.DW  0x0A
0000ab 0004      	.DW  0x04
0000ac 00de      	.DW  __REG_VARS*2
                 
0000ad 0018      	.DW  0x18
0000ae 051f      	.DW  _IPC1Rcvfun
0000af 00e8      	.DW  _0x60003*2
                 
0000b0 0018      	.DW  0x18
0000b1 0537      	.DW  _IPC1Sndfun
0000b2 0100      	.DW  _0x6001E*2
                 
0000b3 0018      	.DW  0x18
0000b4 054f      	.DW  _IPC0Rcvfun
0000b5 0118      	.DW  _0x6002F*2
                 
0000b6 0018      	.DW  0x18
0000b7 0567      	.DW  _IPC0Sndfun
0000b8 0130      	.DW  _0x6003D*2
                 
0000b9 0001      	.DW  0x01
0000ba 0784      	.DW  __seed_G104
0000bb 0148      	.DW  _0x2080060*2
                 
                 _0xFFFFFFFF:
0000bc 0000      	.DW  0
                 
                 #define __GLOBAL_INI_TBL_PRESENT 1
                 
                 __RESET:
0000bd 94f8      	CLI
0000be 27ee      	CLR  R30
0000bf bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF FLASH
0000c0 e0f1      	LDI  R31,1
0000c1 bff5      	OUT  MCUCR,R31
0000c2 bfe5      	OUT  MCUCR,R30
0000c3 93e0 006c 	STS  XMCRB,R30
                 
                 ;DISABLE WATCHDOG
0000c5 e1f8      	LDI  R31,0x18
0000c6 bdf1      	OUT  WDTCR,R31
0000c7 bde1      	OUT  WDTCR,R30
                 
                 ;CLEAR R2-R14
0000c8 e08d      	LDI  R24,(14-2)+1
0000c9 e0a2      	LDI  R26,2
0000ca 27bb      	CLR  R27
                 __CLEAR_REG:
0000cb 93ed      	ST   X+,R30
0000cc 958a      	DEC  R24
0000cd f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
0000ce e080      	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
0000cf e190      	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
0000d0 e0a0      	LDI  R26,LOW(__SRAM_START)
0000d1 e0b1      	LDI  R27,HIGH(__SRAM_START)
                 __CLEAR_SRAM:
0000d2 93ed      	ST   X+,R30
0000d3 9701      	SBIW R24,1
0000d4 f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
0000d5 e5e4      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
0000d6 e0f1      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
0000d7 9185      	LPM  R24,Z+
0000d8 9195      	LPM  R25,Z+
0000d9 9700      	SBIW R24,0
0000da f061      	BREQ __GLOBAL_INI_END
0000db 91a5      	LPM  R26,Z+
0000dc 91b5      	LPM  R27,Z+
0000dd 9005      	LPM  R0,Z+
0000de 9015      	LPM  R1,Z+
0000df 01bf      	MOVW R22,R30
0000e0 01f0      	MOVW R30,R0
                 __GLOBAL_INI_LOOP:
0000e1 9005      	LPM  R0,Z+
0000e2 920d      	ST   X+,R0
0000e3 9701      	SBIW R24,1
0000e4 f7e1      	BRNE __GLOBAL_INI_LOOP
0000e5 01fb      	MOVW R30,R22
0000e6 cff0      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
0000e7 bf8b      	OUT  RAMPZ,R24
                 
                 ;HARDWARE STACK POINTER INITIALIZATION
0000e8 efef      	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
0000e9 bfed      	OUT  SPL,R30
0000ea e1e0      	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
0000eb bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
0000ec e0c0      	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
0000ed e0d5      	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)
                 
0000ee 940c 0af3 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x500
                 
                 	.CSEG
                 ;#include <mega128.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#define __SLEEP_DEFINED__
                 	.EQU __se_bit=0x20
                 	.EQU __sm_mask=0x1C
                 	.EQU __sm_powerdown=0x10
                 	.EQU __sm_powersave=0x18
                 	.EQU __sm_standby=0x14
                 	.EQU __sm_ext_standby=0x1C
                 	.EQU __sm_adc_noise_red=0x08
                 	.SET power_ctrl_reg=mcucr
                 	#endif
                 ;#include "InEepromLib.h"
                 ;
                 ;#define  EEWE    1
                 ;#define  EEMWE   2
                 ;#define  EERE    0
                 ;
                 ;void _EEPROMWrite( WORD addr, BYTE data )
                 ; 0000 0009 {
                 
                 	.CSEG
                 __EEPROMWrite:
                 ; .FSTART __EEPROMWrite
                 ; 0000 000A      while( EECR & (1 << EEWE) );
0000f0 93aa      	ST   -Y,R26
                 ;	addr -> Y+1
                 ;	data -> Y+0
                 _0x3:
0000f1 99e1      	SBIC 0x1C,1
0000f2 cffe      	RJMP _0x3
                 ; 0000 000B      EEAR = addr;
0000f3 81e9      	LDD  R30,Y+1
0000f4 81fa      	LDD  R31,Y+1+1
0000f5 bbff      	OUT  0x1E+1,R31
0000f6 bbee      	OUT  0x1E,R30
                 ; 0000 000C      EEDR = data;
0000f7 81e8      	LD   R30,Y
0000f8 bbed      	OUT  0x1D,R30
                 ; 0000 000D      EECR |= ( 1 << EEMWE);
0000f9 9ae2      	SBI  0x1C,2
                 ; 0000 000E      EECR |= ( 1 << EEWE);
0000fa 9ae1      	SBI  0x1C,1
                 ; 0000 000F }
0000fb 940c 0446 	JMP  _0x20A000D
                 ; .FEND
                 ;
                 ;BYTE _EEPROMRead( WORD addr)
                 ; 0000 0012 {
                 __EEPROMRead:
                 ; .FSTART __EEPROMRead
                 ; 0000 0013      while( EECR & (1 << EEWE) );
0000fd 93ba      	ST   -Y,R27
0000fe 93aa      	ST   -Y,R26
                 ;	addr -> Y+0
                 _0x6:
0000ff 99e1      	SBIC 0x1C,1
000100 cffe      	RJMP _0x6
                 ; 0000 0014      EEAR = addr;
000101 81e8      	LD   R30,Y
000102 81f9      	LDD  R31,Y+1
000103 bbff      	OUT  0x1E+1,R31
000104 bbee      	OUT  0x1E,R30
                 ; 0000 0015      EECR |= ( 1 << EERE);
000105 9ae0      	SBI  0x1C,0
                 ; 0000 0016      return EEDR;
000106 b3ed      	IN   R30,0x1D
000107 940c 04a5 	JMP  _0x20A000B
                 ; 0000 0017 }
                 ; .FEND
                 ;BYTE E2pRead( WORD Addr )
                 ; 0000 0019 {
                 ; 0000 001A     return _EEPROMRead( Addr );
                 ;	Addr -> Y+0
                 ; 0000 001B }
                 ;void E2pReadLen( BYTE *bDat, BYTE bAddr, BYTE nLen )
                 ; 0000 001D {
                 _E2pReadLen:
                 ; .FSTART _E2pReadLen
                 ; 0000 001E     int i;
                 ; 0000 001F 
                 ; 0000 0020     for( i=0; i< nLen; i++ )
000109 93aa      	ST   -Y,R26
00010a 940e 0b40 	CALL SUBOPT_0x0
                 ;	*bDat -> Y+4
                 ;	bAddr -> Y+3
                 ;	nLen -> Y+2
                 ;	i -> R16,R17
                 _0xA:
00010c 81ea      	LDD  R30,Y+2
00010d 01d8      	MOVW R26,R16
00010e e0f0      	LDI  R31,0
00010f 17ae      	CP   R26,R30
000110 07bf      	CPC  R27,R31
000111 f49c      	BRGE _0xB
                 ; 0000 0021     {
                 ; 0000 0022         bDat[i] = _EEPROMRead( bAddr+i );
000112 01f8      	MOVW R30,R16
000113 81ac      	LDD  R26,Y+4
000114 81bd      	LDD  R27,Y+4+1
000115 0fea      	ADD  R30,R26
000116 1ffb      	ADC  R31,R27
000117 93ff      	PUSH R31
000118 93ef      	PUSH R30
000119 01f8      	MOVW R30,R16
00011a 81ab      	LDD  R26,Y+3
00011b e0b0      	LDI  R27,0
00011c 0fae      	ADD  R26,R30
00011d 1fbf      	ADC  R27,R31
00011e dfde      	RCALL __EEPROMRead
00011f 91af      	POP  R26
000120 91bf      	POP  R27
000121 93ec      	ST   X,R30
                 ; 0000 0023     }
                +
000122 5f0f     +SUBI R16 , LOW ( - 1 )
000123 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
000124 cfe7      	RJMP _0xA
                 _0xB:
                 ; 0000 0024 }
000125 8119      	LDD  R17,Y+1
000126 8108      	LDD  R16,Y+0
000127 940c 0196 	JMP  _0x20A000F
                 ; .FEND
                 ;void E2pWriteLen( BYTE *bDat, BYTE bAddr, BYTE nLen )
                 ; 0000 0026 {
                 _E2pWriteLen:
                 ; .FSTART _E2pWriteLen
                 ; 0000 0027     int i;
                 ; 0000 0028     for( i=0; i< nLen; i++)
000129 93aa      	ST   -Y,R26
00012a 940e 0b40 	CALL SUBOPT_0x0
                 ;	*bDat -> Y+4
                 ;	bAddr -> Y+3
                 ;	nLen -> Y+2
                 ;	i -> R16,R17
                 _0xD:
00012c 81ea      	LDD  R30,Y+2
00012d 01d8      	MOVW R26,R16
00012e e0f0      	LDI  R31,0
00012f 17ae      	CP   R26,R30
000130 07bf      	CPC  R27,R31
000131 f48c      	BRGE _0xE
                 ; 0000 0029     {
                 ; 0000 002A        _EEPROMWrite( bAddr+i, bDat[i] );
000132 01f8      	MOVW R30,R16
000133 81ab      	LDD  R26,Y+3
000134 e0b0      	LDI  R27,0
000135 0fea      	ADD  R30,R26
000136 1ffb      	ADC  R31,R27
000137 93fa      	ST   -Y,R31
000138 93ea      	ST   -Y,R30
000139 01f8      	MOVW R30,R16
00013a 81ae      	LDD  R26,Y+6
00013b 81bf      	LDD  R27,Y+6+1
00013c 0fae      	ADD  R26,R30
00013d 1fbf      	ADC  R27,R31
00013e 91ac      	LD   R26,X
00013f dfb0      	RCALL __EEPROMWrite
                 ; 0000 002B     }
                +
000140 5f0f     +SUBI R16 , LOW ( - 1 )
000141 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
000142 cfe9      	RJMP _0xD
                 _0xE:
                 ; 0000 002C }
000143 8119      	LDD  R17,Y+1
000144 8108      	LDD  R16,Y+0
000145 940c 0196 	JMP  _0x20A000F
                 ; .FEND
                 ;#include <mega128.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <stdio.h>
                 ;#include  "I2CLib.h"
                 ;
                 ;BYTE I2C_WriteSeq( BYTE ChipAddr,WORD address, BYTE *Data, WORD Count )
                 ; 0001 0006 {
                 
                 	.CSEG
                 ; 0001 0007      WORD i;
                 ; 0001 0008 
                 ; 0001 0009 #ifdef CFG_I2C_HIGH_ADDRESS
                 ; 0001 000A    if( address > 0x1fff)
                 ; 0001 000B        return ERROR;
                 ; 0001 000C #else
                 ; 0001 000D    if( address > 0xff)
                 ;	ChipAddr -> Y+8
                 ;	address -> Y+6
                 ;	*Data -> Y+4
                 ;	Count -> Y+2
                 ;	i -> R16,R17
                 ; 0001 000E        return ERROR;
                 ; 0001 000F #endif
                 ; 0001 0010      /* Start */
                 ; 0001 0011      I2C_Start();
                 ; 0001 0012      /*Device Address & Write mode */
                 ; 0001 0013      I2C_ShiftOut( (BYTE)(ChipAddr&0xff) );
                 ; 0001 0014      I2C_Ack();
                 ; 0001 0015 
                 ; 0001 0016 #ifdef CFG_I2C_HIGH_ADDRESS
                 ; 0001 0017      I2C_ShiftOut( (address>>8)&0xff ); /* High Address */
                 ; 0001 0018      I2C_Ack();
                 ; 0001 0019 #endif
                 ; 0001 001A 
                 ; 0001 001B      I2C_ShiftOut( (BYTE)(ChipAddr&0xff) );   /* Low Address */
                 ; 0001 001C      I2C_Ack();
                 ; 0001 001D 
                 ; 0001 001E      for( i=0; i< Count; i++ )
                 ; 0001 001F      {
                 ; 0001 0020     /* Data Read  */
                 ; 0001 0021     I2C_ShiftOut( Data[i] );
                 ; 0001 0022            I2C_Ack();
                 ; 0001 0023      }
                 ; 0001 0024     // I2C_Ack();
                 ; 0001 0025 
                 ; 0001 0026      /** bring SDA high while clock is high */
                 ; 0001 0027      I2C_Stop();
                 ; 0001 0028 
                 ; 0001 0029      //for( i=0; i<500; i++ )
                 ; 0001 002A            i2c_delay();        /* 10mSec delay(no test) */
                 ; 0001 002B 
                 ; 0001 002C      return OK;
                 ; 0001 002D }
                 ;
                 ;
                 ;BYTE I2C_Write( BYTE ChipAddr, WORD address, BYTE dat )
                 ; 0001 0031 {
                 ; 0001 0032    //WORD i;
                 ; 0001 0033 
                 ; 0001 0034 #ifdef CFG_I2C_HIGH_ADDRESS
                 ; 0001 0035    if( address > 0x1fff)
                 ; 0001 0036        return ERROR;
                 ; 0001 0037 #else
                 ; 0001 0038    if( address > 0xff)
                 ;	ChipAddr -> Y+3
                 ;	address -> Y+1
                 ;	dat -> Y+0
                 ; 0001 0039        return ERROR;
                 ; 0001 003A #endif
                 ; 0001 003B 
                 ; 0001 003C    I2C_Start();  // Start
                 ; 0001 003D 
                 ; 0001 003E    // Device Address & Write mode
                 ; 0001 003F    I2C_ShiftOut( ChipAddr&0xfe );
                 ; 0001 0040    I2C_Ack();
                 ; 0001 0041 
                 ; 0001 0042 #ifdef   CFG_I2C_HIGH_ADDRESS
                 ; 0001 0043    // High Address
                 ; 0001 0044    I2C_ShiftOut( (address>>8)&0xff );
                 ; 0001 0045    I2C_Ack();
                 ; 0001 0046 #endif
                 ; 0001 0047 
                 ; 0001 0048    // Low Address
                 ; 0001 0049    I2C_ShiftOut( address&0xff );
                 ; 0001 004A    I2C_Ack();
                 ; 0001 004B 
                 ; 0001 004C    I2C_ShiftOut( dat );     // write data
                 ; 0001 004D    I2C_Ack();
                 ; 0001 004E 
                 ; 0001 004F    // bring SDA high while clock is high
                 ; 0001 0050    I2C_Stop();
                 ; 0001 0051 
                 ; 0001 0052    //for( i=0; i<400; i++ )
                 ; 0001 0053         i2c_delay();        //10mSec delay(no test)
                 ; 0001 0054 
                 ; 0001 0055    return OK;
                 ; 0001 0056 }
                 ;
                 ;void i2c_delay(void)
                 ; 0001 0059 {
                 _i2c_delay:
                 ; .FSTART _i2c_delay
                 ; 0001 005A   // int i;
                 ; 0001 005B 
                 ; 0001 005C //   for( i=0; i<10;i++ )    //
                 ; 0001 005D  //    for( i=0; i<2;i++ )    //
                 ; 0001 005E 
                 ; 0001 005F        #asm( "nop" );
000147 0000      	nop
                 ; 0001 0060 }
000148 9508      	RET
                 ; .FEND
                 ;
                 ;BYTE I2C_Ack(void )
                 ; 0001 0063 {
                 ; 0001 0064      BYTE Ack;
                 ; 0001 0065 
                 ; 0001 0066      HIGH_SDA;
                 ;	Ack -> R17
                 ; 0001 0067 
                 ; 0001 0068      I2C_R_MODE; //DDRC.2 = 0;
                 ; 0001 0069      HIGH_SCLK;
                 ; 0001 006A      i2c_delay();
                 ; 0001 006B      Ack = IN_SDA;
                 ; 0001 006C      i2c_delay();
                 ; 0001 006D      LOW_SCLK;
                 ; 0001 006E 
                 ; 0001 006F      I2C_W_MODE; //DDRC.2 = 1;
                 ; 0001 0070      i2c_delay();
                 ; 0001 0071 
                 ; 0001 0072      if( Ack )
                 ; 0001 0073         return ERROR;
                 ; 0001 0074 
                 ; 0001 0075      return OK;
                 ; 0001 0076 }
                 ;
                 ;BYTE I2C_OutAck( BYTE Flag  )
                 ; 0001 0079 {
                 ; 0001 007A        //BYTE Ack;
                 ; 0001 007B 
                 ; 0001 007C        if( Flag )    HIGH_SDA;
                 ;	Flag -> Y+0
                 ; 0001 007D         else        LOW_SDA;
                 ; 0001 007E        /*LOW_SCLK; */
                 ; 0001 007F 
                 ; 0001 0080        /*i2c_delay(); */
                 ; 0001 0081        HIGH_SCLK;
                 ; 0001 0082       // Ack = IN_SDA;//ioport1&0x80;
                 ; 0001 0083        i2c_delay();
                 ; 0001 0084        LOW_SCLK;
                 ; 0001 0085 
                 ; 0001 0086        i2c_delay();
                 ; 0001 0087 
                 ; 0001 0088        //if( Ack )
                 ; 0001 0089 //    return ERROR;
                 ; 0001 008A 
                 ; 0001 008B        return OK;
                 ; 0001 008C }
                 ;
                 ;
                 ;BYTE I2C_ReadSeq( BYTE ChipAddr,WORD address, BYTE *Data, WORD Count )
                 ; 0001 0090 {
                 ; 0001 0091      WORD i;
                 ; 0001 0092 
                 ; 0001 0093 #ifdef CFG_I2C_HIGH_ADDRESS
                 ; 0001 0094    if( address > 0x1fff)
                 ; 0001 0095        return ERROR;
                 ; 0001 0096 #else
                 ; 0001 0097    if( address > 0xff)
                 ;	ChipAddr -> Y+8
                 ;	address -> Y+6
                 ;	*Data -> Y+4
                 ;	Count -> Y+2
                 ;	i -> R16,R17
                 ; 0001 0098        return ERROR;
                 ; 0001 0099 #endif
                 ; 0001 009A      /* Start */
                 ; 0001 009B      I2C_Start();
                 ; 0001 009C      // Device Address & Write mod
                 ; 0001 009D      I2C_ShiftOut( (BYTE)(ChipAddr&0xff) );
                 ; 0001 009E      I2C_Ack();
                 ; 0001 009F 
                 ; 0001 00A0 #ifdef CFG_I2C_HIGH_ADDRESS
                 ; 0001 00A1      // High Address
                 ; 0001 00A2      I2C_ShiftOut( (address>>8)&0xff );
                 ; 0001 00A3      I2C_Ack();
                 ; 0001 00A4 #endif
                 ; 0001 00A5      // Low Address
                 ; 0001 00A6      I2C_ShiftOut( address&0xff );
                 ; 0001 00A7      I2C_Ack();
                 ; 0001 00A8 
                 ; 0001 00A9      /* Start */
                 ; 0001 00AA      I2C_Start();
                 ; 0001 00AB      /*Device Address & Read mode */
                 ; 0001 00AC      I2C_ShiftOut( 0x01|(BYTE)(ChipAddr&0xff) );
                 ; 0001 00AD      I2C_Ack();
                 ; 0001 00AE 
                 ; 0001 00AF      for( i=0; i< Count-1; i++ )
                 ; 0001 00B0      {
                 ; 0001 00B1      /* Data Read  */
                 ; 0001 00B2      Data[i] = I2C_ShiftIn();
                 ; 0001 00B3            // I2C_Ack();
                 ; 0001 00B4            I2C_OutAck( FALSE );
                 ; 0001 00B5      }
                 ; 0001 00B6       Data[i] =    I2C_ShiftIn();
                 ; 0001 00B7       I2C_OutAck( TRUE );
                 ; 0001 00B8      //I2C_Ack();
                 ; 0001 00B9      /** bring SDA high while clock is high */
                 ; 0001 00BA      I2C_Stop();
                 ; 0001 00BB 
                 ; 0001 00BC      return OK;
                 ; 0001 00BD }
                 ;
                 ;BYTE I2C_Read( BYTE ChipAddr, WORD address )
                 ; 0001 00C0 {
                 ; 0001 00C1      BYTE Dat;
                 ; 0001 00C2 
                 ; 0001 00C3 #ifdef CFG_I2C_HIGH_ADDRESS
                 ; 0001 00C4    if( address > 0x1fff)
                 ; 0001 00C5        return ERROR;
                 ; 0001 00C6 #else
                 ; 0001 00C7    if( address > 0xff)
                 ;	ChipAddr -> Y+3
                 ;	address -> Y+1
                 ;	Dat -> R17
                 ; 0001 00C8        return ERROR;
                 ; 0001 00C9 #endif
                 ; 0001 00CA 
                 ; 0001 00CB      I2C_Start();   // Start
                 ; 0001 00CC 
                 ; 0001 00CD      /*Device Address & Write mode */
                 ; 0001 00CE      I2C_ShiftOut( (BYTE)(ChipAddr&0xff) );
                 ; 0001 00CF      I2C_Ack();
                 ; 0001 00D0 
                 ; 0001 00D1 #ifdef CFG_I2C_HIGH_ADDRESS
                 ; 0001 00D2      // High Address
                 ; 0001 00D3      I2C_ShiftOut( (address>>8)&0xff );
                 ; 0001 00D4      I2C_Ack();
                 ; 0001 00D5 #endif
                 ; 0001 00D6 
                 ; 0001 00D7      // Low Address
                 ; 0001 00D8      I2C_ShiftOut( address&0xff );
                 ; 0001 00D9      I2C_Ack();
                 ; 0001 00DA 
                 ; 0001 00DB      // Start
                 ; 0001 00DC      I2C_Start();
                 ; 0001 00DD      // Device Address & Read mode
                 ; 0001 00DE      I2C_ShiftOut( 0x01| (BYTE)(ChipAddr&0xff) );
                 ; 0001 00DF 
                 ; 0001 00E0      I2C_Ack();
                 ; 0001 00E1 
                 ; 0001 00E2       // Data Read
                 ; 0001 00E3       Dat = I2C_ShiftIn();
                 ; 0001 00E4       I2C_Ack();
                 ; 0001 00E5 
                 ; 0001 00E6       /** bring SDA high while clock is high */
                 ; 0001 00E7       I2C_Stop();
                 ; 0001 00E8 
                 ; 0001 00E9      return Dat;
                 ; 0001 00EA }
                 ;/*
                 ;BYTE I2C_Read( BYTE ChipAddr, WORD address )
                 ;{
                 ;     BYTE Dat;
                 ;
                 ;#ifdef CFG_I2C_HIGH_ADDRESS
                 ;   if( address > 0x1fff)
                 ;       return ERROR;
                 ;#else
                 ;   if( address > 0xff)
                 ;       return ERROR;
                 ;#endif
                 ;
                 ;     I2C_Start();   // Start
                 ;
                 ;     //Device Address & Write mode
                 ;     I2C_ShiftOut(  (BYTE)((ChipAddr<<1)&0x0e) );
                 ;     I2C_Ack();
                 ;
                 ;#ifdef CFG_I2C_HIGH_ADDRESS
                 ;     // High Address
                 ;     I2C_ShiftOut( (address>>8)&0xff );
                 ;     I2C_Ack();
                 ;#endif
                 ;
                 ;     // Low Address
                 ;     I2C_ShiftOut( address&0xff );
                 ;
                 ;     I2C_Ack();
                 ;
                 ;     // Start
                 ;     I2C_Start();
                 ;
                 ;     // Device Address & Read mode
                 ;     I2C_ShiftOut( 0x01| (BYTE)((ChipAddr<<1)&0x0e)  );
                 ;
                 ;     I2C_Ack();
                 ;
                 ;      // Data Read
                 ;      Dat = I2C_ShiftIn();
                 ;
                 ;      I2C_Ack();
                 ;
                 ;      // bring SDA high while clock is high
                 ;            I2C_Stop();
                 ;
                 ;     return Dat;
                 ;}
                 ;*/
                 ;void I2C_Start(void )
                 ; 0001 011D {
                 ; 0001 011E       HIGH_SDA;    /* high serial data  */
                 ; 0001 011F       HIGH_SCLK;   /* high serial clock */
                 ; 0001 0120       i2c_delay();
                 ; 0001 0121       LOW_SDA;     /* low  serial data */
                 ; 0001 0122       i2c_delay();
                 ; 0001 0123       LOW_SCLK;    /* low  serial clock */
                 ; 0001 0124       i2c_delay();
                 ; 0001 0125 }
                 ;
                 ;void I2C_Stop( void )
                 ; 0001 0128 {
                 ; 0001 0129      LOW_SCLK;
                 ; 0001 012A      LOW_SDA;      /* low serial data */
                 ; 0001 012B      i2c_delay();
                 ; 0001 012C      HIGH_SCLK;    /* high serial clock */
                 ; 0001 012D      i2c_delay();
                 ; 0001 012E      HIGH_SDA;     /* high serial data      */
                 ; 0001 012F }
                 ;
                 ;void I2C_ShiftOut( BYTE dat )
                 ; 0001 0132 {
                 ; 0001 0133      BYTE i,temp;
                 ; 0001 0134 
                 ; 0001 0135      for( i=0; i<8; i++ )
                 ;	dat -> Y+2
                 ;	i -> R17
                 ;	temp -> R16
                 ; 0001 0136      {
                 ; 0001 0137         /* right shift */
                 ; 0001 0138         temp = dat & ( 0x80>>i );
                 ; 0001 0139 
                 ; 0001 013A        if( temp )   HIGH_SDA;    /* high data   */
                 ; 0001 013B        else         LOW_SDA;
                 ; 0001 013C        i2c_delay();
                 ; 0001 013D        HIGH_SCLK;              /* high clock   */
                 ; 0001 013E        i2c_delay();
                 ; 0001 013F        LOW_SCLK;               /* low clock    */
                 ; 0001 0140        i2c_delay();
                 ; 0001 0141      }
                 ; 0001 0142 }
                 ;
                 ;BYTE I2C_ShiftIn( void )
                 ; 0001 0145 {
                 ; 0001 0146      BYTE i=0,temp;
                 ; 0001 0147      BYTE Dat=0;
                 ; 0001 0148 
                 ; 0001 0149      HIGH_SDA;
                 ;	i -> R17
                 ;	temp -> R16
                 ;	Dat -> R19
                 ; 0001 014A      I2C_R_MODE;      // input mode
                 ; 0001 014B      for( i=0; i<8; i++ )
                 ; 0001 014C      {
                 ; 0001 014D           //  HIGH_SDA;
                 ; 0001 014E           HIGH_SCLK;         /* high serial clock    */
                 ; 0001 014F           i2c_delay();
                 ; 0001 0150 
                 ; 0001 0151           temp = IN_SDA;     // &0x80;
                 ; 0001 0152           Dat |= ( temp<<(7-i) );
                 ; 0001 0153 
                 ; 0001 0154           i2c_delay();
                 ; 0001 0155           LOW_SCLK;          /* low serial clock; */
                 ; 0001 0156           i2c_delay();
                 ; 0001 0157      }
                 ; 0001 0158 
                 ; 0001 0159       I2C_W_MODE;   // output mode
                 ; 0001 015A 
                 ; 0001 015B      return Dat;
                 ; 0001 015C }
                 ;#include <mega128.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <stdio.h>
                 ;#include <string.h>
                 ;#include <delay.h>
                 ;#include <float.h>
                 ;
                 ;#include "DAC7611.h"
                 ;#include "../I2cLib/I2CLib.h"
                 ;
                 ;//const BYTE VolArray[15] = {4, 8, 14, 21, 30, 40, 50, 65, 82, 93, 110, 124, 138, 150, 160};
                 ;//const BYTE VolArray[15] = {5, 8, 14, 20, 30, 40, 53, 65, 82, 93, 110, 124, 138, 150, 160};
                 ;
                 ;                           //20 30 40  50  60  70  80  90  100 110 120  130  140  150  160   2020-10-21
                 ;const BYTE VolArray[15] =   {5, 11, 18, 26, 40, 51, 63, 74, 85, 93, 109, 124, 138, 150, 160};
                 ;
                 ;void DAC7611_init( void )
                 ; 0002 0011 {
                 
                 	.CSEG
                 _DAC7611_init:
                 ; .FSTART _DAC7611_init
                 ; 0002 0012    DAC7611_Write( 0 );
000149 e0a0      	LDI  R26,LOW(0)
00014a e0b0      	LDI  R27,0
00014b d021      	RCALL _DAC7611_Write
                 ; 0002 0013 }
00014c 9508      	RET
                 ; .FEND
                 ;
                 ;void DAC7611_WriteVoltage( int data )
                 ; 0002 0016 {
                 _DAC7611_WriteVoltage:
                 ; .FSTART _DAC7611_WriteVoltage
                 ; 0002 0017    WORD temp;
                 ; 0002 0018    int mRefVol;
                 ; 0002 0019 
                 ; 0002 001A    if(data < 20 )
00014d 940e 0b45 	CALL SUBOPT_0x1
                 ;	data -> Y+4
                 ;	temp -> R16,R17
                 ;	mRefVol -> R18,R19
00014f 81ac      	LDD  R26,Y+4
000150 81bd      	LDD  R27,Y+4+1
000151 9754      	SBIW R26,20
000152 f41c      	BRGE _0x40003
                 ; 0002 001B    {
                 ; 0002 001C       mRefVol = 0;
                +
000153 e020     +LDI R18 , LOW ( 0 )
000154 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 ; 0002 001D    }
                 ; 0002 001E    else
000155 c009      	RJMP _0x40004
                 _0x40003:
                 ; 0002 001F    {
                 ; 0002 0020       mRefVol =  (data-20)/10;
000156 81ac      	LDD  R26,Y+4
000157 81bd      	LDD  R27,Y+4+1
000158 940e 0b4a 	CALL SUBOPT_0x2
00015a 019f      	MOVW R18,R30
                 ; 0002 0021       mRefVol = VolArray[mRefVol];
00015b 57e4      	SUBI R30,LOW(-_VolArray*2)
00015c 4fff      	SBCI R31,HIGH(-_VolArray*2)
00015d 9124      	LPM  R18,Z
00015e 2733      	CLR  R19
                 ; 0002 0022    }
                 _0x40004:
                 ; 0002 0023 
                 ; 0002 0024    temp = (WORD)(4095.0f/160.0f* (float)mRefVol);
00015f 940e 0b50 	CALL SUBOPT_0x3
                +
000161 e0a0     +LDI R26 , LOW ( 0x41CCC000 )
000162 ecb0     +LDI R27 , HIGH ( 0x41CCC000 )
000163 ec8c     +LDI R24 , BYTE3 ( 0x41CCC000 )
000164 e491     +LDI R25 , BYTE4 ( 0x41CCC000 )
                 	__GETD2N 0x41CCC000
000165 940e 0eda 	CALL __MULF12
000167 940e 0e17 	CALL __CFD1U
000169 018f      	MOVW R16,R30
                 ; 0002 0025 
                 ; 0002 0026    DAC7611_Write( temp );
00016a 01d8      	MOVW R26,R16
00016b d001      	RCALL _DAC7611_Write
                 ; 0002 0027 }
00016c c027      	RJMP _0x20A000E
                 ; .FEND
                 ;
                 ;void DAC7611_Write( WORD data )
                 ; 0002 002A {
                 _DAC7611_Write:
                 ; .FSTART _DAC7611_Write
                 ; 0002 002B      int i;
                 ; 0002 002C      WORD temp;
                 ; 0002 002D 
                 ; 0002 002E      HIGH_LD;
00016d 940e 0b45 	CALL SUBOPT_0x1
                 ;	data -> Y+4
                 ;	i -> R16,R17
                 ;	temp -> R18,R19
00016f 9adb      	SBI  0x1B,3
                 ; 0002 002F      HIGH_SCLK;
000170 9ad9      	SBI  0x1B,1
                 ; 0002 0030      LOW_CS;
000171 98da      	CBI  0x1B,2
                 ; 0002 0031 
                 ; 0002 0032      for( i=0; i<12; i++ )
                +
000172 e000     +LDI R16 , LOW ( 0 )
000173 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x4000C:
                +
000174 300c     +CPI R16 , LOW ( 12 )
000175 e0e0     +LDI R30 , HIGH ( 12 )
000176 071e     +CPC R17 , R30
                 	__CPWRN 16,17,12
000177 f4c4      	BRGE _0x4000D
                 ; 0002 0033      {
                 ; 0002 0034         /* right shift */
                 ; 0002 0035        temp = data & ( 0x800>>i );
000178 2fe0      	MOV  R30,R16
000179 e0a0      	LDI  R26,LOW(2048)
00017a e0b8      	LDI  R27,HIGH(2048)
00017b 940e 0fa9 	CALL __LSRW12
00017d 81ac      	LDD  R26,Y+4
00017e 81bd      	LDD  R27,Y+4+1
00017f 23ea      	AND  R30,R26
000180 23fb      	AND  R31,R27
000181 019f      	MOVW R18,R30
                 ; 0002 0036 
                 ; 0002 0037        if( temp ) HIGH_SDA;    /* high data  */
000182 2e02      	MOV  R0,R18
000183 2a03      	OR   R0,R19
000184 f011      	BREQ _0x4000E
000185 9ad8      	SBI  0x1B,0
                 ; 0002 0038        else       LOW_SDA;
000186 c001      	RJMP _0x40011
                 _0x4000E:
000187 98d8      	CBI  0x1B,0
                 ; 0002 0039 
                 ; 0002 003A        i2c_delay();
                 _0x40011:
000188 dfbe      	RCALL _i2c_delay
                 ; 0002 003B        LOW_SCLK;          /* high clock */
000189 98d9      	CBI  0x1B,1
                 ; 0002 003C        i2c_delay();
00018a dfbc      	RCALL _i2c_delay
                 ; 0002 003D        HIGH_SCLK;         /* low clock    */
00018b 9ad9      	SBI  0x1B,1
                 ; 0002 003E        i2c_delay();
00018c dfba      	RCALL _i2c_delay
                 ; 0002 003F      }
                +
00018d 5f0f     +SUBI R16 , LOW ( - 1 )
00018e 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00018f cfe4      	RJMP _0x4000C
                 _0x4000D:
                 ; 0002 0040 
                 ; 0002 0041      HIGH_CS;
000190 9ada      	SBI  0x1B,2
                 ; 0002 0042 
                 ; 0002 0043      LOW_LD;
000191 98db      	CBI  0x1B,3
                 ; 0002 0044      i2c_delay();
000192 dfb4      	RCALL _i2c_delay
                 ; 0002 0045      HIGH_LD;
000193 9adb      	SBI  0x1B,3
                 ; 0002 0046 }
                 _0x20A000E:
000194 940e 100b 	CALL __LOADLOCR4
                 _0x20A000F:
000196 9626      	ADIW R28,6
000197 9508      	RET
                 ; .FEND
                 ;#include <stdio.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include "IPCLib.h"
                 ;#include <string.h>
                 ;#include <math.h>
                 ;#include "../Uart/uart.h"
                 ;#include "../I2CLib/I2CLIb.h"
                 ;#include "../InADC/InAdc.h"
                 ;#include "../DAC7611/DAC7611.h"
                 ;
                 ;extern BYTE gElMatrix[4];
                 ;extern WORD goldTime1ms;
                 ;extern WORD gTime1ms;
                 ;extern int gVoltage;
                 ;extern BYTE gMode;
                 ;extern BOOL gRunFlag;
                 ;extern int gDose;
                 ;extern int gDepth;
                 ;extern int gSpeed;
                 ;extern BYTE gFlag;
                 ;extern BYTE gError;
                 ;extern int gMotorPos1;
                 ;extern int gMotorPos2;
                 ;extern BOOL gElCompletFlag;
                 ;extern int  gElCount;
                 ;//extern int  gReadVol;
                 ;extern BYTE gCurMode;
                 ;extern BOOL gReadyActionFlag;
                 ;extern int  gVolChkCount;
                 ;
                 ;extern void SaveInEeprom( void );
                 ;BYTE IPC1_RCV_MODE( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_RUN( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_DOSE( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_VOLTAGE( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_DEPTH( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_SPEED( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_ELCOUNT( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_FLAG( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_EL_MAP( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_MOTOR_POS1( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_MOTOR_POS2( LPIPC_HEADER pHead );
                 ;BYTE IPC1_RCV_ERROR( LPIPC_HEADER pHead );
                 ;typedef BYTE(*RunFun) (LPIPC_HEADER pHead );
                 ;
                 ;RunFun IPC1Rcvfun[]=
                 ;{
                 ;     IPC1_RCV_MODE,
                 ;     IPC1_RCV_RUN,
                 ;     IPC1_RCV_DOSE,
                 ;     IPC1_RCV_VOLTAGE,
                 ;     IPC1_RCV_DEPTH,
                 ;     IPC1_RCV_SPEED,
                 ;     IPC1_RCV_ELCOUNT,
                 ;     IPC1_RCV_FLAG,
                 ;     IPC1_RCV_EL_MAP,
                 ;     IPC1_RCV_MOTOR_POS1,
                 ;     IPC1_RCV_MOTOR_POS2,
                 ;     IPC1_RCV_ERROR
                 ;};
                 
                 	.DSEG
                 ;
                 ;BYTE IPC1_RCV_MODE( LPIPC_HEADER pHead )
                 ; 0003 003E {
                 
                 	.CSEG
                 _IPC1_RCV_MODE:
                 ; .FSTART _IPC1_RCV_MODE
                 ; 0003 003F     return TRUE;
000198 93ba      	ST   -Y,R27
000199 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
00019a c309      	RJMP _0x20A000A
                 ; 0003 0040 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_RUN( LPIPC_HEADER pHead )
                 ; 0003 0043 {
                 _IPC1_RCV_RUN:
                 ; .FSTART _IPC1_RCV_RUN
                 ; 0003 0044    //gRunFlag =  pHead->data1;
                 ; 0003 0045    //gRunFlag = gRunFlag?TRUE:FALSE;
                 ; 0003 0046    BOOL mFlag =  pHead->data1? TRUE:FALSE;
                 ; 0003 0047    if( mFlag )
00019b 940e 0b56 	CALL SUBOPT_0x4
                 ;	*pHead -> Y+1
                 ;	mFlag -> R17
00019d 81e3      	LDD  R30,Z+3
00019e 30e0      	CPI  R30,0
00019f f011      	BREQ _0x60004
0001a0 e0e1      	LDI  R30,LOW(1)
0001a1 c001      	RJMP _0x60005
                 _0x60004:
0001a2 e0e0      	LDI  R30,LOW(0)
                 _0x60005:
0001a3 2f1e      	MOV  R17,R30
0001a4 3010      	CPI  R17,0
0001a5 f011      	BREQ _0x60007
                 ; 0003 0048        SaveInEeprom();
0001a6 940e 0885 	CALL _SaveInEeprom
                 ; 0003 0049 
                 ; 0003 004A    return TRUE;
                 _0x60007:
0001a8 c29b      	RJMP _0x20A000C
                 ; 0003 004B }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_DOSE( LPIPC_HEADER pHead )
                 ; 0003 004E {
                 _IPC1_RCV_DOSE:
                 ; .FSTART _IPC1_RCV_DOSE
                 ; 0003 004F    gDose = pHead->data2 | ((int)pHead->data1<<8);
0001a9 940e 0b5c 	CALL SUBOPT_0x5
                 ;	*pHead -> Y+0
0001ab 81a4      	LDD  R26,Z+4
0001ac 81e8      	LD   R30,Y
0001ad 81f9      	LDD  R31,Y+1
0001ae 81e3      	LDD  R30,Z+3
0001af 2ffe      	MOV  R31,R30
0001b0 e0e0      	LDI  R30,0
0001b1 2bea      	OR   R30,R26
0001b2 940e 0b61 	CALL SUBOPT_0x6
                 ; 0003 0050    if( gDose < 0 ) gDose = 0;
0001b4 91a0 050d 	LDS  R26,_gDose+1
0001b6 23aa      	TST  R26
0001b7 f412      	BRPL _0x60008
0001b8 940e 0b66 	CALL SUBOPT_0x7
                 ; 0003 0051    if( gDose > 3 ) gDose = 3;
                 _0x60008:
0001ba 91a0 050c 	LDS  R26,_gDose
0001bc 91b0 050d 	LDS  R27,_gDose+1
0001be 9714      	SBIW R26,4
0001bf f024      	BRLT _0x60009
0001c0 e0e3      	LDI  R30,LOW(3)
0001c1 e0f0      	LDI  R31,HIGH(3)
0001c2 940e 0b61 	CALL SUBOPT_0x6
                 ; 0003 0052 
                 ; 0003 0053    return TRUE;
                 _0x60009:
0001c4 c2df      	RJMP _0x20A000A
                 ; 0003 0054 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_VOLTAGE( LPIPC_HEADER pHead )
                 ; 0003 0057 {
                 _IPC1_RCV_VOLTAGE:
                 ; .FSTART _IPC1_RCV_VOLTAGE
                 ; 0003 0058    gVoltage = pHead->data1;
0001c5 940e 0b5c 	CALL SUBOPT_0x5
                 ;	*pHead -> Y+0
0001c7 81e3      	LDD  R30,Z+3
0001c8 940e 0b6c 	CALL SUBOPT_0x8
                 ; 0003 0059    if( gVoltage < 60 ) gVoltage = 60;
0001ca f414      	BRGE _0x6000A
0001cb 940e 0b77 	CALL SUBOPT_0x9
                 ; 0003 005A    if( gVoltage > 120 ) gVoltage = 120;
                 _0x6000A:
0001cd 940e 0b7e 	CALL SUBOPT_0xA
0001cf 37a9      	CPI  R26,LOW(0x79)
0001d0 e0e0      	LDI  R30,HIGH(0x79)
0001d1 07be      	CPC  R27,R30
0001d2 f014      	BRLT _0x6000B
0001d3 940e 0b83 	CALL SUBOPT_0xB
                 ; 0003 005B 
                 ; 0003 005C    if( gVoltage > 50 ) LOW_VOLRY;
                 _0x6000B:
0001d5 940e 0b7e 	CALL SUBOPT_0xA
0001d7 97d3      	SBIW R26,51
0001d8 f014      	BRLT _0x6000C
0001d9 9897      	CBI  0x12,7
                 ; 0003 005D    else  HIGH_VOLRY;
0001da c001      	RJMP _0x6000F
                 _0x6000C:
0001db 9a97      	SBI  0x12,7
                 ; 0003 005E 
                 ; 0003 005F   // DAC7611_WriteVoltage(gVoltage);
                 ; 0003 0060 
                 ; 0003 0061    return TRUE;
                 _0x6000F:
0001dc c2c7      	RJMP _0x20A000A
                 ; 0003 0062 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_DEPTH( LPIPC_HEADER pHead )
                 ; 0003 0065 {
                 _IPC1_RCV_DEPTH:
                 ; .FSTART _IPC1_RCV_DEPTH
                 ; 0003 0066    gDepth = pHead->data1;
0001dd 940e 0b5c 	CALL SUBOPT_0x5
                 ;	*pHead -> Y+0
0001df 81e3      	LDD  R30,Z+3
0001e0 940e 0b8a 	CALL SUBOPT_0xC
                 ; 0003 0067    if( gDepth < 0 ) gDepth = 0;
0001e2 f412      	BRPL _0x60012
0001e3 940e 0b93 	CALL SUBOPT_0xD
                 ; 0003 0068    if( gDepth > 3 ) gDepth = 3;
                 _0x60012:
0001e5 91a0 050e 	LDS  R26,_gDepth
0001e7 91b0 050f 	LDS  R27,_gDepth+1
0001e9 9714      	SBIW R26,4
0001ea f014      	BRLT _0x60013
0001eb 940e 0b99 	CALL SUBOPT_0xE
                 ; 0003 0069 
                 ; 0003 006A    return TRUE;
                 _0x60013:
0001ed c2b6      	RJMP _0x20A000A
                 ; 0003 006B }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_SPEED( LPIPC_HEADER pHead )
                 ; 0003 006E {
                 _IPC1_RCV_SPEED:
                 ; .FSTART _IPC1_RCV_SPEED
                 ; 0003 006F    gSpeed = pHead->data1;
0001ee 940e 0b5c 	CALL SUBOPT_0x5
                 ;	*pHead -> Y+0
0001f0 81e3      	LDD  R30,Z+3
0001f1 940e 0ba0 	CALL SUBOPT_0xF
                 ; 0003 0070    if( gSpeed < 0 ) gSpeed = 0;
0001f3 f42a      	BRPL _0x60014
0001f4 e0e0      	LDI  R30,LOW(0)
0001f5 93e0 0510 	STS  _gSpeed,R30
0001f7 93e0 0511 	STS  _gSpeed+1,R30
                 ; 0003 0071    if( gSpeed > 2 ) gSpeed = 2;
                 _0x60014:
0001f9 91a0 0510 	LDS  R26,_gSpeed
0001fb 91b0 0511 	LDS  R27,_gSpeed+1
0001fd 9713      	SBIW R26,3
0001fe f014      	BRLT _0x60015
0001ff 940e 0ba9 	CALL SUBOPT_0x10
                 ; 0003 0072 
                 ; 0003 0073    return TRUE;
                 _0x60015:
000201 c2a2      	RJMP _0x20A000A
                 ; 0003 0074 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_ELCOUNT( LPIPC_HEADER pHead )
                 ; 0003 0077 {
                 _IPC1_RCV_ELCOUNT:
                 ; .FSTART _IPC1_RCV_ELCOUNT
                 ; 0003 0078    gElCount = pHead->data1;
000202 940e 0b5c 	CALL SUBOPT_0x5
                 ;	*pHead -> Y+0
000204 81e3      	LDD  R30,Z+3
000205 e0f0      	LDI  R31,0
000206 940e 0bb0 	CALL SUBOPT_0x11
                 ; 0003 0079    if( gElCount < 0 ) gElCount = 0;
000208 91a0 051a 	LDS  R26,_gElCount+1
00020a 23aa      	TST  R26
00020b f42a      	BRPL _0x60016
00020c e0e0      	LDI  R30,LOW(0)
00020d 93e0 0519 	STS  _gElCount,R30
00020f 93e0 051a 	STS  _gElCount+1,R30
                 ; 0003 007A    if( gElCount > 100 ) gElCount = 100;
                 _0x60016:
000211 91a0 0519 	LDS  R26,_gElCount
000213 91b0 051a 	LDS  R27,_gElCount+1
000215 36a5      	CPI  R26,LOW(0x65)
000216 e0e0      	LDI  R30,HIGH(0x65)
000217 07be      	CPC  R27,R30
000218 f024      	BRLT _0x60017
000219 e6e4      	LDI  R30,LOW(100)
00021a e0f0      	LDI  R31,HIGH(100)
00021b 940e 0bb0 	CALL SUBOPT_0x11
                 ; 0003 007B 
                 ; 0003 007C    return TRUE;
                 _0x60017:
00021d c286      	RJMP _0x20A000A
                 ; 0003 007D }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_FLAG( LPIPC_HEADER pHead )
                 ; 0003 0080 {
                 _IPC1_RCV_FLAG:
                 ; .FSTART _IPC1_RCV_FLAG
                 ; 0003 0081    gFlag = pHead->data2;
00021e 940e 0b5c 	CALL SUBOPT_0x5
                 ;	*pHead -> Y+0
000220 81e4      	LDD  R30,Z+4
000221 93e0 0512 	STS  _gFlag,R30
                 ; 0003 0082 
                 ; 0003 0083    return TRUE;
000223 c280      	RJMP _0x20A000A
                 ; 0003 0084 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_EL_MAP( LPIPC_HEADER pHead )
                 ; 0003 0087 {
                 _IPC1_RCV_EL_MAP:
                 ; .FSTART _IPC1_RCV_EL_MAP
                 ; 0003 0088    gElMatrix[0] = (BYTE)((pHead->data1>>4)&0xf);
000224 940e 0b5c 	CALL SUBOPT_0x5
                 ;	*pHead -> Y+0
000226 81e3      	LDD  R30,Z+3
000227 95e2      	SWAP R30
000228 70ef      	ANDI R30,LOW(0xF)
000229 93e0 0500 	STS  _gElMatrix,R30
                 ; 0003 0089    gElMatrix[1] = (BYTE)(pHead->data1&0xf);
00022b 81e8      	LD   R30,Y
00022c 81f9      	LDD  R31,Y+1
00022d 81a3      	LDD  R26,Z+3
00022e e0ef      	LDI  R30,LOW(15)
00022f 23ea      	AND  R30,R26
                +
000230 93e0 0501+STS _gElMatrix + ( 1 ) , R30
                 	__PUTB1MN _gElMatrix,1
                 ; 0003 008A    gElMatrix[2] = (BYTE)((pHead->data2>>4)&0xf);
000232 81e8      	LD   R30,Y
000233 81f9      	LDD  R31,Y+1
000234 81e4      	LDD  R30,Z+4
000235 95e2      	SWAP R30
000236 70ef      	ANDI R30,LOW(0xF)
                +
000237 93e0 0502+STS _gElMatrix + ( 2 ) , R30
                 	__PUTB1MN _gElMatrix,2
                 ; 0003 008B    gElMatrix[3] = (BYTE)(pHead->data2&0xf);
000239 81e8      	LD   R30,Y
00023a 81f9      	LDD  R31,Y+1
00023b 81a4      	LDD  R26,Z+4
00023c e0ef      	LDI  R30,LOW(15)
00023d 23ea      	AND  R30,R26
                +
00023e 93e0 0503+STS _gElMatrix + ( 3 ) , R30
                 	__PUTB1MN _gElMatrix,3
                 ; 0003 008C 
                 ; 0003 008D    return TRUE;
000240 c263      	RJMP _0x20A000A
                 ; 0003 008E }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_MOTOR_POS1( LPIPC_HEADER pHead )
                 ; 0003 0091 {
                 _IPC1_RCV_MOTOR_POS1:
                 ; .FSTART _IPC1_RCV_MOTOR_POS1
                 ; 0003 0092    return TRUE;
000241 93ba      	ST   -Y,R27
000242 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
000243 c260      	RJMP _0x20A000A
                 ; 0003 0093 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_MOTOR_POS2( LPIPC_HEADER pHead )
                 ; 0003 0096 {
                 _IPC1_RCV_MOTOR_POS2:
                 ; .FSTART _IPC1_RCV_MOTOR_POS2
                 ; 0003 0097    return TRUE;
000244 93ba      	ST   -Y,R27
000245 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
000246 c25d      	RJMP _0x20A000A
                 ; 0003 0098 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_RCV_ERROR( LPIPC_HEADER pHead )
                 ; 0003 009B {
                 _IPC1_RCV_ERROR:
                 ; .FSTART _IPC1_RCV_ERROR
                 ; 0003 009C    BYTE mErrPos = pHead->data1;
                 ; 0003 009D    BOOL mSetClearFlag = pHead->data2?TRUE:FALSE;
                 ; 0003 009E 
                 ; 0003 009F    if( mErrPos> ERROR_EM_STOP )
000247 940e 0bb5 	CALL SUBOPT_0x12
                 ;	*pHead -> Y+2
                 ;	mErrPos -> R17
                 ;	mSetClearFlag -> R16
000249 81ea      	LDD  R30,Y+2
00024a 81fb      	LDD  R31,Y+2+1
00024b 81e3      	LDD  R30,Z+3
00024c 2f1e      	MOV  R17,R30
00024d 81ea      	LDD  R30,Y+2
00024e 81fb      	LDD  R31,Y+2+1
00024f 81e4      	LDD  R30,Z+4
000250 30e0      	CPI  R30,0
000251 f011      	BREQ _0x60018
000252 e0e1      	LDI  R30,LOW(1)
000253 c001      	RJMP _0x60019
                 _0x60018:
000254 e0e0      	LDI  R30,LOW(0)
                 _0x60019:
000255 2f0e      	MOV  R16,R30
000256 3018      	CPI  R17,8
000257 f008      	BRLO _0x6001B
                 ; 0003 00A0        mErrPos = ERROR_EM_STOP;
000258 e017      	LDI  R17,LOW(7)
                 ; 0003 00A1 
                 ; 0003 00A2    if( mSetClearFlag )
                 _0x6001B:
000259 3000      	CPI  R16,0
00025a f039      	BREQ _0x6001C
                 ; 0003 00A3         gError &= ~(1<<mErrPos);
00025b 940e 0bba 	CALL SUBOPT_0x13
00025d 95e0      	COM  R30
00025e 91a0 0513 	LDS  R26,_gError
000260 23ea      	AND  R30,R26
000261 c005      	RJMP _0x6004D
                 ; 0003 00A4    else gError |= (1<<mErrPos);
                 _0x6001C:
000262 940e 0bba 	CALL SUBOPT_0x13
000264 91a0 0513 	LDS  R26,_gError
000266 2bea      	OR   R30,R26
                 _0x6004D:
000267 93e0 0513 	STS  _gError,R30
                 ; 0003 00A5 
                 ; 0003 00A6    return TRUE;
000269 e0e1      	LDI  R30,LOW(1)
00026a 8119      	LDD  R17,Y+1
00026b 8108      	LDD  R16,Y+0
00026c 9624      	ADIW R28,4
00026d 9508      	RET
                 ; 0003 00A7 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_MODE( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_RUN( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_DOSE( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_VOLTAGE( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_DEPTH( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_SPEED( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_ELCOUNT( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_FLAG( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_EL_MAP( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_MOTOR_POS1( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_MOTOR_POS2( LPIPC_HEADER pHead );
                 ;BYTE IPC1_SND_ERROR( LPIPC_HEADER pHead );
                 ;typedef BYTE(*SenFun) (LPIPC_HEADER pHead);
                 ;
                 ;SenFun IPC1Sndfun[]=
                 ;{
                 ;     IPC1_SND_MODE,
                 ;     IPC1_SND_RUN,
                 ;     IPC1_SND_DOSE,
                 ;     IPC1_SND_VOLTAGE,
                 ;     IPC1_SND_DEPTH,
                 ;     IPC1_SND_SPEED,
                 ;     IPC1_SND_ELCOUNT,
                 ;     IPC1_SND_FLAG,
                 ;     IPC1_SND_EL_MAP,
                 ;     IPC1_SND_MOTOR_POS1,
                 ;     IPC1_SND_MOTOR_POS2,
                 ;     IPC1_SND_ERROR
                 ;};
                 
                 	.DSEG
                 ;
                 ;BYTE IPC1_SND_MODE( LPIPC_HEADER pHead )
                 ; 0003 00C8 {
                 
                 	.CSEG
                 _IPC1_SND_MODE:
                 ; .FSTART _IPC1_SND_MODE
                 ; 0003 00C9    pHead->Command = SYS_OK;
00026e 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 00CA    pHead->data1 = 0;//(BYTE)((gMode>>8)&0xff);  //
000270 e0e0      	LDI  R30,LOW(0)
000271 940e 0bca 	CALL SUBOPT_0x15
                 ; 0003 00CB    pHead->data2 = (BYTE)(gMode&0xff);
                 ; 0003 00CC 
                 ; 0003 00CD    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000273 940e 0bd2 	CALL SUBOPT_0x16
000275 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 00CE 
                 ; 0003 00CF    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
000277 e0a7      	LDI  R26,LOW(7)
000278 940e 0573 	CALL _IPC_SendData1
                 ; 0003 00D0    return TRUE;
00027a c229      	RJMP _0x20A000A
                 ; 0003 00D1 }
                 ; .FEND
                 ;BYTE IPC1_SND_RUN( LPIPC_HEADER pHead )
                 ; 0003 00D3 {
                 _IPC1_SND_RUN:
                 ; .FSTART _IPC1_SND_RUN
                 ; 0003 00D4    pHead->Command = SYS_OK;
00027b 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 00D5    pHead->data1 = 1;  //
00027d 940e 0be0 	CALL SUBOPT_0x18
                 ; 0003 00D6    pHead->data2 = (BYTE)(gRunFlag&0xff);
                 ; 0003 00D7 
                 ; 0003 00D8    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
00027f 940e 0bd2 	CALL SUBOPT_0x16
000281 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 00D9 
                 ; 0003 00DA    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
000283 e0a7      	LDI  R26,LOW(7)
000284 940e 0573 	CALL _IPC_SendData1
                 ; 0003 00DB    return TRUE;
000286 c21d      	RJMP _0x20A000A
                 ; 0003 00DC }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_DOSE( LPIPC_HEADER pHead )
                 ; 0003 00DF {
                 _IPC1_SND_DOSE:
                 ; .FSTART _IPC1_SND_DOSE
                 ; 0003 00E0    pHead->Command = SYS_OK;
000287 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 00E1    pHead->data1 = (BYTE)((gDose>>8)&0xff);
000289 940e 0bf1 	CALL SUBOPT_0x1A
                 ; 0003 00E2    pHead->data2 = (BYTE)(gDose&0xff);
                 ; 0003 00E3 
                 ; 0003 00E4    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
00028b 940e 0bd2 	CALL SUBOPT_0x16
00028d 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 00E5 
                 ; 0003 00E6    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
00028f e0a7      	LDI  R26,LOW(7)
000290 940e 0573 	CALL _IPC_SendData1
                 ; 0003 00E7    return TRUE;
000292 c211      	RJMP _0x20A000A
                 ; 0003 00E8 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_VOLTAGE( LPIPC_HEADER pHead )
                 ; 0003 00EB {
                 _IPC1_SND_VOLTAGE:
                 ; .FSTART _IPC1_SND_VOLTAGE
                 ; 0003 00EC    pHead->Command = SYS_OK;
000293 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 00ED    pHead->data1 = (BYTE)((gVoltage>>8)&0xff);  //
000295 940e 0c02 	CALL SUBOPT_0x1B
                 ; 0003 00EE    pHead->data2 = (BYTE)(gVoltage&0xff);
                 ; 0003 00EF 
                 ; 0003 00F0    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000297 940e 0bd2 	CALL SUBOPT_0x16
000299 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 00F1 
                 ; 0003 00F2    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
00029b e0a7      	LDI  R26,LOW(7)
00029c 940e 0573 	CALL _IPC_SendData1
                 ; 0003 00F3 
                 ; 0003 00F4    return TRUE;
00029e c205      	RJMP _0x20A000A
                 ; 0003 00F5 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_DEPTH( LPIPC_HEADER pHead )
                 ; 0003 00F8 {
                 _IPC1_SND_DEPTH:
                 ; .FSTART _IPC1_SND_DEPTH
                 ; 0003 00F9    pHead->Command = SYS_OK;
00029f 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 00FA    pHead->data1 = (BYTE)((gDepth>>8)&0xff);  //
0002a1 940e 0c13 	CALL SUBOPT_0x1C
                 ; 0003 00FB    pHead->data2 = (BYTE)(gDepth&0xff);
                 ; 0003 00FC 
                 ; 0003 00FD    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
0002a3 940e 0bd2 	CALL SUBOPT_0x16
0002a5 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 00FE 
                 ; 0003 00FF    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
0002a7 e0a7      	LDI  R26,LOW(7)
0002a8 940e 0573 	CALL _IPC_SendData1
                 ; 0003 0100 
                 ; 0003 0101    return TRUE;
0002aa c1f9      	RJMP _0x20A000A
                 ; 0003 0102 
                 ; 0003 0103 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_SPEED( LPIPC_HEADER pHead )
                 ; 0003 0106 {
                 _IPC1_SND_SPEED:
                 ; .FSTART _IPC1_SND_SPEED
                 ; 0003 0107    pHead->Command = SYS_OK;
0002ab 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 0108    pHead->data1 = (BYTE)((gSpeed>>8)&0xff);  //
0002ad 940e 0c24 	CALL SUBOPT_0x1D
                 ; 0003 0109    pHead->data2 = (BYTE)(gSpeed&0xff);
                 ; 0003 010A 
                 ; 0003 010B    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
0002af 940e 0bd2 	CALL SUBOPT_0x16
0002b1 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 010C 
                 ; 0003 010D    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
0002b3 e0a7      	LDI  R26,LOW(7)
0002b4 940e 0573 	CALL _IPC_SendData1
                 ; 0003 010E    return TRUE;
0002b6 c1ed      	RJMP _0x20A000A
                 ; 0003 010F 
                 ; 0003 0110 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_ELCOUNT( LPIPC_HEADER pHead )
                 ; 0003 0113 {
                 _IPC1_SND_ELCOUNT:
                 ; .FSTART _IPC1_SND_ELCOUNT
                 ; 0003 0114    pHead->Command = SYS_OK;
0002b7 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 0115    pHead->data1 = (BYTE)((gElCount>>8)&0xff);  //
0002b9 940e 0c35 	CALL SUBOPT_0x1E
                 ; 0003 0116    pHead->data2 = (BYTE)(gElCount&0xff);
                 ; 0003 0117 
                 ; 0003 0118    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
0002bb 940e 0bd2 	CALL SUBOPT_0x16
0002bd 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 0119 
                 ; 0003 011A    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
0002bf e0a7      	LDI  R26,LOW(7)
0002c0 940e 0573 	CALL _IPC_SendData1
                 ; 0003 011B    return TRUE;
0002c2 c1e1      	RJMP _0x20A000A
                 ; 0003 011C }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_FLAG( LPIPC_HEADER pHead )
                 ; 0003 011F {
                 _IPC1_SND_FLAG:
                 ; .FSTART _IPC1_SND_FLAG
                 ; 0003 0120    pHead->Command = SYS_OK;
0002c3 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 0121    pHead->data1 = (BYTE)(gRunFlag&0xff);
0002c5 91e0 050b 	LDS  R30,_gRunFlag
0002c7 940e 0c46 	CALL SUBOPT_0x1F
                 ; 0003 0122    pHead->data2 = (BYTE)(gFlag&0xff);
0002c9 940e 0c4b 	CALL SUBOPT_0x20
                 ; 0003 0123 
                 ; 0003 0124    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
0002cb 940e 0bd2 	CALL SUBOPT_0x16
0002cd 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 0125 
                 ; 0003 0126    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
0002cf e0a7      	LDI  R26,LOW(7)
0002d0 940e 0573 	CALL _IPC_SendData1
                 ; 0003 0127 
                 ; 0003 0128    return TRUE;
0002d2 c1d1      	RJMP _0x20A000A
                 ; 0003 0129 
                 ; 0003 012A }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_EL_MAP( LPIPC_HEADER pHead )
                 ; 0003 012D {
                 _IPC1_SND_EL_MAP:
                 ; .FSTART _IPC1_SND_EL_MAP
                 ; 0003 012E    pHead->Command = SYS_OK;
0002d3 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 012F    pHead->data1  = (gElMatrix[0]&0x0f)<<4 | (gElMatrix[1]&0x0f);
0002d5 91e0 0500 	LDS  R30,_gElMatrix
0002d7 70ef      	ANDI R30,LOW(0xF)
0002d8 95e2      	SWAP R30
0002d9 7fe0      	ANDI R30,0xF0
0002da 2fae      	MOV  R26,R30
                +
0002db 91e0 0501+LDS R30 , _gElMatrix + ( 1 )
                 	__GETB1MN _gElMatrix,1
0002dd 70ef      	ANDI R30,LOW(0xF)
0002de 2bea      	OR   R30,R26
                +
0002df 81a8     +LDD R26 , Y + 0
0002e0 81b9     +LDD R27 , Y + 0 + 1
0002e1 9613     +ADIW R26 , 3
0002e2 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
                 ; 0003 0130    pHead->data2  = (gElMatrix[2]&0x0f)<<4 | (gElMatrix[3]&0x0f);
                +
0002e3 91e0 0502+LDS R30 , _gElMatrix + ( 2 )
                 	__GETB1MN _gElMatrix,2
0002e5 70ef      	ANDI R30,LOW(0xF)
0002e6 95e2      	SWAP R30
0002e7 7fe0      	ANDI R30,0xF0
0002e8 2fae      	MOV  R26,R30
                +
0002e9 91e0 0503+LDS R30 , _gElMatrix + ( 3 )
                 	__GETB1MN _gElMatrix,3
0002eb 70ef      	ANDI R30,LOW(0xF)
0002ec 2bea      	OR   R30,R26
0002ed 940e 0c52 	CALL SUBOPT_0x21
                 ; 0003 0131 
                 ; 0003 0132    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
0002ef 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 0133 
                 ; 0003 0134    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
0002f1 e0a7      	LDI  R26,LOW(7)
0002f2 940e 0573 	CALL _IPC_SendData1
                 ; 0003 0135 
                 ; 0003 0136    return TRUE;
0002f4 c1af      	RJMP _0x20A000A
                 ; 0003 0137 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_MOTOR_POS1( LPIPC_HEADER pHead )
                 ; 0003 013A {
                 _IPC1_SND_MOTOR_POS1:
                 ; .FSTART _IPC1_SND_MOTOR_POS1
                 ; 0003 013B    pHead->Command = SYS_OK;
0002f5 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 013C    pHead->data1  = (BYTE)((gMotorPos1>>8)&0xff);
0002f7 91e0 0514 	LDS  R30,_gMotorPos1
0002f9 91f0 0515 	LDS  R31,_gMotorPos1+1
0002fb 940e 0fb7 	CALL __ASRW8
0002fd 940e 0c46 	CALL SUBOPT_0x1F
                 ; 0003 013D    pHead->data2  = (BYTE)(gMotorPos1&0xff);
0002ff 91e0 0514 	LDS  R30,_gMotorPos1
000301 940e 0c52 	CALL SUBOPT_0x21
                 ; 0003 013E 
                 ; 0003 013F    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000303 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 0140 
                 ; 0003 0141    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
000305 e0a7      	LDI  R26,LOW(7)
000306 940e 0573 	CALL _IPC_SendData1
                 ; 0003 0142 
                 ; 0003 0143    return TRUE;
000308 c19b      	RJMP _0x20A000A
                 ; 0003 0144 
                 ; 0003 0145 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_MOTOR_POS2( LPIPC_HEADER pHead )
                 ; 0003 0148 {
                 _IPC1_SND_MOTOR_POS2:
                 ; .FSTART _IPC1_SND_MOTOR_POS2
                 ; 0003 0149    pHead->Command = SYS_OK;
000309 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 014A    pHead->data1  = (BYTE)((gMotorPos2>>8)&0xff);
00030b 91e0 0516 	LDS  R30,_gMotorPos2
00030d 91f0 0517 	LDS  R31,_gMotorPos2+1
00030f 940e 0fb7 	CALL __ASRW8
000311 940e 0c46 	CALL SUBOPT_0x1F
                 ; 0003 014B    pHead->data2  = (BYTE)(gMotorPos2&0xff);
000313 91e0 0516 	LDS  R30,_gMotorPos2
000315 940e 0c52 	CALL SUBOPT_0x21
                 ; 0003 014C 
                 ; 0003 014D    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000317 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 014E 
                 ; 0003 014F    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
000319 e0a7      	LDI  R26,LOW(7)
00031a 940e 0573 	CALL _IPC_SendData1
                 ; 0003 0150 
                 ; 0003 0151    return TRUE;
00031c c187      	RJMP _0x20A000A
                 ; 0003 0152 
                 ; 0003 0153 }
                 ; .FEND
                 ;
                 ;BYTE IPC1_SND_ERROR( LPIPC_HEADER pHead )
                 ; 0003 0156 {
                 _IPC1_SND_ERROR:
                 ; .FSTART _IPC1_SND_ERROR
                 ; 0003 0157 
                 ; 0003 0158    pHead->Command = SYS_OK;
00031d 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 0159    pHead->data1 = 0;
00031f e0e0      	LDI  R30,LOW(0)
000320 93ec      	ST   X,R30
                 ; 0003 015A    pHead->data2 = gError;;
000321 91e0 0513 	LDS  R30,_gError
000323 940e 0c52 	CALL SUBOPT_0x21
                 ; 0003 015B 
                 ; 0003 015C    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000325 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 015D 
                 ; 0003 015E    IPC_SendData1( (BYTE *)pHead, sizeof( IPC_HEADER ) );
000327 e0a7      	LDI  R26,LOW(7)
000328 940e 0573 	CALL _IPC_SendData1
                 ; 0003 015F 
                 ; 0003 0160    gReadyActionFlag=TRUE;
00032a e0e1      	LDI  R30,LOW(1)
00032b 93e0 051c 	STS  _gReadyActionFlag,R30
                 ; 0003 0161    return TRUE;
00032d c176      	RJMP _0x20A000A
                 ; 0003 0162 
                 ; 0003 0163 }
                 ; .FEND
                 ;
                 ;BYTE MakeCrc( BYTE *Data, int Len )
                 ; 0003 0166 {
                 _MakeCrc:
                 ; .FSTART _MakeCrc
                 ; 0003 0167      int i;
                 ; 0003 0168      BYTE CRC;
                 ; 0003 0169 
                 ; 0003 016A      CRC = 0;
00032e 940e 0b45 	CALL SUBOPT_0x1
                 ;	*Data -> Y+6
                 ;	Len -> Y+4
                 ;	i -> R16,R17
                 ;	CRC -> R19
000330 e030      	LDI  R19,LOW(0)
                 ; 0003 016B 
                 ; 0003 016C      for( i=0; i<Len ; i++ )
                +
000331 e000     +LDI R16 , LOW ( 0 )
000332 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x60020:
000333 81ec      	LDD  R30,Y+4
000334 81fd      	LDD  R31,Y+4+1
000335 170e      	CP   R16,R30
000336 071f      	CPC  R17,R31
000337 f454      	BRGE _0x60021
                 ; 0003 016D           CRC += Data[i];
000338 01f8      	MOVW R30,R16
000339 81ae      	LDD  R26,Y+6
00033a 81bf      	LDD  R27,Y+6+1
00033b 0fae      	ADD  R26,R30
00033c 1fbf      	ADC  R27,R31
00033d 91ec      	LD   R30,X
00033e 0f3e      	ADD  R19,R30
                +
00033f 5f0f     +SUBI R16 , LOW ( - 1 )
000340 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
000341 cff1      	RJMP _0x60020
                 _0x60021:
                 ; 0003 016F return CRC;
000342 2fe3      	MOV  R30,R19
000343 940e 100b 	CALL __LOADLOCR4
000345 9628      	ADIW R28,8
000346 9508      	RET
                 ; 0003 0170 }
                 ; .FEND
                 ;
                 ;void IPC_RunProcess1( void )
                 ; 0003 0173 {
                 _IPC_RunProcess1:
                 ; .FSTART _IPC_RunProcess1
                 ; 0003 0174      BYTE RcvHead[30];
                 ; 0003 0175      BYTE RcvByte;
                 ; 0003 0176      BYTE  Crc,RcvCrc;
                 ; 0003 0177      LPIPC_HEADER pHead;
                 ; 0003 0178 
                 ; 0003 0179   //   while( TRUE )
                 ; 0003 017A      {
000347 940e 0c57 	CALL SUBOPT_0x22
                 ;	RcvHead -> Y+6
                 ;	RcvByte -> R17
                 ;	Crc -> R16
                 ;	RcvCrc -> R19
                 ;	*pHead -> R20,R21
                 ; 0003 017B         RcvByte = IPC_RcvData_Interrupt1( RcvHead, sizeof( IPC_HEADER ) );
000349 940e 0560 	CALL _IPC_RcvData_Interrupt1
00034b 940e 0c60 	CALL SUBOPT_0x23
                 ; 0003 017C         pHead = ( LPIPC_HEADER )RcvHead;
                 ; 0003 017D 
                 ; 0003 017E          Crc =  MakeCrc(  RcvHead , sizeof( IPC_HEADER )- 2 );
                 ; 0003 017F          RcvCrc = pHead->checksum;
                 ; 0003 0180 
                 ; 0003 0181          if(  RcvByte == sizeof( IPC_HEADER ) && RcvCrc == Crc &&
                 ; 0003 0182               pHead->stx == 0x02 && pHead->etx == 0x03 )
00034d f451      	BRNE _0x60023
00034e 1703      	CP   R16,R19
00034f f441      	BRNE _0x60023
000350 01da      	MOVW R26,R20
000351 91ac      	LD   R26,X
000352 30a2      	CPI  R26,LOW(0x2)
000353 f421      	BRNE _0x60023
000354 01fa      	MOVW R30,R20
000355 81a6      	LDD  R26,Z+6
000356 30a3      	CPI  R26,LOW(0x3)
000357 f009      	BREQ _0x60024
                 _0x60023:
000358 c00c      	RJMP _0x60022
                 _0x60024:
                 ; 0003 0183          {
                 ; 0003 0184               if( pHead->RWflag ==  IPC_MODE_READ )
000359 01fa      	MOVW R30,R20
00035a 81a1      	LDD  R26,Z+1
00035b 35a2      	CPI  R26,LOW(0x52)
00035c f421      	BRNE _0x60025
                 ; 0003 0185                    IPC_SndProcess1( RcvHead );
00035d 01de      	MOVW R26,R28
00035e 9616      	ADIW R26,6
00035f d035      	RCALL _IPC_SndProcess1
                 ; 0003 0186               else IPC_RcvProcess1( RcvHead );
000360 c003      	RJMP _0x60026
                 _0x60025:
000361 01de      	MOVW R26,R28
000362 9616      	ADIW R26,6
000363 d00f      	RCALL _IPC_RcvProcess1
                 ; 0003 0187 
                 ; 0003 0188           }
                 _0x60026:
                 ; 0003 0189           else
000364 c005      	RJMP _0x60027
                 _0x60022:
                 ; 0003 018A           {
                 ; 0003 018B              IPC_Send_Response1( RcvHead, SYS_ERROR);
000365 01fe      	MOVW R30,R28
000366 9636      	ADIW R30,6
000367 940e 0c71 	CALL SUBOPT_0x24
                 ; 0003 018C              IPC_ResetCount1();
000369 d1e7      	RCALL _IPC_ResetCount1
                 ; 0003 018D           }
                 _0x60027:
                 ; 0003 018E 
                 ; 0003 018F      }
                 ; 0003 0190 
                 ; 0003 0191 }
00036a c161      	RJMP _0x20A0008
                 ; .FEND
                 ; void IPC_Send_Response1( BYTE *Data, BYTE Res )
                 ; 0003 0193 {
                 _IPC_Send_Response1:
                 ; .FSTART _IPC_Send_Response1
                 ; 0003 0194      LPIPC_HEADER mLpHead;
                 ; 0003 0195 
                 ; 0003 0196      mLpHead = (LPIPC_HEADER)Data;
00036b 940e 0c76 	CALL SUBOPT_0x25
                 ;	*Data -> Y+3
                 ;	Res -> Y+2
                 ;	*mLpHead -> R16,R17
                 ; 0003 0197 
                 ; 0003 0198      mLpHead->Command = Res;
                 ; 0003 0199      mLpHead->data1 = 0;
                 ; 0003 019A      mLpHead->data2 = 0;
                 ; 0003 019B      mLpHead-> checksum = MakeCrc( (BYTE *)mLpHead , sizeof( IPC_HEADER )- 2 );
                 ; 0003 019C 
                 ; 0003 019D      IPC_SendData1( Data, sizeof( IPC_HEADER ) );
00036d 940e 0573 	CALL _IPC_SendData1
                 ; 0003 019E }
00036f 8119      	LDD  R17,Y+1
000370 8108      	LDD  R16,Y+0
000371 940c 0610 	JMP  _0x20A0001
                 ; .FEND
                 ;
                 ;void IPC_RcvProcess1( BYTE *Data )
                 ; 0003 01A1 {
                 _IPC_RcvProcess1:
                 ; .FSTART _IPC_RcvProcess1
                 ; 0003 01A2       LPIPC_HEADER pHead;
                 ; 0003 01A3 
                 ; 0003 01A4       pHead   = (LPIPC_HEADER)Data;
000373 940e 0bb5 	CALL SUBOPT_0x12
                 ;	*Data -> Y+2
                 ;	*pHead -> R16,R17
000375 940e 0c95 	CALL SUBOPT_0x26
                 ; 0003 01A5       if(  pHead->Command < sizeof(IPC1Rcvfun)/2 )
000377 f4b8      	BRSH _0x60028
                 ; 0003 01A6       {
                 ; 0003 01A7              if( IPC1Rcvfun[pHead->Command]( pHead ) == TRUE )        //  Run Command
000378 01f8      	MOVW R30,R16
000379 81e2      	LDD  R30,Z+2
00037a e1af      	LDI  R26,LOW(_IPC1Rcvfun)
00037b e0b5      	LDI  R27,HIGH(_IPC1Rcvfun)
00037c 940e 0c9b 	CALL SUBOPT_0x27
00037e 93ff      	PUSH R31
00037f 93ef      	PUSH R30
000380 01d8      	MOVW R26,R16
000381 91ef      	POP  R30
000382 91ff      	POP  R31
000383 9509      	ICALL
000384 30e1      	CPI  R30,LOW(0x1)
000385 f421      	BRNE _0x60029
                 ; 0003 01A8              {
                 ; 0003 01A9                  IPC_Send_Response1( Data, SYS_OK );
000386 940e 0ca3 	CALL SUBOPT_0x28
000388 e8a0      	LDI  R26,LOW(128)
000389 c003      	RJMP _0x6004E
                 ; 0003 01AA              }
                 ; 0003 01AB              else
                 _0x60029:
                 ; 0003 01AC              {
                 ; 0003 01AD                  IPC_Send_Response1( Data, SYS_ERROR);
00038a 940e 0ca3 	CALL SUBOPT_0x28
00038c e8a1      	LDI  R26,LOW(129)
                 _0x6004E:
00038d dfdd      	RCALL _IPC_Send_Response1
                 ; 0003 01AE               }
                 ; 0003 01AF        }
                 ; 0003 01B0        else
00038e c002      	RJMP _0x6002B
                 _0x60028:
                 ; 0003 01B1        {
                 ; 0003 01B2            IPC_Send_Response1( Data, SYS_ERROR );
00038f 940e 0ca8 	CALL SUBOPT_0x29
                 ; 0003 01B3         }
                 _0x6002B:
                 ; 0003 01B4 
                 ; 0003 01B5 }
000391 8119      	LDD  R17,Y+1
000392 8108      	LDD  R16,Y+0
000393 940c 05e8 	JMP  _0x20A0003
                 ; .FEND
                 ;
                 ;
                 ;void IPC_SndProcess1( BYTE *Data )
                 ; 0003 01B9 {
                 _IPC_SndProcess1:
                 ; .FSTART _IPC_SndProcess1
                 ; 0003 01BA       LPIPC_HEADER pHead;
                 ; 0003 01BB 
                 ; 0003 01BC       pHead = (LPIPC_HEADER)Data;
000395 940e 0bb5 	CALL SUBOPT_0x12
                 ;	*Data -> Y+2
                 ;	*pHead -> R16,R17
000397 940e 0c95 	CALL SUBOPT_0x26
                 ; 0003 01BD       if(   pHead->Command < sizeof(IPC1Sndfun)/2  )
000399 f488      	BRSH _0x6002C
                 ; 0003 01BE       {
                 ; 0003 01BF           if( IPC1Sndfun[pHead->Command]( pHead ) == FALSE )        //  Run Command
00039a 01f8      	MOVW R30,R16
00039b 81e2      	LDD  R30,Z+2
00039c e3a7      	LDI  R26,LOW(_IPC1Sndfun)
00039d e0b5      	LDI  R27,HIGH(_IPC1Sndfun)
00039e 940e 0c9b 	CALL SUBOPT_0x27
0003a0 93ff      	PUSH R31
0003a1 93ef      	PUSH R30
0003a2 01d8      	MOVW R26,R16
0003a3 91ef      	POP  R30
0003a4 91ff      	POP  R31
0003a5 9509      	ICALL
0003a6 30e0      	CPI  R30,0
0003a7 f411      	BRNE _0x6002D
                 ; 0003 01C0               IPC_Send_Response1( Data, SYS_ERROR );
0003a8 940e 0ca8 	CALL SUBOPT_0x29
                 ; 0003 01C1       }
                 _0x6002D:
                 ; 0003 01C2       else
0003aa c002      	RJMP _0x6002E
                 _0x6002C:
                 ; 0003 01C3       {
                 ; 0003 01C4            IPC_Send_Response1( Data, SYS_ERROR );
0003ab 940e 0ca8 	CALL SUBOPT_0x29
                 ; 0003 01C5       }
                 _0x6002E:
                 ; 0003 01C6 }
0003ad 8119      	LDD  R17,Y+1
0003ae 8108      	LDD  R16,Y+0
0003af 940c 05e8 	JMP  _0x20A0003
                 ; .FEND
                 ;
                 ;
                 ;BYTE IPC0_RCV_MODE( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_RUN( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_DOSE( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_VOLTAGE( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_DEPTH( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_SPEED( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_ELCOUNT( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_FLAG( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_EL_MAP( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_MOTOR_POS1( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_MOTOR_POS2( LPIPC_HEADER pHead );
                 ;BYTE IPC0_RCV_ERROR( LPIPC_HEADER pHead );
                 ;//typedef BYTE(*RunFun) (LPIPC_HEADER pHead );
                 ;
                 ;RunFun IPC0Rcvfun[]=
                 ;{
                 ;     IPC0_RCV_MODE,
                 ;     IPC0_RCV_RUN,
                 ;     IPC0_RCV_DOSE,
                 ;     IPC0_RCV_VOLTAGE,
                 ;     IPC0_RCV_DEPTH,
                 ;     IPC0_RCV_SPEED,
                 ;     IPC0_RCV_ELCOUNT,
                 ;     IPC0_RCV_FLAG,
                 ;     IPC0_RCV_EL_MAP,
                 ;     IPC0_RCV_MOTOR_POS1,
                 ;     IPC0_RCV_MOTOR_POS2,
                 ;     IPC0_RCV_ERROR
                 ;};
                 
                 	.DSEG
                 ;
                 ;BYTE IPC0_RCV_MODE( LPIPC_HEADER pHead )
                 ; 0003 01E8 {
                 
                 	.CSEG
                 _IPC0_RCV_MODE:
                 ; .FSTART _IPC0_RCV_MODE
                 ; 0003 01E9    gMode = pHead->data2;
0003b1 940e 0b5c 	CALL SUBOPT_0x5
                 ;	*pHead -> Y+0
0003b3 81e4      	LDD  R30,Z+4
0003b4 93e0 050a 	STS  _gMode,R30
                 ; 0003 01EA 
                 ; 0003 01EB    if( gMode == MODE_READY ) //ready
0003b6 91a0 050a 	LDS  R26,_gMode
0003b8 30a1      	CPI  R26,LOW(0x1)
0003b9 f4d9      	BRNE _0x60030
                 ; 0003 01EC    {
                 ; 0003 01ED       //gElCount = 0;
                 ; 0003 01EE       PORTC = 0x00;
0003ba e0e0      	LDI  R30,LOW(0)
0003bb bbe5      	OUT  0x15,R30
                 ; 0003 01EF       HIGH_PWM;
0003bc 91e0 0065 	LDS  R30,101
0003be 60e8      	ORI  R30,8
0003bf 93e0 0065 	STS  101,R30
                 ; 0003 01F0       DAC7611_WriteVoltage(gVoltage);
0003c1 940e 0b7e 	CALL SUBOPT_0xA
0003c3 940e 0cab 	CALL SUBOPT_0x2A
                 ; 0003 01F1       HIGH_OUTRY;
0003c5 61e0      	ORI  R30,0x10
0003c6 93e0 0065 	STS  101,R30
                 ; 0003 01F2 
                 ; 0003 01F3       gError = ERROR_NO;
0003c8 e0e0      	LDI  R30,LOW(0)
0003c9 93e0 0513 	STS  _gError,R30
                 ; 0003 01F4       gFlag = FLAG_VOLADJ;
0003cb e0e1      	LDI  R30,LOW(1)
0003cc 93e0 0512 	STS  _gFlag,R30
                 ; 0003 01F5 
                 ; 0003 01F6       gVolChkCount = 2;
0003ce e0e2      	LDI  R30,LOW(2)
0003cf e0f0      	LDI  R31,HIGH(2)
0003d0 93e0 051d 	STS  _gVolChkCount,R30
0003d2 93f0 051e 	STS  _gVolChkCount+1,R31
                 ; 0003 01F7 
                 ; 0003 01F8       //LOW_COMPLETE_LED;
                 ; 0003 01F9       //LOW_WARRING_LED;
                 ; 0003 01FA    }
                 ; 0003 01FB    else //if( gMode == MODE_STOP )
0003d4 c004      	RJMP _0x60031
                 _0x60030:
                 ; 0003 01FC    {
                 ; 0003 01FD        PORTC = 0x00;
0003d5 940e 0cb0 	CALL SUBOPT_0x2B
                 ; 0003 01FE        DAC7611_WriteVoltage(0);
                 ; 0003 01FF        LOW_PWM;
0003d7 940e 0cb5 	CALL SUBOPT_0x2C
                 ; 0003 0200        LOW_OUTRY;
                 ; 0003 0201       // gError = ERROR_NO;
                 ; 0003 0202        gFlag = FLAG_STADNBY;
                 ; 0003 0203 
                 ; 0003 0204       // LOW_COMPLETE_LED;
                 ; 0003 0205       //LOW_WARRING_LED;
                 ; 0003 0206    }
                 _0x60031:
                 ; 0003 0207 
                 ; 0003 0208    gRunFlag = FALSE;
0003d9 e0e0      	LDI  R30,LOW(0)
0003da 93e0 050b 	STS  _gRunFlag,R30
                 ; 0003 0209    gElCompletFlag = FALSE;
0003dc 93e0 0518 	STS  _gElCompletFlag,R30
                 ; 0003 020A    return TRUE;
0003de c0c5      	RJMP _0x20A000A
                 ; 0003 020B }
                 ; .FEND
                 ;
                 ;BYTE IPC0_RCV_RUN( LPIPC_HEADER pHead )
                 ; 0003 020E {
                 _IPC0_RCV_RUN:
                 ; .FSTART _IPC0_RCV_RUN
                 ; 0003 020F    if( gFlag == FLAG_SHOOTING ) //ready
0003df 93ba      	ST   -Y,R27
0003e0 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
0003e1 91a0 0512 	LDS  R26,_gFlag
0003e3 30a3      	CPI  R26,LOW(0x3)
0003e4 f479      	BRNE _0x60032
                 ; 0003 0210    {
                 ; 0003 0211       // HIGH_SH;
                 ; 0003 0212        gRunFlag = pHead->data2?TRUE:FALSE;
0003e5 81e8      	LD   R30,Y
0003e6 81f9      	LDD  R31,Y+1
0003e7 81e4      	LDD  R30,Z+4
0003e8 30e0      	CPI  R30,0
0003e9 f011      	BREQ _0x60033
0003ea e0e1      	LDI  R30,LOW(1)
0003eb c001      	RJMP _0x60034
                 _0x60033:
0003ec e0e0      	LDI  R30,LOW(0)
                 _0x60034:
0003ed 93e0 050b 	STS  _gRunFlag,R30
                 ; 0003 0213 
                 ; 0003 0214        gElCompletFlag = FALSE;
0003ef e0e0      	LDI  R30,LOW(0)
0003f0 93e0 0518 	STS  _gElCompletFlag,R30
                 ; 0003 0215        LOW_SH;
0003f2 98c6      	CBI  0x18,6
                 ; 0003 0216    }
                 ; 0003 0217    else
0003f3 c004      	RJMP _0x60038
                 _0x60032:
                 ; 0003 0218    {
                 ; 0003 0219        PORTC = 0x00;
0003f4 940e 0cb0 	CALL SUBOPT_0x2B
                 ; 0003 021A        DAC7611_WriteVoltage(0);
                 ; 0003 021B        LOW_PWM;
0003f6 940e 0cb5 	CALL SUBOPT_0x2C
                 ; 0003 021C        LOW_OUTRY;
                 ; 0003 021D       // gError = ERROR_NO;
                 ; 0003 021E        gFlag = FLAG_STADNBY;
                 ; 0003 021F    }
                 _0x60038:
                 ; 0003 0220    return TRUE;
0003f8 c0ab      	RJMP _0x20A000A
                 ; 0003 0221 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_RCV_DOSE( LPIPC_HEADER pHead )
                 ; 0003 0224 {
                 _IPC0_RCV_DOSE:
                 ; .FSTART _IPC0_RCV_DOSE
                 ; 0003 0225 
                 ; 0003 0226    return TRUE;
0003f9 93ba      	ST   -Y,R27
0003fa 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
0003fb c0a8      	RJMP _0x20A000A
                 ; 0003 0227 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_RCV_VOLTAGE( LPIPC_HEADER pHead )
                 ; 0003 022A {
                 _IPC0_RCV_VOLTAGE:
                 ; .FSTART _IPC0_RCV_VOLTAGE
                 ; 0003 022B    return TRUE;
0003fc 93ba      	ST   -Y,R27
0003fd 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
0003fe c0a5      	RJMP _0x20A000A
                 ; 0003 022C }
                 ; .FEND
                 ;
                 ;BYTE IPC0_RCV_DEPTH( LPIPC_HEADER pHead )
                 ; 0003 022F {
                 _IPC0_RCV_DEPTH:
                 ; .FSTART _IPC0_RCV_DEPTH
                 ; 0003 0230    return TRUE;
0003ff 93ba      	ST   -Y,R27
000400 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
000401 c0a2      	RJMP _0x20A000A
                 ; 0003 0231 }
                 ; .FEND
                 ;BYTE IPC0_RCV_SPEED( LPIPC_HEADER pHead )
                 ; 0003 0233 {
                 _IPC0_RCV_SPEED:
                 ; .FSTART _IPC0_RCV_SPEED
                 ; 0003 0234    return TRUE;
000402 93ba      	ST   -Y,R27
000403 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
000404 c09f      	RJMP _0x20A000A
                 ; 0003 0235 }
                 ; .FEND
                 ;BYTE IPC0_RCV_ELCOUNT( LPIPC_HEADER pHead )
                 ; 0003 0237 {
                 _IPC0_RCV_ELCOUNT:
                 ; .FSTART _IPC0_RCV_ELCOUNT
                 ; 0003 0238    return TRUE;
000405 93ba      	ST   -Y,R27
000406 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
000407 c09c      	RJMP _0x20A000A
                 ; 0003 0239 }
                 ; .FEND
                 ;
                 ; BYTE IPC0_RCV_FLAG( LPIPC_HEADER pHead )
                 ; 0003 023C {
                 _IPC0_RCV_FLAG:
                 ; .FSTART _IPC0_RCV_FLAG
                 ; 0003 023D    BYTE mFlag;
                 ; 0003 023E    mFlag = pHead->data2;
000408 940e 0b56 	CALL SUBOPT_0x4
                 ;	*pHead -> Y+1
                 ;	mFlag -> R17
00040a 8114      	LDD  R17,Z+4
                 ; 0003 023F 
                 ; 0003 0240    if( mFlag > FLAG_EM_STOP)
00040b 3016      	CPI  R17,6
00040c f020      	BRLO _0x60039
                 ; 0003 0241        gFlag = FLAG_EM_STOP;
00040d e0e5      	LDI  R30,LOW(5)
00040e 93e0 0512 	STS  _gFlag,R30
                 ; 0003 0242    else gFlag = mFlag;
000410 c002      	RJMP _0x6003A
                 _0x60039:
000411 9310 0512 	STS  _gFlag,R17
                 ; 0003 0243 
                 ; 0003 0244    return TRUE;
                 _0x6003A:
000413 c030      	RJMP _0x20A000C
                 ; 0003 0245 }
                 ; .FEND
                 ;BYTE IPC0_RCV_EL_MAP( LPIPC_HEADER pHead )
                 ; 0003 0247 {
                 _IPC0_RCV_EL_MAP:
                 ; .FSTART _IPC0_RCV_EL_MAP
                 ; 0003 0248    return TRUE;
000414 93ba      	ST   -Y,R27
000415 93aa      	ST   -Y,R26
                 ;	*pHead -> Y+0
000416 c08d      	RJMP _0x20A000A
                 ; 0003 0249 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_RCV_MOTOR_POS1( LPIPC_HEADER pHead )
                 ; 0003 024C {
                 _IPC0_RCV_MOTOR_POS1:
                 ; .FSTART _IPC0_RCV_MOTOR_POS1
                 ; 0003 024D    WORD temp;
                 ; 0003 024E    temp = ((WORD)pHead->data1)<<8|pHead->data2;
000417 940e 0bb5 	CALL SUBOPT_0x12
                 ;	*pHead -> Y+2
                 ;	temp -> R16,R17
000419 940e 0cc1 	CALL SUBOPT_0x2D
                 ; 0003 024F    gMotorPos1 = temp;
                +
00041b 9300 0514+STS _gMotorPos1 + ( 0 ) , R16
00041d 9310 0515+STS _gMotorPos1 + ( 0 ) + 1 , R17
                 	__PUTWMRN _gMotorPos1,0,16,17
                 ; 0003 0250 
                 ; 0003 0251    return TRUE;
00041f e0e1      	LDI  R30,LOW(1)
000420 8119      	LDD  R17,Y+1
000421 8108      	LDD  R16,Y+0
000422 940c 05e8 	JMP  _0x20A0003
                 ; 0003 0252 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_RCV_MOTOR_POS2( LPIPC_HEADER pHead )
                 ; 0003 0255 {
                 _IPC0_RCV_MOTOR_POS2:
                 ; .FSTART _IPC0_RCV_MOTOR_POS2
                 ; 0003 0256    WORD temp;
                 ; 0003 0257    temp = ((WORD)pHead->data1)<<8|pHead->data2;
000424 940e 0bb5 	CALL SUBOPT_0x12
                 ;	*pHead -> Y+2
                 ;	temp -> R16,R17
000426 940e 0cc1 	CALL SUBOPT_0x2D
                 ; 0003 0258    gMotorPos2 = temp;
                +
000428 9300 0516+STS _gMotorPos2 + ( 0 ) , R16
00042a 9310 0517+STS _gMotorPos2 + ( 0 ) + 1 , R17
                 	__PUTWMRN _gMotorPos2,0,16,17
                 ; 0003 0259 
                 ; 0003 025A    return TRUE;
00042c e0e1      	LDI  R30,LOW(1)
00042d 8119      	LDD  R17,Y+1
00042e 8108      	LDD  R16,Y+0
00042f 940c 05e8 	JMP  _0x20A0003
                 ; 0003 025B }
                 ; .FEND
                 ;
                 ;BYTE IPC0_RCV_ERROR( LPIPC_HEADER pHead )
                 ; 0003 025E {
                 _IPC0_RCV_ERROR:
                 ; .FSTART _IPC0_RCV_ERROR
                 ; 0003 025F    BYTE mErrPos = pHead->data1;
                 ; 0003 0260 
                 ; 0003 0261    if( mErrPos> ERROR_EM_STOP )
000431 940e 0b56 	CALL SUBOPT_0x4
                 ;	*pHead -> Y+1
                 ;	mErrPos -> R17
000433 81e3      	LDD  R30,Z+3
000434 2f1e      	MOV  R17,R30
000435 3018      	CPI  R17,8
000436 f008      	BRLO _0x6003B
                 ; 0003 0262        mErrPos = ERROR_EM_STOP;
000437 e017      	LDI  R17,LOW(7)
                 ; 0003 0263 
                 ; 0003 0264    if( mErrPos == ERROR_EM_STOP )  //2021-01-12
                 _0x6003B:
000438 3017      	CPI  R17,7
000439 f419      	BRNE _0x6003C
                 ; 0003 0265       gFlag = FLAG_EM_STOP;
00043a e0e5      	LDI  R30,LOW(5)
00043b 93e0 0512 	STS  _gFlag,R30
                 ; 0003 0266 
                 ; 0003 0267    gError |= (1<<mErrPos);
                 _0x6003C:
00043d 940e 0bba 	CALL SUBOPT_0x13
00043f 91a0 0513 	LDS  R26,_gError
000441 2bea      	OR   R30,R26
000442 940e 0ccf 	CALL SUBOPT_0x2E
                 ; 0003 0268 
                 ; 0003 0269    gCurMode = CUR_ERROR;
                 ; 0003 026A 
                 ; 0003 026B    return TRUE;
                 _0x20A000C:
000444 e0e1      	LDI  R30,LOW(1)
000445 8118      	LDD  R17,Y+0
                 _0x20A000D:
000446 9623      	ADIW R28,3
000447 9508      	RET
                 ; 0003 026C }
                 ; .FEND
                 ;BYTE IPC0_SND_MODE( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_RUN( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_DOSE( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_VOLTAGE( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_DEPTH( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_SPEED( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_ELCOUNT( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_FLAG( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_EL_MAP( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_MOTOR_POS1( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_MOTOR_POS2( LPIPC_HEADER pHead );
                 ;BYTE IPC0_SND_ERROR( LPIPC_HEADER pHead );
                 ;//typedef BYTE(*SenFun) (LPIPC_HEADER pHead);
                 ;
                 ;SenFun IPC0Sndfun[]=
                 ;{
                 ;     IPC0_SND_MODE,
                 ;     IPC0_SND_RUN,
                 ;     IPC0_SND_DOSE,
                 ;     IPC0_SND_VOLTAGE,
                 ;     IPC0_SND_DEPTH,
                 ;     IPC0_SND_SPEED,
                 ;     IPC0_SND_ELCOUNT,
                 ;     IPC0_SND_FLAG,
                 ;     IPC0_SND_EL_MAP,
                 ;     IPC0_SND_MOTOR_POS1,
                 ;     IPC0_SND_MOTOR_POS2,
                 ;     IPC0_SND_ERROR
                 ;};
                 
                 	.DSEG
                 ;
                 ;BYTE IPC0_SND_MODE( LPIPC_HEADER pHead )
                 ; 0003 028C {
                 
                 	.CSEG
                 _IPC0_SND_MODE:
                 ; .FSTART _IPC0_SND_MODE
                 ; 0003 028D    pHead->Command = SYS_OK;
000448 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 028E    pHead->data1 = 1;//(BYTE)((gMode>>8)&0xff);  //
00044a e0e1      	LDI  R30,LOW(1)
00044b 940e 0bca 	CALL SUBOPT_0x15
                 ; 0003 028F    pHead->data2 =  (BYTE)(gMode&0xff);
                 ; 0003 0290 
                 ; 0003 0291    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
00044d c04d      	RJMP _0x20A0009
                 ; 0003 0292 
                 ; 0003 0293    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 0294    return TRUE;
                 ; 0003 0295 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_SND_RUN( LPIPC_HEADER pHead )
                 ; 0003 0298 {
                 _IPC0_SND_RUN:
                 ; .FSTART _IPC0_SND_RUN
                 ; 0003 0299    pHead->Command = SYS_OK;
00044e 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 029A    pHead->data1 = 1;//(BYTE)((gRunFlag>>8)&0xff);  //
000450 940e 0be0 	CALL SUBOPT_0x18
                 ; 0003 029B    pHead->data2 = (BYTE)(gRunFlag&0xff);
                 ; 0003 029C 
                 ; 0003 029D    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000452 c048      	RJMP _0x20A0009
                 ; 0003 029E 
                 ; 0003 029F    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 02A0    return TRUE;
                 ; 0003 02A1 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_SND_DOSE( LPIPC_HEADER pHead )
                 ; 0003 02A4 {
                 _IPC0_SND_DOSE:
                 ; .FSTART _IPC0_SND_DOSE
                 ; 0003 02A5    pHead->Command = SYS_OK;
000453 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 02A6    pHead->data1 = (BYTE)((gDose>>8)&0xff);
000455 940e 0bf1 	CALL SUBOPT_0x1A
                 ; 0003 02A7    pHead->data2 = (BYTE)(gDose&0xff);
                 ; 0003 02A8 
                 ; 0003 02A9    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000457 c043      	RJMP _0x20A0009
                 ; 0003 02AA 
                 ; 0003 02AB    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 02AC    return TRUE;
                 ; 0003 02AD }
                 ; .FEND
                 ;BYTE IPC0_SND_VOLTAGE( LPIPC_HEADER pHead )
                 ; 0003 02AF {
                 _IPC0_SND_VOLTAGE:
                 ; .FSTART _IPC0_SND_VOLTAGE
                 ; 0003 02B0    pHead->Command = SYS_OK;
000458 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 02B1    pHead->data1 = (BYTE)((gVoltage>>8)&0xff);  //
00045a 940e 0c02 	CALL SUBOPT_0x1B
                 ; 0003 02B2    pHead->data2 = (BYTE)(gVoltage&0xff);
                 ; 0003 02B3 
                 ; 0003 02B4    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
00045c c03e      	RJMP _0x20A0009
                 ; 0003 02B5 
                 ; 0003 02B6    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 02B7 
                 ; 0003 02B8    return TRUE;
                 ; 0003 02B9 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_SND_DEPTH( LPIPC_HEADER pHead )
                 ; 0003 02BC {
                 _IPC0_SND_DEPTH:
                 ; .FSTART _IPC0_SND_DEPTH
                 ; 0003 02BD    pHead->Command = SYS_OK;
00045d 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 02BE    pHead->data1 = (BYTE)((gDepth>>8)&0xff);  //
00045f 940e 0c13 	CALL SUBOPT_0x1C
                 ; 0003 02BF    pHead->data2 = (BYTE)(gDepth&0xff);
                 ; 0003 02C0 
                 ; 0003 02C1    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000461 c039      	RJMP _0x20A0009
                 ; 0003 02C2 
                 ; 0003 02C3    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 02C4 
                 ; 0003 02C5    return TRUE;
                 ; 0003 02C6 
                 ; 0003 02C7 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_SND_ELCOUNT( LPIPC_HEADER pHead )
                 ; 0003 02CA {
                 _IPC0_SND_ELCOUNT:
                 ; .FSTART _IPC0_SND_ELCOUNT
                 ; 0003 02CB    pHead->Command = SYS_OK;
000462 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 02CC    pHead->data1 = (BYTE)((gElCount>>8)&0xff);  //
000464 940e 0c35 	CALL SUBOPT_0x1E
                 ; 0003 02CD    pHead->data2 = (BYTE)(gElCount&0xff);
                 ; 0003 02CE 
                 ; 0003 02CF    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000466 c034      	RJMP _0x20A0009
                 ; 0003 02D0 
                 ; 0003 02D1    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 02D2    return TRUE;
                 ; 0003 02D3 
                 ; 0003 02D4 }
                 ; .FEND
                 ;BYTE IPC0_SND_SPEED( LPIPC_HEADER pHead )
                 ; 0003 02D6 {
                 _IPC0_SND_SPEED:
                 ; .FSTART _IPC0_SND_SPEED
                 ; 0003 02D7    pHead->Command = SYS_OK;
000467 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 02D8    pHead->data1 = (BYTE)((gSpeed>>8)&0xff);  //
000469 940e 0c24 	CALL SUBOPT_0x1D
                 ; 0003 02D9    pHead->data2 = (BYTE)(gSpeed&0xff);
                 ; 0003 02DA 
                 ; 0003 02DB    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
00046b c02f      	RJMP _0x20A0009
                 ; 0003 02DC 
                 ; 0003 02DD    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 02DE    return TRUE;
                 ; 0003 02DF 
                 ; 0003 02E0 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_SND_FLAG( LPIPC_HEADER pHead )
                 ; 0003 02E3 {
                 _IPC0_SND_FLAG:
                 ; .FSTART _IPC0_SND_FLAG
                 ; 0003 02E4 
                 ; 0003 02E5    pHead->Command = SYS_OK;
00046c 940e 0be9 	CALL SUBOPT_0x19
                 ;	*pHead -> Y+0
                 ; 0003 02E6    pHead->data1 = (BYTE)((gFlag>>8)&0xff);  //
00046e 91a0 0512 	LDS  R26,_gFlag
000470 e0e8      	LDI  R30,LOW(8)
000471 940e 0fa1 	CALL __LSRB12
000473 940e 0c46 	CALL SUBOPT_0x1F
                 ; 0003 02E7    pHead->data2 = (BYTE)(gFlag&0xff);
000475 940e 0c4b 	CALL SUBOPT_0x20
                 ; 0003 02E8 
                 ; 0003 02E9    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000477 c023      	RJMP _0x20A0009
                 ; 0003 02EA 
                 ; 0003 02EB    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 02EC 
                 ; 0003 02ED    return TRUE;
                 ; 0003 02EE 
                 ; 0003 02EF }
                 ; .FEND
                 ;BYTE IPC0_SND_EL_MAP( LPIPC_HEADER pHead )
                 ; 0003 02F1 {
                 _IPC0_SND_EL_MAP:
                 ; .FSTART _IPC0_SND_EL_MAP
                 ; 0003 02F2 
                 ; 0003 02F3    pHead->Command = SYS_OK;
000478 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 02F4    pHead->data1 = 0;  //
00047a 940e 0cd5 	CALL SUBOPT_0x2F
                 ; 0003 02F5    pHead->data2 = 0;
                 ; 0003 02F6 
                 ; 0003 02F7    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
00047c c01e      	RJMP _0x20A0009
                 ; 0003 02F8 
                 ; 0003 02F9    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 02FA 
                 ; 0003 02FB    return TRUE;
                 ; 0003 02FC 
                 ; 0003 02FD }
                 ; .FEND
                 ;BYTE IPC0_SND_MOTOR_POS1( LPIPC_HEADER pHead )
                 ; 0003 02FF {
                 _IPC0_SND_MOTOR_POS1:
                 ; .FSTART _IPC0_SND_MOTOR_POS1
                 ; 0003 0300 
                 ; 0003 0301    pHead->Command = SYS_OK;
00047d 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 0302    pHead->data1 = 0;  //
00047f 940e 0cd5 	CALL SUBOPT_0x2F
                 ; 0003 0303    pHead->data2 = 0;
                 ; 0003 0304 
                 ; 0003 0305    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000481 c019      	RJMP _0x20A0009
                 ; 0003 0306 
                 ; 0003 0307    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 0308 
                 ; 0003 0309    return TRUE;
                 ; 0003 030A }
                 ; .FEND
                 ;
                 ;BYTE IPC0_SND_MOTOR_POS2( LPIPC_HEADER pHead )
                 ; 0003 030D {
                 _IPC0_SND_MOTOR_POS2:
                 ; .FSTART _IPC0_SND_MOTOR_POS2
                 ; 0003 030E    pHead->Command = SYS_OK;
000482 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 030F    pHead->data1 = 0;  //
000484 940e 0cd5 	CALL SUBOPT_0x2F
                 ; 0003 0310    pHead->data2 = 0;
                 ; 0003 0311 
                 ; 0003 0312    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
000486 c014      	RJMP _0x20A0009
                 ; 0003 0313 
                 ; 0003 0314    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
                 ; 0003 0315 
                 ; 0003 0316    return TRUE;
                 ; 0003 0317 }
                 ; .FEND
                 ;
                 ;BYTE IPC0_SND_ERROR( LPIPC_HEADER pHead )
                 ; 0003 031A {
                 _IPC0_SND_ERROR:
                 ; .FSTART _IPC0_SND_ERROR
                 ; 0003 031B    pHead->Command = SYS_OK;
000487 940e 0bbf 	CALL SUBOPT_0x14
                 ;	*pHead -> Y+0
                 ; 0003 031C    pHead->data1 = 0;  //
000489 e0e0      	LDI  R30,LOW(0)
00048a 93ec      	ST   X,R30
                 ; 0003 031D    if( gReadyActionFlag ==FALSE )
00048b 91e0 051c 	LDS  R30,_gReadyActionFlag
00048d 30e0      	CPI  R30,0
00048e f431      	BRNE _0x6003E
                 ; 0003 031E         pHead->data2 = ERROR_NOTLCD;
00048f 81a8      	LD   R26,Y
000490 81b9      	LDD  R27,Y+1
000491 9614      	ADIW R26,4
000492 e0e6      	LDI  R30,LOW(6)
000493 93ec      	ST   X,R30
                 ; 0003 031F    else
000494 c006      	RJMP _0x6003F
                 _0x6003E:
                 ; 0003 0320        pHead->data2 = gError;
000495 91e0 0513 	LDS  R30,_gError
                +
000497 81a8     +LDD R26 , Y + 0
000498 81b9     +LDD R27 , Y + 0 + 1
000499 9614     +ADIW R26 , 4
00049a 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
                 ; 0003 0321 
                 ; 0003 0322    pHead->checksum = MakeCrc( (BYTE *)pHead , sizeof( IPC_HEADER )- 2 );
                 _0x6003F:
                 _0x20A0009:
00049b 81e8      	LD   R30,Y
00049c 81f9      	LDD  R31,Y+1
00049d 93fa      	ST   -Y,R31
00049e 93ea      	ST   -Y,R30
00049f 940e 0bd7 	CALL SUBOPT_0x17
                 ; 0003 0323 
                 ; 0003 0324    IPC_SendData0( (BYTE *)pHead, sizeof( IPC_HEADER ) );
0004a1 e0a7      	LDI  R26,LOW(7)
0004a2 940e 05dc 	CALL _IPC_SendData0
                 ; 0003 0325 
                 ; 0003 0326    return TRUE;
                 _0x20A000A:
0004a4 e0e1      	LDI  R30,LOW(1)
                 _0x20A000B:
0004a5 9622      	ADIW R28,2
0004a6 9508      	RET
                 ; 0003 0327 
                 ; 0003 0328 }
                 ; .FEND
                 ;void IPC_RunProcess0( void )
                 ; 0003 032A {
                 _IPC_RunProcess0:
                 ; .FSTART _IPC_RunProcess0
                 ; 0003 032B      BYTE RcvHead[30];
                 ; 0003 032C      BYTE RcvByte;
                 ; 0003 032D      BYTE  Crc,RcvCrc;
                 ; 0003 032E      LPIPC_HEADER pHead;
                 ; 0003 032F 
                 ; 0003 0330   //   while( TRUE )
                 ; 0003 0331      {
0004a7 940e 0c57 	CALL SUBOPT_0x22
                 ;	RcvHead -> Y+6
                 ;	RcvByte -> R17
                 ;	Crc -> R16
                 ;	RcvCrc -> R19
                 ;	*pHead -> R20,R21
                 ; 0003 0332         RcvByte = IPC_RcvData_Interrupt0( RcvHead, sizeof( IPC_HEADER ) );
0004a9 940e 05c5 	CALL _IPC_RcvData_Interrupt0
0004ab 940e 0c60 	CALL SUBOPT_0x23
                 ; 0003 0333         pHead = ( LPIPC_HEADER )RcvHead;
                 ; 0003 0334 
                 ; 0003 0335          Crc =  MakeCrc(  RcvHead , sizeof( IPC_HEADER )- 2 );
                 ; 0003 0336          RcvCrc = pHead->checksum;
                 ; 0003 0337 
                 ; 0003 0338          if(  RcvByte == sizeof( IPC_HEADER ) && RcvCrc == Crc &&
                 ; 0003 0339               pHead->stx == 0x02 && pHead->etx == 0x03 )
0004ad f451      	BRNE _0x60041
0004ae 1703      	CP   R16,R19
0004af f441      	BRNE _0x60041
0004b0 01da      	MOVW R26,R20
0004b1 91ac      	LD   R26,X
0004b2 30a2      	CPI  R26,LOW(0x2)
0004b3 f421      	BRNE _0x60041
0004b4 01fa      	MOVW R30,R20
0004b5 81a6      	LDD  R26,Z+6
0004b6 30a3      	CPI  R26,LOW(0x3)
0004b7 f009      	BREQ _0x60042
                 _0x60041:
0004b8 c00c      	RJMP _0x60040
                 _0x60042:
                 ; 0003 033A          {
                 ; 0003 033B               if( pHead->RWflag ==  IPC_MODE_READ )
0004b9 01fa      	MOVW R30,R20
0004ba 81a1      	LDD  R26,Z+1
0004bb 35a2      	CPI  R26,LOW(0x52)
0004bc f421      	BRNE _0x60043
                 ; 0003 033C                    IPC_SndProcess0( RcvHead );
0004bd 01de      	MOVW R26,R28
0004be 9616      	ADIW R26,6
0004bf d03c      	RCALL _IPC_SndProcess0
                 ; 0003 033D               else IPC_RcvProcess0( RcvHead );
0004c0 c003      	RJMP _0x60044
                 _0x60043:
0004c1 01de      	MOVW R26,R28
0004c2 9616      	ADIW R26,6
0004c3 d014      	RCALL _IPC_RcvProcess0
                 ; 0003 033E 
                 ; 0003 033F           }
                 _0x60044:
                 ; 0003 0340           else
0004c4 c007      	RJMP _0x60045
                 _0x60040:
                 ; 0003 0341           {
                 ; 0003 0342              IPC_Send_Response0( RcvHead, SYS_ERROR);
0004c5 01fe      	MOVW R30,R28
0004c6 9636      	ADIW R30,6
0004c7 93fa      	ST   -Y,R31
0004c8 93ea      	ST   -Y,R30
0004c9 e8a1      	LDI  R26,LOW(129)
0004ca d005      	RCALL _IPC_Send_Response0
                 ; 0003 0343              IPC_ResetCount0();
0004cb d0ec      	RCALL _IPC_ResetCount0
                 ; 0003 0344           }
                 _0x60045:
                 ; 0003 0345 
                 ; 0003 0346      }
                 ; 0003 0347 
                 ; 0003 0348 }
                 _0x20A0008:
0004cc 940e 1009 	CALL __LOADLOCR6
0004ce 96a4      	ADIW R28,36
0004cf 9508      	RET
                 ; .FEND
                 ; void IPC_Send_Response0( BYTE *Data, BYTE Res )
                 ; 0003 034A {
                 _IPC_Send_Response0:
                 ; .FSTART _IPC_Send_Response0
                 ; 0003 034B      LPIPC_HEADER mLpHead;
                 ; 0003 034C 
                 ; 0003 034D      mLpHead = (LPIPC_HEADER)Data;
0004d0 940e 0c76 	CALL SUBOPT_0x25
                 ;	*Data -> Y+3
                 ;	Res -> Y+2
                 ;	*mLpHead -> R16,R17
                 ; 0003 034E 
                 ; 0003 034F      mLpHead->Command = Res;
                 ; 0003 0350      mLpHead->data1 = 0;
                 ; 0003 0351      mLpHead->data2 = 0;
                 ; 0003 0352      mLpHead-> checksum = MakeCrc( (BYTE *)mLpHead , sizeof( IPC_HEADER )- 2 );
                 ; 0003 0353 
                 ; 0003 0354      IPC_SendData0( Data, sizeof( IPC_HEADER ) );
0004d2 940e 05dc 	CALL _IPC_SendData0
                 ; 0003 0355 }
0004d4 8119      	LDD  R17,Y+1
0004d5 8108      	LDD  R16,Y+0
0004d6 940c 0610 	JMP  _0x20A0001
                 ; .FEND
                 ;
                 ;void IPC_RcvProcess0( BYTE *Data )
                 ; 0003 0358 {
                 _IPC_RcvProcess0:
                 ; .FSTART _IPC_RcvProcess0
                 ; 0003 0359       LPIPC_HEADER pHead;
                 ; 0003 035A 
                 ; 0003 035B       pHead   = (LPIPC_HEADER)Data;
0004d8 940e 0bb5 	CALL SUBOPT_0x12
                 ;	*Data -> Y+2
                 ;	*pHead -> R16,R17
0004da 940e 0c95 	CALL SUBOPT_0x26
                 ; 0003 035C       if(  pHead->Command < sizeof(IPC0Rcvfun)/2 )
0004dc f4b8      	BRSH _0x60046
                 ; 0003 035D       {
                 ; 0003 035E              if( IPC0Rcvfun[pHead->Command]( pHead ) == TRUE )        //  Run Command
0004dd 01f8      	MOVW R30,R16
0004de 81e2      	LDD  R30,Z+2
0004df e4af      	LDI  R26,LOW(_IPC0Rcvfun)
0004e0 e0b5      	LDI  R27,HIGH(_IPC0Rcvfun)
0004e1 940e 0c9b 	CALL SUBOPT_0x27
0004e3 93ff      	PUSH R31
0004e4 93ef      	PUSH R30
0004e5 01d8      	MOVW R26,R16
0004e6 91ef      	POP  R30
0004e7 91ff      	POP  R31
0004e8 9509      	ICALL
0004e9 30e1      	CPI  R30,LOW(0x1)
0004ea f421      	BRNE _0x60047
                 ; 0003 035F              {
                 ; 0003 0360                  IPC_Send_Response0( Data, SYS_OK );
0004eb 940e 0ca3 	CALL SUBOPT_0x28
0004ed e8a0      	LDI  R26,LOW(128)
0004ee c003      	RJMP _0x6004F
                 ; 0003 0361              }
                 ; 0003 0362              else
                 _0x60047:
                 ; 0003 0363              {
                 ; 0003 0364                  IPC_Send_Response0( Data, SYS_ERROR);
0004ef 940e 0ca3 	CALL SUBOPT_0x28
0004f1 e8a1      	LDI  R26,LOW(129)
                 _0x6004F:
0004f2 dfdd      	RCALL _IPC_Send_Response0
                 ; 0003 0365               }
                 ; 0003 0366        }
                 ; 0003 0367        else
0004f3 c004      	RJMP _0x60049
                 _0x60046:
                 ; 0003 0368        {
                 ; 0003 0369            IPC_Send_Response0( Data, SYS_ERROR );
0004f4 940e 0ca3 	CALL SUBOPT_0x28
0004f6 e8a1      	LDI  R26,LOW(129)
0004f7 dfd8      	RCALL _IPC_Send_Response0
                 ; 0003 036A         }
                 _0x60049:
                 ; 0003 036B 
                 ; 0003 036C }
0004f8 8119      	LDD  R17,Y+1
0004f9 8108      	LDD  R16,Y+0
0004fa 940c 05e8 	JMP  _0x20A0003
                 ; .FEND
                 ;
                 ;
                 ;void IPC_SndProcess0( BYTE *Data )
                 ; 0003 0370 {
                 _IPC_SndProcess0:
                 ; .FSTART _IPC_SndProcess0
                 ; 0003 0371       LPIPC_HEADER pHead;
                 ; 0003 0372 
                 ; 0003 0373       pHead = (LPIPC_HEADER)Data;
0004fc 940e 0bb5 	CALL SUBOPT_0x12
                 ;	*Data -> Y+2
                 ;	*pHead -> R16,R17
0004fe 940e 0c95 	CALL SUBOPT_0x26
                 ; 0003 0374       if( pHead->Command < sizeof(IPC0Sndfun)/2  )
000500 f498      	BRSH _0x6004A
                 ; 0003 0375       {
                 ; 0003 0376           if( IPC0Sndfun[pHead->Command]( pHead ) == FALSE )        //  Run Command
000501 01f8      	MOVW R30,R16
000502 81e2      	LDD  R30,Z+2
000503 e6a7      	LDI  R26,LOW(_IPC0Sndfun)
000504 e0b5      	LDI  R27,HIGH(_IPC0Sndfun)
000505 940e 0c9b 	CALL SUBOPT_0x27
000507 93ff      	PUSH R31
000508 93ef      	PUSH R30
000509 01d8      	MOVW R26,R16
00050a 91ef      	POP  R30
00050b 91ff      	POP  R31
00050c 9509      	ICALL
00050d 30e0      	CPI  R30,0
00050e f421      	BRNE _0x6004B
                 ; 0003 0377               IPC_Send_Response0( Data, SYS_ERROR );
00050f 940e 0ca3 	CALL SUBOPT_0x28
000511 e8a1      	LDI  R26,LOW(129)
000512 dfbd      	RCALL _IPC_Send_Response0
                 ; 0003 0378       }
                 _0x6004B:
                 ; 0003 0379       else
000513 c004      	RJMP _0x6004C
                 _0x6004A:
                 ; 0003 037A       {
                 ; 0003 037B            IPC_Send_Response0( Data, SYS_ERROR );
000514 940e 0ca3 	CALL SUBOPT_0x28
000516 e8a1      	LDI  R26,LOW(129)
000517 dfb8      	RCALL _IPC_Send_Response0
                 ; 0003 037C       }
                 _0x6004C:
                 ; 0003 037D }
000518 8119      	LDD  R17,Y+1
000519 8108      	LDD  R16,Y+0
00051a 940c 05e8 	JMP  _0x20A0003
                 ; .FEND
                 ;#include <stdarg.h>
                 ;#include <stdio.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include "uart.h"
                 ;
                 ;#define RXB8 1
                 ;#define TXB8 0
                 ;#define UPE  2
                 ;#define OVR  3
                 ;#define FE   4
                 ;#define UDRE 5
                 ;#define RXC  7
                 ;
                 ;#define FRAMING_ERROR (1<<FE)
                 ;#define PARITY_ERROR (1<<UPE)
                 ;#define DATA_OVERRUN (1<<OVR)
                 ;#define DATA_REGISTER_EMPTY (1<<UDRE)
                 ;#define RX_COMPLETE (1<<RXC)
                 ;
                 ;extern WORD  gTime1ms;
                 ;
                 ;#define RX_BUFFER_SIZE0 250
                 ;char rx_buffer0[RX_BUFFER_SIZE0];
                 ;unsigned char rx_wr_index0=0,rx_rd_index0=0,rx_counter0=0;
                 ;BOOL rx_buffer_overflow0=FALSE;
                 ;char mRcvErrFlag0 = 0;
                 ;
                 ;#define RX_BUFFER_SIZE1 250
                 ;char rx_buffer1[RX_BUFFER_SIZE1];
                 ;unsigned char rx_wr_index1=0,rx_rd_index1=0,rx_counter1=0;
                 ;BOOL rx_buffer_overflow1=FALSE;
                 ;char mRcvErrFlag1 = 0;
                 ;
                 ;// USART1 Receiver interrupt service routine
                 ;interrupt [USART1_RXC] void usart1_rx_isr(void)
                 ; 0004 0023 {
                 
                 	.CSEG
                 _usart1_rx_isr:
                 ; .FSTART _usart1_rx_isr
00051c 940e 0cdc 	CALL SUBOPT_0x30
                 ; 0004 0024    char status,data;
                 ; 0004 0025    status = UCSR1A;
                 ;	status -> R17
                 ;	data -> R16
00051e 9110 009b 	LDS  R17,155
                 ; 0004 0026    data   = UDR1;
000520 9100 009c 	LDS  R16,156
                 ; 0004 0027 
                 ; 0004 0028    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0 )
000522 2fe1      	MOV  R30,R17
000523 71ec      	ANDI R30,LOW(0x1C)
000524 f489      	BRNE _0x80003
                 ; 0004 0029    {
                 ; 0004 002A       rx_buffer1[rx_wr_index1++]=data;
000525 2de8      	MOV  R30,R8
000526 9483      	INC  R8
000527 e0f0      	LDI  R31,0
000528 58e7      	SUBI R30,LOW(-_rx_buffer1)
000529 4ff9      	SBCI R31,HIGH(-_rx_buffer1)
00052a 8300      	ST   Z,R16
                 ; 0004 002B       if (rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
00052b efea      	LDI  R30,LOW(250)
00052c 15e8      	CP   R30,R8
00052d f409      	BRNE _0x80004
00052e 2488      	CLR  R8
                 ; 0004 002C       if (++rx_counter1 == RX_BUFFER_SIZE1)
                 _0x80004:
00052f 94a3      	INC  R10
000530 efea      	LDI  R30,LOW(250)
000531 15ea      	CP   R30,R10
000532 f419      	BRNE _0x80005
                 ; 0004 002D       {
                 ; 0004 002E          rx_counter1 = 0;
000533 24aa      	CLR  R10
                 ; 0004 002F          rx_buffer_overflow1 = TRUE;
000534 e0e1      	LDI  R30,LOW(1)
000535 2ede      	MOV  R13,R30
                 ; 0004 0030       }
                 ; 0004 0031       //gOldUartTime1ms = gTime1ms;
                 ; 0004 0032    }
                 _0x80005:
                 ; 0004 0033 }
                 _0x80003:
000536 c05f      	RJMP _0x80059
                 ; .FEND
                 ;
                 ;// Get a character from the USART1 Receiver buffer
                 ;//#pragma used+
                 ;char getchar1( void )
                 ; 0004 0038 {
                 _getchar1:
                 ; .FSTART _getchar1
                 ; 0004 0039    char data;
                 ; 0004 003A    //while (rx_counter1==0);
                 ; 0004 003B     if( rx_counter1 >0 )
000537 931a      	ST   -Y,R17
                 ;	data -> R17
000538 e0e0      	LDI  R30,LOW(0)
000539 15ea      	CP   R30,R10
00053a f480      	BRSH _0x80006
                 ; 0004 003C     {
                 ; 0004 003D       data = rx_buffer1[rx_rd_index1++];
00053b 2deb      	MOV  R30,R11
00053c 94b3      	INC  R11
00053d e0f0      	LDI  R31,0
00053e 58e7      	SUBI R30,LOW(-_rx_buffer1)
00053f 4ff9      	SBCI R31,HIGH(-_rx_buffer1)
000540 8110      	LD   R17,Z
                 ; 0004 003E       if (rx_rd_index1 == RX_BUFFER_SIZE1) rx_rd_index1=0;
000541 efea      	LDI  R30,LOW(250)
000542 15eb      	CP   R30,R11
000543 f409      	BRNE _0x80007
000544 24bb      	CLR  R11
                 ; 0004 003F 
                 ; 0004 0040        #asm("cli")
                 _0x80007:
000545 94f8      	cli
                 ; 0004 0041        --rx_counter1;
000546 94aa      	DEC  R10
                 ; 0004 0042        #asm("sei")
000547 9478      	sei
                 ; 0004 0043        mRcvErrFlag1 = 0;
000548 24cc      	CLR  R12
                 ; 0004 0044        return data;
000549 2fe1      	MOV  R30,R17
00054a c069      	RJMP _0x20A0007
                 ; 0004 0045     }
                 ; 0004 0046     else
                 _0x80006:
                 ; 0004 0047     {
                 ; 0004 0048        mRcvErrFlag1 = 1;
00054b e0e1      	LDI  R30,LOW(1)
00054c 2ece      	MOV  R12,R30
                 ; 0004 0049        return 0;
00054d e0e0      	LDI  R30,LOW(0)
00054e c065      	RJMP _0x20A0007
                 ; 0004 004A     }
                 ; 0004 004B }
                 ; .FEND
                 ;
                 ;//#pragma used-
                 ;BYTE  IPC_Get_RxCount1( void )
                 ; 0004 004F {
                 _IPC_Get_RxCount1:
                 ; .FSTART _IPC_Get_RxCount1
                 ; 0004 0050    return rx_counter1;
00054f 2dea      	MOV  R30,R10
000550 9508      	RET
                 ; 0004 0051 }
                 ; .FEND
                 ;
                 ;void IPC_ResetCount1( void )
                 ; 0004 0054 {
                 _IPC_ResetCount1:
                 ; .FSTART _IPC_ResetCount1
                 ; 0004 0055    #asm("cli")
000551 94f8      	cli
                 ; 0004 0056    rx_counter1 = 0;
000552 24aa      	CLR  R10
                 ; 0004 0057    rx_rd_index1 = 0;
000553 24bb      	CLR  R11
                 ; 0004 0058    rx_wr_index1 = 0;
000554 2488      	CLR  R8
                 ; 0004 0059    #asm("sei")
000555 9478      	sei
                 ; 0004 005A }
000556 9508      	RET
                 ; .FEND
                 ;
                 ;char Mygetchar1( BYTE flag )
                 ; 0004 005D {
                 ; 0004 005E       WORD oldTime1ms;
                 ; 0004 005F       char status,data;
                 ; 0004 0060 
                 ; 0004 0061       while ( 1 )
                 ;	flag -> Y+4
                 ;	oldTime1ms -> R16,R17
                 ;	status -> R19
                 ;	data -> R18
                 ; 0004 0062       {
                 ; 0004 0063           if( flag )
                 ; 0004 0064                oldTime1ms = gTime1ms;
                 ; 0004 0065 
                 ; 0004 0066           while ( ((status=UCSR1A) & RX_COMPLETE) == 0 )
                 ; 0004 0067           {
                 ; 0004 0068               if( flag )
                 ; 0004 0069               {
                 ; 0004 006A                  if( (gTime1ms - oldTime1ms) > 300 ) //old 300
                 ; 0004 006B                  {
                 ; 0004 006C                       return 0;
                 ; 0004 006D                  }
                 ; 0004 006E               }
                 ; 0004 006F           };
                 ; 0004 0070 
                 ; 0004 0071           data = UDR1;
                 ; 0004 0072           if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
                 ; 0004 0073           return data;
                 ; 0004 0074       };
                 ; 0004 0075 }
                 ;
                 ;char Tgetchar1( void )
                 ; 0004 0078 {
                 ; 0004 0079       char status,data;
                 ; 0004 007A       while ( 1 )
                 ;	status -> R17
                 ;	data -> R16
                 ; 0004 007B       {
                 ; 0004 007C           while ( ((status=UCSR1A) & RX_COMPLETE)==0 );
                 ; 0004 007D               data = UDR1;
                 ; 0004 007E           if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
                 ; 0004 007F          return data;
                 ; 0004 0080       };
                 ; 0004 0081 }
                 ;
                 ;void Tputchar1( char c )
                 ; 0004 0084 {
                 _Tputchar1:
                 ; .FSTART _Tputchar1
                 ; 0004 0085      while ((UCSR1A & DATA_REGISTER_EMPTY)==0);
000557 93aa      	ST   -Y,R26
                 ;	c -> Y+0
                 _0x8001A:
000558 91e0 009b 	LDS  R30,155
00055a 72e0      	ANDI R30,LOW(0x20)
00055b f3e1      	BREQ _0x8001A
                 ; 0004 0086      UDR1 = c;
00055c 81e8      	LD   R30,Y
00055d 93e0 009c 	STS  156,R30
                 ; 0004 0087 }
00055f c063      	RJMP _0x20A0006
                 ; .FEND
                 ;
                 ;void Usrprintf1( char  *string )
                 ; 0004 008A {
                 ; 0004 008B     while( *string != '\0' )
                 ;	*string -> Y+0
                 ; 0004 008C     {
                 ; 0004 008D         Tputchar1(*string++);
                 ; 0004 008E     }
                 ; 0004 008F }
                 ;
                 ;void FlashUsrprintf1( const char *string )
                 ; 0004 0092 {
                 ; 0004 0093     while( *string != '\0' )
                 ;	*string -> Y+0
                 ; 0004 0094     {
                 ; 0004 0095         Tputchar1(*string++);
                 ; 0004 0096     }
                 ; 0004 0097 }
                 ;
                 ;void MyPrint1( char flash* format, ...)
                 ; 0004 009A {
                 ; 0004 009B       char str[100];
                 ; 0004 009C 
                 ; 0004 009D       va_list arg;
                 ; 0004 009E       va_start(arg, format);
                 ;	*format -> Y+102
                 ;	str -> Y+2
                 ;	*arg -> R16,R17
                 ; 0004 009F 
                 ; 0004 00A0       vsprintf( str, format, arg);
                 ; 0004 00A1       va_end(arg);
                 ; 0004 00A2 
                 ; 0004 00A3       Usrprintf1( str ); // putchar1()   .- ~
                 ; 0004 00A4 }
                 ;
                 ;BYTE  IPC_RcvData1( BYTE *Buffer, BYTE len )
                 ; 0004 00A7 {
                 ; 0004 00A8    BYTE i=0;
                 ; 0004 00A9 
                 ; 0004 00AA    while( i < len )
                 ;	*Buffer -> Y+2
                 ;	len -> Y+1
                 ;	i -> R17
                 ; 0004 00AB    {
                 ; 0004 00AC         Buffer[i] = Mygetchar1(i);
                 ; 0004 00AD         i++;
                 ; 0004 00AE    }
                 ; 0004 00AF    return  i;
                 ; 0004 00B0 }
                 ;
                 ;
                 ;BYTE  IPC_RcvData_Interrupt1( BYTE *Buffer, BYTE len )
                 ; 0004 00B4 {
                 _IPC_RcvData_Interrupt1:
                 ; .FSTART _IPC_RcvData_Interrupt1
                 ; 0004 00B5    BYTE i=0;
                 ; 0004 00B6    char dat = 0;
                 ; 0004 00B7    WORD oldTime1ms;
                 ; 0004 00B8    oldTime1ms = gTime1ms;
000560 940e 0ce3 	CALL SUBOPT_0x31
                 ;	*Buffer -> Y+5
                 ;	len -> Y+4
                 ;	i -> R17
                 ;	dat -> R16
                 ;	oldTime1ms -> R18,R19
                 ; 0004 00B9 
                 ; 0004 00BA    while( i < len )
                 _0x80026:
000562 81ec      	LDD  R30,Y+4
000563 171e      	CP   R17,R30
000564 f468      	BRSH _0x80028
                 ; 0004 00BB    {
                 ; 0004 00BC        dat = getchar1();
000565 dfd1      	RCALL _getchar1
000566 2f0e      	MOV  R16,R30
                 ; 0004 00BD        if( mRcvErrFlag1 == 0  )
000567 20cc      	TST  R12
000568 f411      	BRNE _0x80029
                 ; 0004 00BE        {
                 ; 0004 00BF           Buffer[i] = dat;
000569 940e 0ced 	CALL SUBOPT_0x32
                 ; 0004 00C0           i++;
                 ; 0004 00C1        }
                 ; 0004 00C2        if( (gTime1ms - oldTime1ms) > 3000 ) //old 300
                 _0x80029:
00056b 940e 0cf6 	CALL SUBOPT_0x33
00056d f018      	BRLO _0x8002A
                 ; 0004 00C3        {
                 ; 0004 00C4           IPC_ResetCount1();
00056e dfe2      	RCALL _IPC_ResetCount1
                 ; 0004 00C5           return 0;
00056f e0e0      	LDI  R30,LOW(0)
000570 c067      	RJMP _0x20A0004
                 ; 0004 00C6        }
                 ; 0004 00C7    }
                 _0x8002A:
000571 cff0      	RJMP _0x80026
                 _0x80028:
                 ; 0004 00C8    return  i;
000572 c064      	RJMP _0x20A0005
                 ; 0004 00C9 }
                 ; .FEND
                 ;
                 ;BYTE IPC_SendData1( BYTE *Buffer, BYTE len )
                 ; 0004 00CC {
                 _IPC_SendData1:
                 ; .FSTART _IPC_SendData1
                 ; 0004 00CD    BYTE i;
                 ; 0004 00CE    i= 0;
000573 93aa      	ST   -Y,R26
000574 931a      	ST   -Y,R17
                 ;	*Buffer -> Y+2
                 ;	len -> Y+1
                 ;	i -> R17
000575 e010      	LDI  R17,LOW(0)
                 ; 0004 00CF    while( i < len )
                 _0x8002B:
000576 81e9      	LDD  R30,Y+1
000577 171e      	CP   R17,R30
000578 f420      	BRSH _0x8002D
                 ; 0004 00D0    {
                 ; 0004 00D1      Tputchar1(Buffer[i++]);
000579 940e 0d00 	CALL SUBOPT_0x34
00057b dfdb      	RCALL _Tputchar1
                 ; 0004 00D2    }
00057c cff9      	RJMP _0x8002B
                 _0x8002D:
                 ; 0004 00D3 
                 ; 0004 00D4    return  i;
00057d c068      	RJMP _0x20A0002
                 ; 0004 00D5 }
                 ; .FEND
                 ;
                 ;
                 ;// USART0 Receiver interrupt service routine
                 ;interrupt [USART0_RXC] void usart0_rx_isr(void)
                 ; 0004 00DA {
                 _usart0_rx_isr:
                 ; .FSTART _usart0_rx_isr
00057e 940e 0cdc 	CALL SUBOPT_0x30
                 ; 0004 00DB    char status,data;
                 ; 0004 00DC    status=UCSR0A;
                 ;	status -> R17
                 ;	data -> R16
000580 b11b      	IN   R17,11
                 ; 0004 00DD    data=UDR0;
000581 b10c      	IN   R16,12
                 ; 0004 00DE 
                 ; 0004 00DF    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
000582 2fe1      	MOV  R30,R17
000583 71ec      	ANDI R30,LOW(0x1C)
000584 f489      	BRNE _0x8002E
                 ; 0004 00E0    {
                 ; 0004 00E1       rx_buffer0[rx_wr_index0++]=data;
000585 2de5      	MOV  R30,R5
000586 9453      	INC  R5
000587 e0f0      	LDI  R31,0
000588 58e1      	SUBI R30,LOW(-_rx_buffer0)
000589 4ffa      	SBCI R31,HIGH(-_rx_buffer0)
00058a 8300      	ST   Z,R16
                 ; 0004 00E2       if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
00058b efea      	LDI  R30,LOW(250)
00058c 15e5      	CP   R30,R5
00058d f409      	BRNE _0x8002F
00058e 2455      	CLR  R5
                 ; 0004 00E3       if (++rx_counter0 == RX_BUFFER_SIZE0)
                 _0x8002F:
00058f 9473      	INC  R7
000590 efea      	LDI  R30,LOW(250)
000591 15e7      	CP   R30,R7
000592 f419      	BRNE _0x80030
                 ; 0004 00E4       {
                 ; 0004 00E5         rx_counter0=0;
000593 2477      	CLR  R7
                 ; 0004 00E6         rx_buffer_overflow0=TRUE;
000594 e0e1      	LDI  R30,LOW(1)
000595 2e6e      	MOV  R6,R30
                 ; 0004 00E7       }
                 ; 0004 00E8    }
                 _0x80030:
                 ; 0004 00E9 }
                 _0x8002E:
                 _0x80059:
000596 9109      	LD   R16,Y+
000597 9119      	LD   R17,Y+
000598 91e9      	LD   R30,Y+
000599 bfef      	OUT  SREG,R30
00059a 91f9      	LD   R31,Y+
00059b 91e9      	LD   R30,Y+
00059c 9518      	RETI
                 ; .FEND
                 ;
                 ;// Get a character from the USART1 Receiver buffer
                 ;char getchar0( void )
                 ; 0004 00ED {
                 _getchar0:
                 ; .FSTART _getchar0
                 ; 0004 00EE     char data;
                 ; 0004 00EF     if( rx_counter0 >0 )
00059d 931a      	ST   -Y,R17
                 ;	data -> R17
00059e e0e0      	LDI  R30,LOW(0)
00059f 15e7      	CP   R30,R7
0005a0 f480      	BRSH _0x80031
                 ; 0004 00F0     {
                 ; 0004 00F1       data = rx_buffer0[rx_rd_index0++];
0005a1 2de4      	MOV  R30,R4
0005a2 9443      	INC  R4
0005a3 e0f0      	LDI  R31,0
0005a4 58e1      	SUBI R30,LOW(-_rx_buffer0)
0005a5 4ffa      	SBCI R31,HIGH(-_rx_buffer0)
0005a6 8110      	LD   R17,Z
                 ; 0004 00F2       if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
0005a7 efea      	LDI  R30,LOW(250)
0005a8 15e4      	CP   R30,R4
0005a9 f409      	BRNE _0x80032
0005aa 2444      	CLR  R4
                 ; 0004 00F3 
                 ; 0004 00F4        #asm("cli")
                 _0x80032:
0005ab 94f8      	cli
                 ; 0004 00F5        --rx_counter0;
0005ac 947a      	DEC  R7
                 ; 0004 00F6        #asm("sei")
0005ad 9478      	sei
                 ; 0004 00F7        mRcvErrFlag0 = 0;
0005ae 2499      	CLR  R9
                 ; 0004 00F8        return data;
0005af 2fe1      	MOV  R30,R17
0005b0 c003      	RJMP _0x20A0007
                 ; 0004 00F9     }
                 ; 0004 00FA     else
                 _0x80031:
                 ; 0004 00FB     {
                 ; 0004 00FC        mRcvErrFlag0 = 1;
0005b1 e0e1      	LDI  R30,LOW(1)
0005b2 2e9e      	MOV  R9,R30
                 ; 0004 00FD        return 0;
0005b3 e0e0      	LDI  R30,LOW(0)
                 ; 0004 00FE     }
                 ; 0004 00FF }
                 _0x20A0007:
0005b4 9119      	LD   R17,Y+
0005b5 9508      	RET
                 ; .FEND
                 ;
                 ;//#pragma used-
                 ;BYTE  IPC_Get_RxCount0( void )
                 ; 0004 0103 {
                 _IPC_Get_RxCount0:
                 ; .FSTART _IPC_Get_RxCount0
                 ; 0004 0104    return rx_counter0;
0005b6 2de7      	MOV  R30,R7
0005b7 9508      	RET
                 ; 0004 0105 }
                 ; .FEND
                 ;
                 ;void IPC_ResetCount0( void )
                 ; 0004 0108 {
                 _IPC_ResetCount0:
                 ; .FSTART _IPC_ResetCount0
                 ; 0004 0109    #asm("cli")
0005b8 94f8      	cli
                 ; 0004 010A    rx_counter0 = 0;
0005b9 2477      	CLR  R7
                 ; 0004 010B    rx_rd_index0 = 0;
0005ba 2444      	CLR  R4
                 ; 0004 010C    rx_wr_index0 = 0;
0005bb 2455      	CLR  R5
                 ; 0004 010D    #asm("sei")
0005bc 9478      	sei
                 ; 0004 010E }
0005bd 9508      	RET
                 ; .FEND
                 ;
                 ;char Mygetchar0( BYTE flag )
                 ; 0004 0111 {
                 ; 0004 0112       WORD oldTime1ms;
                 ; 0004 0113       char status,data;
                 ; 0004 0114 
                 ; 0004 0115       while ( 1 )
                 ;	flag -> Y+4
                 ;	oldTime1ms -> R16,R17
                 ;	status -> R19
                 ;	data -> R18
                 ; 0004 0116       {
                 ; 0004 0117           if( flag )
                 ; 0004 0118                oldTime1ms = gTime1ms;
                 ; 0004 0119 
                 ; 0004 011A           while ( ((status=UCSR0A) & RX_COMPLETE) == 0 )
                 ; 0004 011B           {
                 ; 0004 011C               if( flag )
                 ; 0004 011D               {
                 ; 0004 011E                  if( (gTime1ms - oldTime1ms) > 300 ) //old 300
                 ; 0004 011F                  {
                 ; 0004 0120                       return 0;
                 ; 0004 0121                  }
                 ; 0004 0122               }
                 ; 0004 0123           };
                 ; 0004 0124 
                 ; 0004 0125           data = UDR0;
                 ; 0004 0126           if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
                 ; 0004 0127           return data;
                 ; 0004 0128       };
                 ; 0004 0129 }
                 ;
                 ;char Tgetchar0( void )
                 ; 0004 012C {
                 ; 0004 012D       char status,data;
                 ; 0004 012E       while ( 1 )
                 ;	status -> R17
                 ;	data -> R16
                 ; 0004 012F       {
                 ; 0004 0130           while ( ((status=UCSR0A) & RX_COMPLETE)==0 );
                 ; 0004 0131               data = UDR0;
                 ; 0004 0132           if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
                 ; 0004 0133          return data;
                 ; 0004 0134       };
                 ; 0004 0135 }
                 ;
                 ;void Tputchar0( char c )
                 ; 0004 0138 {
                 _Tputchar0:
                 ; .FSTART _Tputchar0
                 ; 0004 0139      while ((UCSR0A & DATA_REGISTER_EMPTY)==0);
0005be 93aa      	ST   -Y,R26
                 ;	c -> Y+0
                 _0x80045:
0005bf 9b5d      	SBIS 0xB,5
0005c0 cffe      	RJMP _0x80045
                 ; 0004 013A      UDR0 = c;
0005c1 81e8      	LD   R30,Y
0005c2 b9ec      	OUT  0xC,R30
                 ; 0004 013B }
                 _0x20A0006:
0005c3 9621      	ADIW R28,1
0005c4 9508      	RET
                 ; .FEND
                 ;
                 ;void Usrprintf0( char  *string )
                 ; 0004 013E {
                 ; 0004 013F     while( *string != '\0' )
                 ;	*string -> Y+0
                 ; 0004 0140     {
                 ; 0004 0141         Tputchar0(*string++);
                 ; 0004 0142     }
                 ; 0004 0143 }
                 ;
                 ;void FlashUsrprintf0( const char *string )
                 ; 0004 0146 {
                 ; 0004 0147     while( *string != '\0' )
                 ;	*string -> Y+0
                 ; 0004 0148     {
                 ; 0004 0149         Tputchar0(*string++);
                 ; 0004 014A     }
                 ; 0004 014B }
                 ;
                 ;void MyPrint0( char flash* format, ...)
                 ; 0004 014E {
                 ; 0004 014F       char str[100];
                 ; 0004 0150 
                 ; 0004 0151       va_list arg;
                 ; 0004 0152       va_start(arg, format);
                 ;	*format -> Y+102
                 ;	str -> Y+2
                 ;	*arg -> R16,R17
                 ; 0004 0153 
                 ; 0004 0154       vsprintf( str, format, arg);
                 ; 0004 0155       va_end(arg);
                 ; 0004 0156 
                 ; 0004 0157       Usrprintf0( str ); // putchar1()   .- ~
                 ; 0004 0158 }
                 ;
                 ;BYTE  IPC_RcvData0( BYTE *Buffer, BYTE len )
                 ; 0004 015B {
                 ; 0004 015C    BYTE i=0;
                 ; 0004 015D 
                 ; 0004 015E    while( i < len )
                 ;	*Buffer -> Y+2
                 ;	len -> Y+1
                 ;	i -> R17
                 ; 0004 015F    {
                 ; 0004 0160         Buffer[i] = Mygetchar0(i);
                 ; 0004 0161         i++;
                 ; 0004 0162    }
                 ; 0004 0163    return  i;
                 ; 0004 0164 }
                 ;
                 ;BYTE IPC_RcvData_Interrupt0( BYTE *Buffer, BYTE len )
                 ; 0004 0167 {
                 _IPC_RcvData_Interrupt0:
                 ; .FSTART _IPC_RcvData_Interrupt0
                 ; 0004 0168    BYTE i=0;
                 ; 0004 0169    char dat = 0;
                 ; 0004 016A    WORD oldTime1ms;
                 ; 0004 016B    oldTime1ms = gTime1ms;
0005c5 940e 0ce3 	CALL SUBOPT_0x31
                 ;	*Buffer -> Y+5
                 ;	len -> Y+4
                 ;	i -> R17
                 ;	dat -> R16
                 ;	oldTime1ms -> R18,R19
                 ; 0004 016C 
                 ; 0004 016D    while( i < len )
                 _0x80051:
0005c7 81ec      	LDD  R30,Y+4
0005c8 171e      	CP   R17,R30
0005c9 f468      	BRSH _0x80053
                 ; 0004 016E    {
                 ; 0004 016F        dat = getchar0();
0005ca dfd2      	RCALL _getchar0
0005cb 2f0e      	MOV  R16,R30
                 ; 0004 0170        if( mRcvErrFlag0 == 0  )
0005cc 2099      	TST  R9
0005cd f411      	BRNE _0x80054
                 ; 0004 0171        {
                 ; 0004 0172           Buffer[i] = dat;
0005ce 940e 0ced 	CALL SUBOPT_0x32
                 ; 0004 0173           i++;
                 ; 0004 0174        }
                 ; 0004 0175        if( (gTime1ms - oldTime1ms) > 3000 ) //old 300
                 _0x80054:
0005d0 940e 0cf6 	CALL SUBOPT_0x33
0005d2 f018      	BRLO _0x80055
                 ; 0004 0176        {
                 ; 0004 0177           IPC_ResetCount0();
0005d3 dfe4      	RCALL _IPC_ResetCount0
                 ; 0004 0178           return 0;
0005d4 e0e0      	LDI  R30,LOW(0)
0005d5 c002      	RJMP _0x20A0004
                 ; 0004 0179        }
                 ; 0004 017A    }
                 _0x80055:
0005d6 cff0      	RJMP _0x80051
                 _0x80053:
                 ; 0004 017B    return  i;
                 _0x20A0005:
0005d7 2fe1      	MOV  R30,R17
                 _0x20A0004:
0005d8 940e 100b 	CALL __LOADLOCR4
0005da 9627      	ADIW R28,7
0005db 9508      	RET
                 ; 0004 017C }
                 ; .FEND
                 ;
                 ;BYTE IPC_SendData0( BYTE *Buffer, BYTE len )
                 ; 0004 017F {
                 _IPC_SendData0:
                 ; .FSTART _IPC_SendData0
                 ; 0004 0180    BYTE i;
                 ; 0004 0181    i= 0;
0005dc 93aa      	ST   -Y,R26
0005dd 931a      	ST   -Y,R17
                 ;	*Buffer -> Y+2
                 ;	len -> Y+1
                 ;	i -> R17
0005de e010      	LDI  R17,LOW(0)
                 ; 0004 0182    while( i < len )
                 _0x80056:
0005df 81e9      	LDD  R30,Y+1
0005e0 171e      	CP   R17,R30
0005e1 f420      	BRSH _0x80058
                 ; 0004 0183    {
                 ; 0004 0184      Tputchar0(Buffer[i++]);
0005e2 940e 0d00 	CALL SUBOPT_0x34
0005e4 dfd9      	RCALL _Tputchar0
                 ; 0004 0185    }
0005e5 cff9      	RJMP _0x80056
                 _0x80058:
                 ; 0004 0186 
                 ; 0004 0187    return  i;
                 _0x20A0002:
0005e6 2fe1      	MOV  R30,R17
0005e7 8118      	LDD  R17,Y+0
                 _0x20A0003:
0005e8 9624      	ADIW R28,4
0005e9 9508      	RET
                 ; 0004 0188 }
                 ; .FEND
                 ;#include <stdio.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include "SpiLib.h"
                 ;
                 ;BYTE Spi_ReadByte( void  )
                 ; 0005 0005 {
                 
                 	.CSEG
                 ; 0005 0006    BYTE temp;
                 ; 0005 0007 
                 ; 0005 0008    SPDR = 0xff;
                 ;	temp -> R17
                 ; 0005 0009    while(!(SPSR&0x80));
                 ; 0005 000A    temp=SPDR;
                 ; 0005 000B 
                 ; 0005 000C    return temp;
                 ; 0005 000D }
                 ;
                 ;void Spi_WriteByte(BYTE data )
                 ; 0005 0010 {
                 ; 0005 0011    SPDR = data;
                 ;	data -> Y+0
                 ; 0005 0012    while(!(SPSR&0x80));
                 ; 0005 0013    data = SPDR;
                 ; 0005 0014 }
                 ;#include <mega128.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;#include "InAdc.h"
                 ;
                 ;#define ADC_VREF_TYPE 0x00
                 ;
                 ;// Read the AD conversion result
                 ;int read_adc( BYTE adc_input )
                 ; 0006 0009 {
                 
                 	.CSEG
                 _read_adc:
                 ; .FSTART _read_adc
                 ; 0006 000A   WORD temp;
                 ; 0006 000B   int  RetVal;
                 ; 0006 000C 
                 ; 0006 000D   ADMUX = adc_input | (ADC_VREF_TYPE & 0xff);
0005ea 93aa      	ST   -Y,R26
0005eb 940e 1004 	CALL __SAVELOCR4
                 ;	adc_input -> Y+4
                 ;	temp -> R16,R17
                 ;	RetVal -> R18,R19
0005ed 81ec      	LDD  R30,Y+4
0005ee b9e7      	OUT  0x7,R30
                 ; 0006 000E   // Delay needed for the stabilization of the ADC input voltage
                 ; 0006 000F   delay_us(10);
                +
0005ef e385     +LDI R24 , LOW ( 53 )
                +__DELAY_USB_LOOP :
0005f0 958a     +DEC R24
0005f1 f7f1     +BRNE __DELAY_USB_LOOP
                 	__DELAY_USB 53
                 ; 0006 0010   // Start the AD conversion
                 ; 0006 0011   ADCSRA|=0x40;
0005f2 9a36      	SBI  0x6,6
                 ; 0006 0012   // Wait for the AD conversion to complete
                 ; 0006 0013   while ((ADCSRA & 0x10)==0);
                 _0xC0003:
0005f3 9b34      	SBIS 0x6,4
0005f4 cffe      	RJMP _0xC0003
                 ; 0006 0014   ADCSRA |=0x10;
0005f5 9a34      	SBI  0x6,4
                 ; 0006 0015 
                 ; 0006 0016  // return ADCW;
                 ; 0006 0017   temp  = ADCW;
                +
0005f6 b104     +IN R16 , 4
0005f7 b115     +IN R17 , 4 + 1
                 	__INWR 16,17,4
                 ; 0006 0018 
                 ; 0006 0019   RetVal =  (int)(5.0f*10.0f*(float)temp/1024.0f);
0005f8 01f8      	MOVW R30,R16
0005f9 2766      	CLR  R22
0005fa 2777      	CLR  R23
0005fb 940e 0e50 	CALL __CDF1
                +
0005fd e0a0     +LDI R26 , LOW ( 0x42480000 )
0005fe e0b0     +LDI R27 , HIGH ( 0x42480000 )
0005ff e488     +LDI R24 , BYTE3 ( 0x42480000 )
000600 e492     +LDI R25 , BYTE4 ( 0x42480000 )
                 	__GETD2N 0x42480000
000601 940e 0eda 	CALL __MULF12
000603 01df      	MOVW R26,R30
000604 01cb      	MOVW R24,R22
                +
000605 e0e0     +LDI R30 , LOW ( 0x44800000 )
000606 e0f0     +LDI R31 , HIGH ( 0x44800000 )
000607 e860     +LDI R22 , BYTE3 ( 0x44800000 )
000608 e474     +LDI R23 , BYTE4 ( 0x44800000 )
                 	__GETD1N 0x44800000
000609 940e 0f28 	CALL __DIVF21
00060b 940e 0e19 	CALL __CFD1
00060d 019f      	MOVW R18,R30
                 ; 0006 001A 
                 ; 0006 001B   return RetVal;
00060e 940e 100b 	CALL __LOADLOCR4
                 _0x20A0001:
000610 9625      	ADIW R28,5
000611 9508      	RET
                 ; 0006 001C }
                 ; .FEND
                 ;#include <mega128.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <stdio.h>
                 ;#include <delay.h>
                 ;#include <math.h>
                 ;#include <string.h>
                 ;
                 ;#include "DAC7611/DAC7611.h"
                 ;#include "Uart/uart.h"
                 ;#include "IPC/IPClib.h"
                 ;#include "InAdc/InAdc.h"
                 ;#include "InEEprom/InEepromLib.h"
                 ;
                 ;const float DacArray[12] = {10.0f, 20.0f, 30.0f, 40.20f, 13.20f, 16.94f, 21.28f, 25.82f, 30.57f, 35.4f, 40.0f, 55.9f};
                 ;
                 ;// Variables
                 ;int  gVoltage;
                 ;BYTE gMode;
                 ;BOOL gRunFlag;
                 ;int  gDepth;
                 ;int  gSpeed;
                 ;int  gElCount=0;
                 ;BYTE gFlag;
                 ;int  gDose;
                 ;BYTE gError;
                 ;int  gAdcLoc=0;
                 ;int  gElLoc=0;
                 ;int  gMotorPos1=0;
                 ;int  gMotorPos2=0;
                 ;
                 ;
                 ;WORD gTime1ms;
                 ;WORD goldTime1ms;
                 ;BYTE WaitEvent( void );
                 ;BYTE gElMatrix[4];
                 ;int  gCurState=0;
                 ;int  gCalValue0,gCalValue1;
                 ;int  gDutyOff=0;
                 ;BOOL gElCompletFlag = FALSE;
                 ;int  gShift=0;
                 ;//int  gReadVol;
                 ;int  gVolAdjCount=0;
                 ;int  gVolChkCount = 0;
                 ;//int  gInitCount=0;
                 ;BYTE gCurMode;
                 ;BOOL gGenMode=FALSE;
                 ;BOOL gReadyActionFlag=FALSE;
                 ;
                 ;void InitSettingData(void);
                 ;void LoadInEeprom( void);
                 ;void InitData(void);
                 ;
                 ;//const int LowVolAdj[4] = {0, 8, 7, 0};
                 ;
                 ;// Timer 0 overflow interrupt service routine
                 ;interrupt [TIM0_OVF] void timer0_ovf_isr(void)
                 ; 0007 0038 {
                 
                 	.CSEG
                 _timer0_ovf_isr:
                 ; .FSTART _timer0_ovf_isr
000612 93aa      	ST   -Y,R26
000613 93ba      	ST   -Y,R27
000614 93ea      	ST   -Y,R30
000615 93fa      	ST   -Y,R31
000616 b7ef      	IN   R30,SREG
000617 93ea      	ST   -Y,R30
                 ; 0007 0039     // Reinitialize Timer 0 value
                 ; 0007 003A     TCNT0 = 0x06;   //1ms
000618 e0e6      	LDI  R30,LOW(6)
000619 bfe2      	OUT  0x32,R30
                 ; 0007 003B     // Place your code here
                 ; 0007 003C     gTime1ms++;
00061a e0a6      	LDI  R26,LOW(_gTime1ms)
00061b e0b5      	LDI  R27,HIGH(_gTime1ms)
00061c 940e 0d09 	CALL SUBOPT_0x35
                 ; 0007 003D }
00061e 91e9      	LD   R30,Y+
00061f bfef      	OUT  SREG,R30
000620 91f9      	LD   R31,Y+
000621 91e9      	LD   R30,Y+
000622 91b9      	LD   R27,Y+
000623 91a9      	LD   R26,Y+
000624 9518      	RETI
                 ; .FEND
                 ;
                 ;void PulseGenerator1( void )
                 ; 0007 0040 {
                 ; 0007 0041    // Reinitialize Timer1 value
                 ; 0007 0042     TCNT1H=0xB1E0 >> 8;           //10ms
                 ; 0007 0043     TCNT1L=0xB1E0 & 0xff;
                 ; 0007 0044 
                 ; 0007 0045     // Place your code here
                 ; 0007 0046     if( gRunFlag==TRUE && gElCompletFlag == FALSE )
                 ; 0007 0047     {
                 ; 0007 0048        if( gCurState == 0 )
                 ; 0007 0049        {
                 ; 0007 004A           gCalValue0 = gElMatrix[gElLoc]<<4 |(~gElMatrix[gElLoc])&0x0f; //((~gElMatrix[gElLoc]<<4)&0xf0)| gElMatrix[gElL ...
                 ; 0007 004B           gCalValue1 = gCalValue0&0x0f; // (~gElMatrix[gElLoc])&0x0f;
                 ; 0007 004C 
                 ; 0007 004D           PORTC = gCalValue0;
                 ; 0007 004E           gCurState = 1;
                 ; 0007 004F        }
                 ; 0007 0050        else if( gCurState == 1 )
                 ; 0007 0051        {
                 ; 0007 0052           PORTC = gCalValue1;
                 ; 0007 0053           gCurState = 2;
                 ; 0007 0054        }
                 ; 0007 0055        else if( gCurState == 2 )
                 ; 0007 0056        {
                 ; 0007 0057           PORTC = gCalValue0;
                 ; 0007 0058           gCurState = 3;
                 ; 0007 0059        }
                 ; 0007 005A        else if( gCurState == 3 )
                 ; 0007 005B        {
                 ; 0007 005C           PORTC = gCalValue1;
                 ; 0007 005D           gCurState = 4;
                 ; 0007 005E        }
                 ; 0007 005F        else if( gCurState == 4 )
                 ; 0007 0060        {
                 ; 0007 0061           PORTC = gCalValue0;
                 ; 0007 0062           gCurState = 5;
                 ; 0007 0063        }
                 ; 0007 0064        else if( gCurState == 5 )
                 ; 0007 0065        {
                 ; 0007 0066           gDutyOff = 0;
                 ; 0007 0067           PORTC = gCalValue1;
                 ; 0007 0068           gCurState = 6;
                 ; 0007 0069        }
                 ; 0007 006A        else if( gCurState == 6 )
                 ; 0007 006B        {
                 ; 0007 006C           gDutyOff++;
                 ; 0007 006D           if( gDutyOff >8)
                 ; 0007 006E           {
                 ; 0007 006F              gCurState = 0;
                 ; 0007 0070              gElLoc++;
                 ; 0007 0071              if( gElLoc > 3 )
                 ; 0007 0072              {
                 ; 0007 0073                 PORTC = 0;
                 ; 0007 0074                 gElLoc = 0;
                 ; 0007 0075                 gElCompletFlag = TRUE;
                 ; 0007 0076              }
                 ; 0007 0077           }
                 ; 0007 0078        }
                 ; 0007 0079    }
                 ; 0007 007A }
                 ;
                 ;void PulseGenerator2( void )
                 ; 0007 007D {
                 ; 0007 007E      // Reinitialize Timer1 value
                 ; 0007 007F     TCNT1H=0xE013 >> 8;          //     0.4ms
                 ; 0007 0080     TCNT1L=0xE013 & 0xff;
                 ; 0007 0081 
                 ; 0007 0082     // Place your code here
                 ; 0007 0083     if( gRunFlag==TRUE && gElCompletFlag == FALSE )
                 ; 0007 0084     {
                 ; 0007 0085        if( gCurState == 0 )
                 ; 0007 0086        {
                 ; 0007 0087           gCalValue0 = gElMatrix[gElLoc]<<4 |(~gElMatrix[gElLoc])&0x0f; //((~gElMatrix[gElLoc]<<4)&0xf0)| gElMatrix[gElL ...
                 ; 0007 0088           gCalValue1 = gCalValue0&0x0f; // (~gElMatrix[gElLoc])&0x0f;
                 ; 0007 0089 
                 ; 0007 008A           PORTC = gCalValue0;
                 ; 0007 008B           gDutyOff = 0;
                 ; 0007 008C           gCurState = 1;
                 ; 0007 008D        }
                 ; 0007 008E        else if( gCurState == 1 )
                 ; 0007 008F        {
                 ; 0007 0090           gDutyOff++;
                 ; 0007 0091           if( gDutyOff >10 ) gCurState = 2;
                 ; 0007 0092        }
                 ; 0007 0093        else if( gCurState == 2 )
                 ; 0007 0094        {
                 ; 0007 0095           gDutyOff = 0;
                 ; 0007 0096           PORTC = gCalValue1;
                 ; 0007 0097           gCurState = 3;
                 ; 0007 0098        }
                 ; 0007 0099        else if( gCurState == 3 )
                 ; 0007 009A        {
                 ; 0007 009B           PORTC = gCalValue0;
                 ; 0007 009C           gDutyOff++;
                 ; 0007 009D           if( gDutyOff >11) gCurState = 4;
                 ; 0007 009E        }
                 ; 0007 009F        else if( gCurState == 4 )
                 ; 0007 00A0        {
                 ; 0007 00A1           gDutyOff = 0;
                 ; 0007 00A2           PORTC = gCalValue1;
                 ; 0007 00A3           gCurState = 5;
                 ; 0007 00A4        }
                 ; 0007 00A5        else if( gCurState == 5 )
                 ; 0007 00A6        {
                 ; 0007 00A7           gDutyOff++;
                 ; 0007 00A8           if( gDutyOff >297)     //150ms
                 ; 0007 00A9           {
                 ; 0007 00AA              gCurState = 0;
                 ; 0007 00AB              gElLoc++;
                 ; 0007 00AC              if( gElLoc > 3 )
                 ; 0007 00AD              {
                 ; 0007 00AE                 PORTC = 0x00;
                 ; 0007 00AF                 gElLoc = 0;
                 ; 0007 00B0                 gElCompletFlag = TRUE;
                 ; 0007 00B1              }
                 ; 0007 00B2           }
                 ; 0007 00B3        }
                 ; 0007 00B4    }
                 ; 0007 00B5 }
                 ;
                 ;void PulseGenerator3( void )
                 ; 0007 00B8 {
                 ; 0007 00B9    // Reinitialize Timer1 value
                 ; 0007 00BA     TCNT1H=0xE700 >> 8;          //     0.4ms
                 ; 0007 00BB     TCNT1L=0xE700 & 0xff;
                 ; 0007 00BC 
                 ; 0007 00BD     // Place your code here
                 ; 0007 00BE     if( gRunFlag==TRUE && gElCompletFlag == FALSE )
                 ; 0007 00BF     {
                 ; 0007 00C0        if( gCurState == 0 )
                 ; 0007 00C1        {
                 ; 0007 00C2           gCalValue0 = gElMatrix[gElLoc]<<4 |(~gElMatrix[gElLoc])&0x0f; //((~gElMatrix[gElLoc]<<4)&0xf0)| gElMatrix[gElL ...
                 ; 0007 00C3           gCalValue1 = gCalValue0&0x0f; // (~gElMatrix[gElLoc])&0x0f;
                 ; 0007 00C4 
                 ; 0007 00C5           PORTC = gCalValue0;
                 ; 0007 00C6           gDutyOff = 0;
                 ; 0007 00C7 
                 ; 0007 00C8           gCurState = 1;
                 ; 0007 00C9        }
                 ; 0007 00CA        else if( gCurState == 1 )
                 ; 0007 00CB        {
                 ; 0007 00CC           gDutyOff++;
                 ; 0007 00CD           if( gDutyOff >47 )gCurState = 2;
                 ; 0007 00CE 
                 ; 0007 00CF        }
                 ; 0007 00D0        else if( gCurState == 2 )
                 ; 0007 00D1        {
                 ; 0007 00D2           gDutyOff = 0;
                 ; 0007 00D3           PORTC = gCalValue1;
                 ; 0007 00D4           gCurState = 3;
                 ; 0007 00D5        }
                 ; 0007 00D6        else if( gCurState == 3 )
                 ; 0007 00D7        {
                 ; 0007 00D8            PORTC = gCalValue0;
                 ; 0007 00D9            gDutyOff++;
                 ; 0007 00DA            if( gDutyOff >47 )gCurState = 4;
                 ; 0007 00DB        }
                 ; 0007 00DC        else if( gCurState == 4 )
                 ; 0007 00DD        {
                 ; 0007 00DE           gDutyOff = 0;
                 ; 0007 00DF           PORTC = gCalValue1;
                 ; 0007 00E0           gCurState = 5;
                 ; 0007 00E1        }
                 ; 0007 00E2        else if( gCurState == 5 )
                 ; 0007 00E3        {
                 ; 0007 00E4           PORTC = gCalValue0;
                 ; 0007 00E5           gDutyOff++;
                 ; 0007 00E6           if( gDutyOff >47 ) gCurState = 6;
                 ; 0007 00E7        }
                 ; 0007 00E8        else if( gCurState == 6 )
                 ; 0007 00E9        {
                 ; 0007 00EA           gDutyOff = 0;
                 ; 0007 00EB           PORTC = gCalValue1;
                 ; 0007 00EC           gCurState = 7;
                 ; 0007 00ED        }
                 ; 0007 00EE        else if( gCurState == 7 )
                 ; 0007 00EF        {
                 ; 0007 00F0           gDutyOff++;
                 ; 0007 00F1           if( gDutyOff >246)
                 ; 0007 00F2           {
                 ; 0007 00F3              gCurState = 0;
                 ; 0007 00F4              gElLoc++;
                 ; 0007 00F5              if( gElLoc > 3 )
                 ; 0007 00F6              {
                 ; 0007 00F7                 PORTC = 0;
                 ; 0007 00F8                 gElLoc = 0;
                 ; 0007 00F9                 gElCompletFlag = TRUE;
                 ; 0007 00FA              }
                 ; 0007 00FB           }
                 ; 0007 00FC        }
                 ; 0007 00FD    }
                 ; 0007 00FE }
                 ;
                 ;void PulseGenerator4( void )
                 ; 0007 0101 {
                 ; 0007 0102      // Reinitialize Timer1 value
                 ; 0007 0103     TCNT1H=0xE013 >> 8;          //     0.4ms
                 ; 0007 0104     TCNT1L=0xE013 & 0xff;
                 ; 0007 0105 
                 ; 0007 0106     // Place your code here
                 ; 0007 0107     if( gRunFlag==TRUE && gElCompletFlag == FALSE )
                 ; 0007 0108     {
                 ; 0007 0109        if( gCurState == 0 )
                 ; 0007 010A        {
                 ; 0007 010B           gCalValue0 = gElMatrix[gElLoc]<<4 |(~gElMatrix[gElLoc])&0x0f; //((~gElMatrix[gElLoc]<<4)&0xf0)| gElMatrix[gElL ...
                 ; 0007 010C           gCalValue1 = gCalValue0&0x0f; // (~gElMatrix[gElLoc])&0x0f;
                 ; 0007 010D 
                 ; 0007 010E           PORTC = gCalValue0;
                 ; 0007 010F           gDutyOff = 0;
                 ; 0007 0110           gCurState = 1;
                 ; 0007 0111        }
                 ; 0007 0112        else if( gCurState == 1 )
                 ; 0007 0113        {
                 ; 0007 0114           gDutyOff++;
                 ; 0007 0115           if( gDutyOff >11 )gCurState = 2;
                 ; 0007 0116        }
                 ; 0007 0117        else if( gCurState == 2 )
                 ; 0007 0118        {
                 ; 0007 0119           gDutyOff = 0;
                 ; 0007 011A           PORTC = gCalValue1;
                 ; 0007 011B           gCurState = 3;
                 ; 0007 011C        }
                 ; 0007 011D        else if( gCurState == 3 )
                 ; 0007 011E        {
                 ; 0007 011F           PORTC = gCalValue0;
                 ; 0007 0120           gDutyOff++;
                 ; 0007 0121           if( gDutyOff >11) gCurState = 4;
                 ; 0007 0122        }
                 ; 0007 0123        else if( gCurState == 4 )
                 ; 0007 0124        {
                 ; 0007 0125           gDutyOff = 0;
                 ; 0007 0126           PORTC = gCalValue1;
                 ; 0007 0127           gCurState = 5;
                 ; 0007 0128        }
                 ; 0007 0129        else if( gCurState == 5 )
                 ; 0007 012A        {
                 ; 0007 012B           PORTC = gCalValue0;
                 ; 0007 012C           gDutyOff++;
                 ; 0007 012D           if( gDutyOff >11) gCurState = 6;
                 ; 0007 012E        }
                 ; 0007 012F        else if( gCurState == 6 )
                 ; 0007 0130        {
                 ; 0007 0131           gDutyOff = 0;
                 ; 0007 0132           PORTC = gCalValue1;
                 ; 0007 0133           gCurState = 7;
                 ; 0007 0134        }
                 ; 0007 0135        else if( gCurState == 7 )
                 ; 0007 0136        {
                 ; 0007 0137           PORTC = gCalValue0;
                 ; 0007 0138           gDutyOff++;
                 ; 0007 0139           if( gDutyOff >11) gCurState = 8;
                 ; 0007 013A        }
                 ; 0007 013B        else if( gCurState == 8 )
                 ; 0007 013C        {
                 ; 0007 013D           gDutyOff = 0;
                 ; 0007 013E           PORTC = gCalValue1;
                 ; 0007 013F           gCurState = 9;
                 ; 0007 0140        }
                 ; 0007 0141        else if( gCurState == 9 )
                 ; 0007 0142        {
                 ; 0007 0143           PORTC = gCalValue0;
                 ; 0007 0144           gDutyOff++;
                 ; 0007 0145           if( gDutyOff >11) gCurState = 10;
                 ; 0007 0146        }
                 ; 0007 0147        else if( gCurState == 10 )
                 ; 0007 0148        {
                 ; 0007 0149           gDutyOff = 0;
                 ; 0007 014A           PORTC = gCalValue1;
                 ; 0007 014B           gCurState = 11;
                 ; 0007 014C        }
                 ; 0007 014D        else if( gCurState == 11 )
                 ; 0007 014E        {
                 ; 0007 014F           gDutyOff++;
                 ; 0007 0150           if( gDutyOff >294)     //150ms
                 ; 0007 0151           {
                 ; 0007 0152              gCurState = 0;
                 ; 0007 0153              gElLoc++;
                 ; 0007 0154              if( gElLoc > 3 )
                 ; 0007 0155              {
                 ; 0007 0156                 PORTC = 0x00;
                 ; 0007 0157                 gElLoc = 0;
                 ; 0007 0158                 gElCompletFlag = TRUE;
                 ; 0007 0159              }
                 ; 0007 015A           }
                 ; 0007 015B        }
                 ; 0007 015C    }
                 ; 0007 015D }
                 ;
                 ;void PulseGenerator5( void )
                 ; 0007 0160 {
                 _PulseGenerator5:
                 ; .FSTART _PulseGenerator5
                 ; 0007 0161     int i=0;
                 ; 0007 0162     // Reinitialize Timer1 value
                 ; 0007 0163 
                 ; 0007 0164     #if 0
                 ; 0007 0165     TCNT1H=0xB1E0 >> 8;           //10ms
                 ; 0007 0166     TCNT1L=0xB1E0 & 0xff;
                 ; 0007 0167     #else
                 ; 0007 0168     TCNT1H=0xC1;
000625 940e 0b40 	CALL SUBOPT_0x0
                 ;	i -> R16,R17
000627 ece1      	LDI  R30,LOW(193)
000628 bded      	OUT  0x2D,R30
                 ; 0007 0169     TCNT1L=0x80;
000629 e8e0      	LDI  R30,LOW(128)
00062a bdec      	OUT  0x2C,R30
                 ; 0007 016A     #endif
                 ; 0007 016B 
                 ; 0007 016C     // Place your code here
                 ; 0007 016D     if( gRunFlag==TRUE && gElCompletFlag == FALSE )
00062b 91a0 050b 	LDS  R26,_gRunFlag
00062d 30a1      	CPI  R26,LOW(0x1)
00062e f421      	BRNE _0xE0060
00062f 91a0 0518 	LDS  R26,_gElCompletFlag
000631 30a0      	CPI  R26,LOW(0x0)
000632 f009      	BREQ _0xE0061
                 _0xE0060:
000633 c08b      	RJMP _0xE005F
                 _0xE0061:
                 ; 0007 016E     {
                 ; 0007 016F        if( gCurState == 0 )
000634 91e0 0777 	LDS  R30,_gCurState
000636 91f0 0778 	LDS  R31,_gCurState+1
000638 9730      	SBIW R30,0
000639 f589      	BRNE _0xE0062
                 ; 0007 0170        {
                 ; 0007 0171          // gCalValue0 = gElMatrix[gElLoc]<<4 |(~gElMatrix[gElLoc])&0x0f; //((~gElMatrix[gElLoc]<<4)&0xf0)| gElMatrix[gE ...
                 ; 0007 0172          // gCalValue1 = gCalValue0&0x0f; // (~gElMatrix[gElLoc])&0x0f;
                 ; 0007 0173           gCalValue0 = gElMatrix[gElLoc]<<4;
00063a 940e 0d0f 	CALL SUBOPT_0x36
00063c 81e0      	LD   R30,Z
00063d 95e2      	SWAP R30
00063e 7fe0      	ANDI R30,0xF0
00063f e0f0      	LDI  R31,0
000640 93e0 0779 	STS  _gCalValue0,R30
000642 93f0 077a 	STS  _gCalValue0+1,R31
                 ; 0007 0174           gCalValue1 = 0;
000644 e0e0      	LDI  R30,LOW(0)
000645 93e0 077b 	STS  _gCalValue1,R30
000647 93e0 077c 	STS  _gCalValue1+1,R30
                 ; 0007 0175 
                 ; 0007 0176           for( i=0; i< 4; i++)
                +
000649 e000     +LDI R16 , LOW ( 0 )
00064a e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0xE0064:
                +
00064b 3004     +CPI R16 , LOW ( 4 )
00064c e0e0     +LDI R30 , HIGH ( 4 )
00064d 071e     +CPC R17 , R30
                 	__CPWRN 16,17,4
00064e f464      	BRGE _0xE0065
                 ; 0007 0177           {
                 ; 0007 0178              if( gElMatrix[gElLoc]&(0x08>>i))
00064f 940e 0d0f 	CALL SUBOPT_0x36
000651 8010      	LD   R1,Z
000652 2fe0      	MOV  R30,R16
000653 e0a8      	LDI  R26,LOW(8)
000654 940e 0fa1 	CALL __LSRB12
000656 21e1      	AND  R30,R1
000657 f419      	BRNE _0xE0065
                 ; 0007 0179               break;
                 ; 0007 017A           }
                +
000658 5f0f     +SUBI R16 , LOW ( - 1 )
000659 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00065a cff0      	RJMP _0xE0064
                 _0xE0065:
                 ; 0007 017B           gShift = i;
                +
00065b 9300 077f+STS _gShift + ( 0 ) , R16
00065d 9310 0780+STS _gShift + ( 0 ) + 1 , R17
                 	__PUTWMRN _gShift,0,16,17
                 ; 0007 017C 
                 ; 0007 017D           gShift++;
00065f 940e 0d16 	CALL SUBOPT_0x37
                 ; 0007 017E           if( gShift > 3 ) gShift = 0;
000661 940e 0d19 	CALL SUBOPT_0x38
000663 f014      	BRLT _0xE0067
000664 940e 0d1f 	CALL SUBOPT_0x39
                 ; 0007 017F 
                 ; 0007 0180           PORTC = gCalValue0|(0x08>>gShift);
                 _0xE0067:
000666 940e 0d25 	CALL SUBOPT_0x3A
                 ; 0007 0181           gCurState = 1;
000668 940e 0d2f 	CALL SUBOPT_0x3B
                 ; 0007 0182        }
                 ; 0007 0183        else if( gCurState == 1 )
00066a c054      	RJMP _0xE0068
                 _0xE0062:
00066b 940e 0d36 	CALL SUBOPT_0x3C
00066d 9711      	SBIW R26,1
00066e f431      	BRNE _0xE0069
                 ; 0007 0184        {
                 ; 0007 0185           PORTC = gCalValue1;
00066f 91e0 077b 	LDS  R30,_gCalValue1
000671 bbe5      	OUT  0x15,R30
                 ; 0007 0186           gCurState = 2;
000672 940e 0d3b 	CALL SUBOPT_0x3D
                 ; 0007 0187        }
                 ; 0007 0188        else if( gCurState == 2 )
000674 c04a      	RJMP _0xE006A
                 _0xE0069:
000675 940e 0d36 	CALL SUBOPT_0x3C
000677 9712      	SBIW R26,2
000678 f461      	BRNE _0xE006B
                 ; 0007 0189        {
                 ; 0007 018A           gShift++;
000679 940e 0d16 	CALL SUBOPT_0x37
                 ; 0007 018B           if( gShift > 3 ) gShift = 0;
00067b 940e 0d19 	CALL SUBOPT_0x38
00067d f014      	BRLT _0xE006C
00067e 940e 0d1f 	CALL SUBOPT_0x39
                 ; 0007 018C           PORTC = gCalValue0|(0x08>>gShift);
                 _0xE006C:
000680 940e 0d25 	CALL SUBOPT_0x3A
                 ; 0007 018D           gCurState = 3;
000682 940e 0d42 	CALL SUBOPT_0x3E
                 ; 0007 018E        }
                 ; 0007 018F        else if( gCurState == 3 )
000684 c03a      	RJMP _0xE006D
                 _0xE006B:
000685 940e 0d36 	CALL SUBOPT_0x3C
000687 9713      	SBIW R26,3
000688 f431      	BRNE _0xE006E
                 ; 0007 0190        {
                 ; 0007 0191           PORTC = gCalValue1;
000689 91e0 077b 	LDS  R30,_gCalValue1
00068b bbe5      	OUT  0x15,R30
                 ; 0007 0192           gCurState = 4;
00068c 940e 0d49 	CALL SUBOPT_0x3F
                 ; 0007 0193        }
                 ; 0007 0194        else if( gCurState == 4 )
00068e c030      	RJMP _0xE006F
                 _0xE006E:
00068f 940e 0d36 	CALL SUBOPT_0x3C
000691 9714      	SBIW R26,4
000692 f461      	BRNE _0xE0070
                 ; 0007 0195        {
                 ; 0007 0196           gShift++;
000693 940e 0d16 	CALL SUBOPT_0x37
                 ; 0007 0197           if( gShift > 3 ) gShift = 0;
000695 940e 0d19 	CALL SUBOPT_0x38
000697 f014      	BRLT _0xE0071
000698 940e 0d1f 	CALL SUBOPT_0x39
                 ; 0007 0198           PORTC = gCalValue0|(0x08>>gShift);
                 _0xE0071:
00069a 940e 0d25 	CALL SUBOPT_0x3A
                 ; 0007 0199           gCurState = 5;
00069c 940e 0d50 	CALL SUBOPT_0x40
                 ; 0007 019A        }
                 ; 0007 019B        else if( gCurState == 5 )
00069e c020      	RJMP _0xE0072
                 _0xE0070:
00069f 940e 0d36 	CALL SUBOPT_0x3C
0006a1 9715      	SBIW R26,5
0006a2 f441      	BRNE _0xE0073
                 ; 0007 019C        {
                 ; 0007 019D           gDutyOff = 0;
0006a3 940e 0d57 	CALL SUBOPT_0x41
                 ; 0007 019E           PORTC = gCalValue1;
0006a5 91e0 077b 	LDS  R30,_gCalValue1
0006a7 bbe5      	OUT  0x15,R30
                 ; 0007 019F           gCurState = 6;
0006a8 940e 0d5d 	CALL SUBOPT_0x42
                 ; 0007 01A0        }
                 ; 0007 01A1        else if( gCurState == 6 )
0006aa c014      	RJMP _0xE0074
                 _0xE0073:
0006ab 940e 0d36 	CALL SUBOPT_0x3C
0006ad 9716      	SBIW R26,6
0006ae f481      	BRNE _0xE0075
                 ; 0007 01A2        {
                 ; 0007 01A3           gDutyOff++;
0006af 940e 0d64 	CALL SUBOPT_0x43
                 ; 0007 01A4           if( gDutyOff >8)
0006b1 940e 0d67 	CALL SUBOPT_0x44
0006b3 9719      	SBIW R26,9
0006b4 f054      	BRLT _0xE0076
                 ; 0007 01A5           {
                 ; 0007 01A6              gCurState = 0;
0006b5 940e 0d6c 	CALL SUBOPT_0x45
                 ; 0007 01A7              gElLoc++;
                 ; 0007 01A8              if( gElLoc > 3 )
0006b7 91a0 0775 	LDS  R26,_gElLoc
0006b9 91b0 0776 	LDS  R27,_gElLoc+1
0006bb 9714      	SBIW R26,4
0006bc f014      	BRLT _0xE0077
                 ; 0007 01A9              {
                 ; 0007 01AA                 PORTC = 0;
0006bd 940e 0d74 	CALL SUBOPT_0x46
                 ; 0007 01AB                 gElLoc = 0;
                 ; 0007 01AC                 gElCompletFlag = TRUE;
                 ; 0007 01AD              }
                 ; 0007 01AE           }
                 _0xE0077:
                 ; 0007 01AF        }
                 _0xE0076:
                 ; 0007 01B0    }
                 _0xE0075:
                 _0xE0074:
                 _0xE0072:
                 _0xE006F:
                 _0xE006D:
                 _0xE006A:
                 _0xE0068:
                 ; 0007 01B1 }
                 _0xE005F:
0006bf 9109      	LD   R16,Y+
0006c0 9119      	LD   R17,Y+
0006c1 9508      	RET
                 ; .FEND
                 ;
                 ;void PulseGenerator6( void )
                 ; 0007 01B4 {
                 _PulseGenerator6:
                 ; .FSTART _PulseGenerator6
                 ; 0007 01B5      // Reinitialize Timer1 value
                 ; 0007 01B6     TCNT1H=0xE600 >> 8;          //     0.4ms
0006c2 eee6      	LDI  R30,LOW(230)
0006c3 bded      	OUT  0x2D,R30
                 ; 0007 01B7     TCNT1L=0xE600 & 0xff;
0006c4 e0e0      	LDI  R30,LOW(0)
0006c5 bdec      	OUT  0x2C,R30
                 ; 0007 01B8 
                 ; 0007 01B9     // Place your code here
                 ; 0007 01BA     if( gRunFlag==TRUE && gElCompletFlag == FALSE )
0006c6 91a0 050b 	LDS  R26,_gRunFlag
0006c8 30a1      	CPI  R26,LOW(0x1)
0006c9 f421      	BRNE _0xE0079
0006ca 91a0 0518 	LDS  R26,_gElCompletFlag
0006cc 30a0      	CPI  R26,LOW(0x0)
0006cd f009      	BREQ _0xE007A
                 _0xE0079:
0006ce c0c1      	RJMP _0xE0078
                 _0xE007A:
                 ; 0007 01BB     {
                 ; 0007 01BC        if( gCurState == 0 )
0006cf 91e0 0777 	LDS  R30,_gCurState
0006d1 91f0 0778 	LDS  R31,_gCurState+1
0006d3 9730      	SBIW R30,0
0006d4 f4f1      	BRNE _0xE007B
                 ; 0007 01BD        {
                 ; 0007 01BE           gCalValue0 = gElMatrix[gElLoc]<<4 |(~gElMatrix[gElLoc])&0x0f; //((~gElMatrix[gElLoc]<<4)&0xf0)| gElMatrix[gElL ...
0006d5 940e 0d0f 	CALL SUBOPT_0x36
0006d7 81e0      	LD   R30,Z
0006d8 2e0e      	MOV  R0,R30
0006d9 95e2      	SWAP R30
0006da 7fe0      	ANDI R30,0xF0
0006db 2fae      	MOV  R26,R30
0006dc 2de0      	MOV  R30,R0
0006dd 95e0      	COM  R30
0006de 70ef      	ANDI R30,LOW(0xF)
0006df 2bea      	OR   R30,R26
0006e0 e0f0      	LDI  R31,0
0006e1 93e0 0779 	STS  _gCalValue0,R30
0006e3 93f0 077a 	STS  _gCalValue0+1,R31
                 ; 0007 01BF           gCalValue1 = gCalValue0&0x0f; // (~gElMatrix[gElLoc])&0x0f;
0006e5 70ef      	ANDI R30,LOW(0xF)
0006e6 70f0      	ANDI R31,HIGH(0xF)
0006e7 93e0 077b 	STS  _gCalValue1,R30
0006e9 93f0 077c 	STS  _gCalValue1+1,R31
                 ; 0007 01C0 
                 ; 0007 01C1           PORTC = gCalValue0;
0006eb 91e0 0779 	LDS  R30,_gCalValue0
0006ed bbe5      	OUT  0x15,R30
                 ; 0007 01C2           gDutyOff = 0;
0006ee 940e 0d57 	CALL SUBOPT_0x41
                 ; 0007 01C3           gCurState = 1;
0006f0 940e 0d2f 	CALL SUBOPT_0x3B
                 ; 0007 01C4        }
                 ; 0007 01C5        else if( gCurState == 1 )
0006f2 c09d      	RJMP _0xE007C
                 _0xE007B:
0006f3 940e 0d36 	CALL SUBOPT_0x3C
0006f5 9711      	SBIW R26,1
0006f6 f449      	BRNE _0xE007D
                 ; 0007 01C6        {
                 ; 0007 01C7           gDutyOff++;
0006f7 940e 0d64 	CALL SUBOPT_0x43
                 ; 0007 01C8           if( gDutyOff >14 )gCurState = 2;
0006f9 940e 0d67 	CALL SUBOPT_0x44
0006fb 971f      	SBIW R26,15
0006fc f014      	BRLT _0xE007E
0006fd 940e 0d3b 	CALL SUBOPT_0x3D
                 ; 0007 01C9        }
                 _0xE007E:
                 ; 0007 01CA        else if( gCurState == 2 )
0006ff c090      	RJMP _0xE007F
                 _0xE007D:
000700 940e 0d36 	CALL SUBOPT_0x3C
000702 9712      	SBIW R26,2
000703 f441      	BRNE _0xE0080
                 ; 0007 01CB        {
                 ; 0007 01CC           gDutyOff = 0;
000704 940e 0d57 	CALL SUBOPT_0x41
                 ; 0007 01CD           PORTC = gCalValue1;
000706 91e0 077b 	LDS  R30,_gCalValue1
000708 bbe5      	OUT  0x15,R30
                 ; 0007 01CE           gCurState = 3;
000709 940e 0d42 	CALL SUBOPT_0x3E
                 ; 0007 01CF        }
                 ; 0007 01D0        else if( gCurState == 3 )
00070b c084      	RJMP _0xE0081
                 _0xE0080:
00070c 940e 0d36 	CALL SUBOPT_0x3C
00070e 9713      	SBIW R26,3
00070f f449      	BRNE _0xE0082
                 ; 0007 01D1        {
                 ; 0007 01D2           PORTC = gCalValue0;
000710 940e 0d7e 	CALL SUBOPT_0x47
                 ; 0007 01D3           gDutyOff++;
                 ; 0007 01D4           if( gDutyOff >15) gCurState = 4;
000712 940e 0d67 	CALL SUBOPT_0x44
000714 9750      	SBIW R26,16
000715 f014      	BRLT _0xE0083
000716 940e 0d49 	CALL SUBOPT_0x3F
                 ; 0007 01D5        }
                 _0xE0083:
                 ; 0007 01D6        else if( gCurState == 4 )
000718 c077      	RJMP _0xE0084
                 _0xE0082:
000719 940e 0d36 	CALL SUBOPT_0x3C
00071b 9714      	SBIW R26,4
00071c f441      	BRNE _0xE0085
                 ; 0007 01D7        {
                 ; 0007 01D8           gDutyOff = 0;
00071d 940e 0d57 	CALL SUBOPT_0x41
                 ; 0007 01D9           PORTC = gCalValue1;
00071f 91e0 077b 	LDS  R30,_gCalValue1
000721 bbe5      	OUT  0x15,R30
                 ; 0007 01DA           gCurState = 5;
000722 940e 0d50 	CALL SUBOPT_0x40
                 ; 0007 01DB        }
                 ; 0007 01DC        else if( gCurState == 5 )
000724 c06b      	RJMP _0xE0086
                 _0xE0085:
000725 940e 0d36 	CALL SUBOPT_0x3C
000727 9715      	SBIW R26,5
000728 f449      	BRNE _0xE0087
                 ; 0007 01DD        {
                 ; 0007 01DE           PORTC = gCalValue0;
000729 940e 0d7e 	CALL SUBOPT_0x47
                 ; 0007 01DF           gDutyOff++;
                 ; 0007 01E0           if( gDutyOff >15) gCurState = 6;
00072b 940e 0d67 	CALL SUBOPT_0x44
00072d 9750      	SBIW R26,16
00072e f014      	BRLT _0xE0088
00072f 940e 0d5d 	CALL SUBOPT_0x42
                 ; 0007 01E1        }
                 _0xE0088:
                 ; 0007 01E2        else if( gCurState == 6 )
000731 c05e      	RJMP _0xE0089
                 _0xE0087:
000732 940e 0d36 	CALL SUBOPT_0x3C
000734 9716      	SBIW R26,6
000735 f451      	BRNE _0xE008A
                 ; 0007 01E3        {
                 ; 0007 01E4           gDutyOff = 0;
000736 940e 0d57 	CALL SUBOPT_0x41
                 ; 0007 01E5           PORTC = gCalValue1;
000738 91e0 077b 	LDS  R30,_gCalValue1
00073a bbe5      	OUT  0x15,R30
                 ; 0007 01E6           gCurState = 7;
00073b e0e7      	LDI  R30,LOW(7)
00073c e0f0      	LDI  R31,HIGH(7)
00073d 940e 0d82 	CALL SUBOPT_0x48
                 ; 0007 01E7        }
                 ; 0007 01E8        else if( gCurState == 7 )
00073f c050      	RJMP _0xE008B
                 _0xE008A:
000740 940e 0d36 	CALL SUBOPT_0x3C
000742 9717      	SBIW R26,7
000743 f459      	BRNE _0xE008C
                 ; 0007 01E9        {
                 ; 0007 01EA           PORTC = gCalValue0;
000744 940e 0d7e 	CALL SUBOPT_0x47
                 ; 0007 01EB           gDutyOff++;
                 ; 0007 01EC           if( gDutyOff >15) gCurState = 8;
000746 940e 0d67 	CALL SUBOPT_0x44
000748 9750      	SBIW R26,16
000749 f024      	BRLT _0xE008D
00074a e0e8      	LDI  R30,LOW(8)
00074b e0f0      	LDI  R31,HIGH(8)
00074c 940e 0d82 	CALL SUBOPT_0x48
                 ; 0007 01ED        }
                 _0xE008D:
                 ; 0007 01EE        else if( gCurState == 8 )
00074e c041      	RJMP _0xE008E
                 _0xE008C:
00074f 940e 0d36 	CALL SUBOPT_0x3C
000751 9718      	SBIW R26,8
000752 f451      	BRNE _0xE008F
                 ; 0007 01EF        {
                 ; 0007 01F0           gDutyOff = 0;
000753 940e 0d57 	CALL SUBOPT_0x41
                 ; 0007 01F1           PORTC = gCalValue1;
000755 91e0 077b 	LDS  R30,_gCalValue1
000757 bbe5      	OUT  0x15,R30
                 ; 0007 01F2           gCurState = 9;
000758 e0e9      	LDI  R30,LOW(9)
000759 e0f0      	LDI  R31,HIGH(9)
00075a 940e 0d82 	CALL SUBOPT_0x48
                 ; 0007 01F3        }
                 ; 0007 01F4        else if( gCurState == 9 )
00075c c033      	RJMP _0xE0090
                 _0xE008F:
00075d 940e 0d36 	CALL SUBOPT_0x3C
00075f 9719      	SBIW R26,9
000760 f459      	BRNE _0xE0091
                 ; 0007 01F5        {
                 ; 0007 01F6           PORTC = gCalValue0;
000761 940e 0d7e 	CALL SUBOPT_0x47
                 ; 0007 01F7           gDutyOff++;
                 ; 0007 01F8           if( gDutyOff >15) gCurState = 10;
000763 940e 0d67 	CALL SUBOPT_0x44
000765 9750      	SBIW R26,16
000766 f024      	BRLT _0xE0092
000767 e0ea      	LDI  R30,LOW(10)
000768 e0f0      	LDI  R31,HIGH(10)
000769 940e 0d82 	CALL SUBOPT_0x48
                 ; 0007 01F9        }
                 _0xE0092:
                 ; 0007 01FA        else if( gCurState == 10 )
00076b c024      	RJMP _0xE0093
                 _0xE0091:
00076c 940e 0d36 	CALL SUBOPT_0x3C
00076e 971a      	SBIW R26,10
00076f f451      	BRNE _0xE0094
                 ; 0007 01FB        {
                 ; 0007 01FC           gDutyOff = 0;
000770 940e 0d57 	CALL SUBOPT_0x41
                 ; 0007 01FD           PORTC = gCalValue1;
000772 91e0 077b 	LDS  R30,_gCalValue1
000774 bbe5      	OUT  0x15,R30
                 ; 0007 01FE           gCurState = 11;
000775 e0eb      	LDI  R30,LOW(11)
000776 e0f0      	LDI  R31,HIGH(11)
000777 940e 0d82 	CALL SUBOPT_0x48
                 ; 0007 01FF        }
                 ; 0007 0200        else if( gCurState == 11 )
000779 c016      	RJMP _0xE0095
                 _0xE0094:
00077a 940e 0d36 	CALL SUBOPT_0x3C
00077c 971b      	SBIW R26,11
00077d f491      	BRNE _0xE0096
                 ; 0007 0201        {
                 ; 0007 0202           gDutyOff++;
00077e 940e 0d64 	CALL SUBOPT_0x43
                 ; 0007 0203           if( gDutyOff > 363)     //150ms
000780 940e 0d67 	CALL SUBOPT_0x44
000782 36ac      	CPI  R26,LOW(0x16C)
000783 e0e1      	LDI  R30,HIGH(0x16C)
000784 07be      	CPC  R27,R30
000785 f054      	BRLT _0xE0097
                 ; 0007 0204           {
                 ; 0007 0205              gCurState = 0;
000786 940e 0d6c 	CALL SUBOPT_0x45
                 ; 0007 0206              gElLoc++;
                 ; 0007 0207              if( gElLoc > 3 )
000788 91a0 0775 	LDS  R26,_gElLoc
00078a 91b0 0776 	LDS  R27,_gElLoc+1
00078c 9714      	SBIW R26,4
00078d f014      	BRLT _0xE0098
                 ; 0007 0208              {
                 ; 0007 0209                 PORTC = 0x00;
00078e 940e 0d74 	CALL SUBOPT_0x46
                 ; 0007 020A                 gElLoc = 0;
                 ; 0007 020B                 gElCompletFlag = TRUE;
                 ; 0007 020C              }
                 ; 0007 020D           }
                 _0xE0098:
                 ; 0007 020E        }
                 _0xE0097:
                 ; 0007 020F    }
                 _0xE0096:
                 _0xE0095:
                 _0xE0093:
                 _0xE0090:
                 _0xE008E:
                 _0xE008B:
                 _0xE0089:
                 _0xE0086:
                 _0xE0084:
                 _0xE0081:
                 _0xE007F:
                 _0xE007C:
                 ; 0007 0210 }
                 _0xE0078:
000790 9508      	RET
                 ; .FEND
                 ;
                 ;interrupt [TIM1_OVF] void timer1_ovf_isr(void)
                 ; 0007 0213 {
                 _timer1_ovf_isr:
                 ; .FSTART _timer1_ovf_isr
000791 920a      	ST   -Y,R0
000792 921a      	ST   -Y,R1
000793 92fa      	ST   -Y,R15
000794 936a      	ST   -Y,R22
000795 937a      	ST   -Y,R23
000796 938a      	ST   -Y,R24
000797 939a      	ST   -Y,R25
000798 93aa      	ST   -Y,R26
000799 93ba      	ST   -Y,R27
00079a 93ea      	ST   -Y,R30
00079b 93fa      	ST   -Y,R31
00079c b7ef      	IN   R30,SREG
00079d 93ea      	ST   -Y,R30
                 ; 0007 0214      if( gGenMode==FALSE )
00079e 91e0 0783 	LDS  R30,_gGenMode
0007a0 30e0      	CPI  R30,0
0007a1 f411      	BRNE _0xE0099
                 ; 0007 0215           PulseGenerator5();
0007a2 de82      	RCALL _PulseGenerator5
                 ; 0007 0216      else PulseGenerator6();
0007a3 c001      	RJMP _0xE009A
                 _0xE0099:
0007a4 df1d      	RCALL _PulseGenerator6
                 ; 0007 0217 }
                 _0xE009A:
0007a5 91e9      	LD   R30,Y+
0007a6 bfef      	OUT  SREG,R30
0007a7 91f9      	LD   R31,Y+
0007a8 91e9      	LD   R30,Y+
0007a9 91b9      	LD   R27,Y+
0007aa 91a9      	LD   R26,Y+
0007ab 9199      	LD   R25,Y+
0007ac 9189      	LD   R24,Y+
0007ad 9179      	LD   R23,Y+
0007ae 9169      	LD   R22,Y+
0007af 90f9      	LD   R15,Y+
0007b0 9019      	LD   R1,Y+
0007b1 9009      	LD   R0,Y+
0007b2 9518      	RETI
                 ; .FEND
                 ;
                 ;void PortInit( void )
                 ; 0007 021A {
                 _PortInit:
                 ; .FSTART _PortInit
                 ; 0007 021B     // PORTA
                 ; 0007 021C     // bit 7 : N.C
                 ; 0007 021D     // bit 6 : N.C
                 ; 0007 021E     // bit 5 : EPG 2 out(LED)
                 ; 0007 021F     // bit 4 : EPG 1 out(LED)
                 ; 0007 0220     // bit 3 : DAC7611 LD  out
                 ; 0007 0221     // bit 2 : DAC7611 CS  out
                 ; 0007 0222     // bit 1 : DAC7611 CLK out
                 ; 0007 0223     // bit 0 : DAC7611 SDI out
                 ; 0007 0224     DDRA    = 0x3f;
0007b3 e3ef      	LDI  R30,LOW(63)
0007b4 bbea      	OUT  0x1A,R30
                 ; 0007 0225     PORTA   = 0x04;
0007b5 e0e4      	LDI  R30,LOW(4)
0007b6 bbeb      	OUT  0x1B,R30
                 ; 0007 0226 
                 ; 0007 0227     //PORTB
                 ; 0007 0228     // bit 7 : N.C
                 ; 0007 0229     // bit 6 : LF398 Sample Hold out
                 ; 0007 022A     // bit 5 : N.C
                 ; 0007 022B     // bit 4 : N.C
                 ; 0007 022C     // bit 3 : N.C
                 ; 0007 022D     // bit 2 : N.C
                 ; 0007 022E     // bit 1 : N.C
                 ; 0007 022F     // bit 0 : N.C
                 ; 0007 0230     DDRB    = 0x40;
0007b7 e4e0      	LDI  R30,LOW(64)
0007b8 bbe7      	OUT  0x17,R30
                 ; 0007 0231     PORTB   = 0x01;
0007b9 e0e1      	LDI  R30,LOW(1)
0007ba bbe8      	OUT  0x18,R30
                 ; 0007 0232 
                 ; 0007 0233     //PORTC
                 ; 0007 0234     //bit 7: ELECT7
                 ; 0007 0235     //bit 6: ELECT6
                 ; 0007 0236     //bit 5: ELECT5
                 ; 0007 0237     //bit 4: ELECT4
                 ; 0007 0238     //bit 3: ELECT3
                 ; 0007 0239     //bit 2: ELECT2
                 ; 0007 023A     //bit 1: ELECT1
                 ; 0007 023B     //bit 0: ELECT0
                 ; 0007 023C     DDRC    = 0xff;
0007bb efef      	LDI  R30,LOW(255)
0007bc bbe4      	OUT  0x14,R30
                 ; 0007 023D     PORTC   = 0x00;
0007bd e0e0      	LDI  R30,LOW(0)
0007be bbe5      	OUT  0x15,R30
                 ; 0007 023E 
                 ; 0007 023F     //PORTD
                 ; 0007 0240     //bit 7: (OUT) Voltage Read Select
                 ; 0007 0241     //bit 6: NC
                 ; 0007 0242     //bit 5: NC
                 ; 0007 0243     //bit 4: (IN)FET destruction sen
                 ; 0007 0244     //bit 3: TXD1
                 ; 0007 0245     //bit 2: RXD1
                 ; 0007 0246     //bit 1: NC
                 ; 0007 0247     //bit 0: NC
                 ; 0007 0248     DDRD    = 0x80;
0007bf e8e0      	LDI  R30,LOW(128)
0007c0 bbe1      	OUT  0x11,R30
                 ; 0007 0249     PORTD   = 0x00;
0007c1 e0e0      	LDI  R30,LOW(0)
0007c2 bbe2      	OUT  0x12,R30
                 ; 0007 024A 
                 ; 0007 024B     DDRE    = 0x12;
0007c3 e1e2      	LDI  R30,LOW(18)
0007c4 b9e2      	OUT  0x2,R30
                 ; 0007 024C     //PORTE   = 0x54;
                 ; 0007 024D 
                 ; 0007 024E     DDRF    = 0xC0;
0007c5 ece0      	LDI  R30,LOW(192)
0007c6 93e0 0061 	STS  97,R30
                 ; 0007 024F     PORTF   = 0x00;
0007c8 e0e0      	LDI  R30,LOW(0)
0007c9 93e0 0062 	STS  98,R30
                 ; 0007 0250 
                 ; 0007 0251     DDRG    = 0xff;
0007cb efef      	LDI  R30,LOW(255)
0007cc 93e0 0064 	STS  100,R30
                 ; 0007 0252     PORTG   = 0x00;
0007ce e0e0      	LDI  R30,LOW(0)
0007cf 93e0 0065 	STS  101,R30
                 ; 0007 0253 
                 ; 0007 0254     // Timer/Counter 0 initialization
                 ; 0007 0255     // Clock source: System Clock
                 ; 0007 0256     // Clock value: 250.000 kHz
                 ; 0007 0257     // Mode: Normal top=0xFF
                 ; 0007 0258     // OC0 output: Disconnected
                 ; 0007 0259     // Timer Period: 1 ms
                 ; 0007 025A     ASSR=0;
0007d1 bfe0      	OUT  0x30,R30
                 ; 0007 025B     TCCR0=0x04;
0007d2 e0e4      	LDI  R30,LOW(4)
0007d3 bfe3      	OUT  0x33,R30
                 ; 0007 025C     TCNT0=0x06;
0007d4 e0e6      	LDI  R30,LOW(6)
0007d5 bfe2      	OUT  0x32,R30
                 ; 0007 025D     OCR0=0x00;
0007d6 e0e0      	LDI  R30,LOW(0)
0007d7 bfe1      	OUT  0x31,R30
                 ; 0007 025E 
                 ; 0007 025F    // Timer/Counter 1 initialization
                 ; 0007 0260    // Clock source: System Clock
                 ; 0007 0261    // Clock value: 2000.000 kHz
                 ; 0007 0262    // Mode: Normal top=0xFFFF
                 ; 0007 0263    // OC1A output: Disconnected
                 ; 0007 0264    // OC1B output: Disconnected
                 ; 0007 0265    // OC1C output: Disconnected
                 ; 0007 0266    // Noise Canceler: Off
                 ; 0007 0267    // Input Capture on Falling Edge
                 ; 0007 0268    // Timer Period: 10 ms
                 ; 0007 0269    // Timer1 Overflow Interrupt: On
                 ; 0007 026A    // Input Capture Interrupt: Off
                 ; 0007 026B    // Compare A Match Interrupt: Off
                 ; 0007 026C    // Compare B Match Interrupt: Off
                 ; 0007 026D    // Compare C Match Interrupt: Off
                 ; 0007 026E    /*
                 ; 0007 026F    TCCR1A=0x00;
                 ; 0007 0270    TCCR1B=0x02;
                 ; 0007 0271    TCNT1H=0xB1;
                 ; 0007 0272    TCNT1L=0xE0;
                 ; 0007 0273    ICR1H=0x00;
                 ; 0007 0274    ICR1L=0x00;
                 ; 0007 0275    OCR1AH=0x00;
                 ; 0007 0276    OCR1AL=0x00;
                 ; 0007 0277    OCR1BH=0x00;
                 ; 0007 0278    OCR1BL=0x00;
                 ; 0007 0279    OCR1CH=0x00;
                 ; 0007 027A    */
                 ; 0007 027B 
                 ; 0007 027C // Timer/Counter 1 initialization
                 ; 0007 027D // Clock source: System Clock
                 ; 0007 027E // Clock value: 16000.000 kHz
                 ; 0007 027F // Mode: Normal top=0xFFFF
                 ; 0007 0280 // OC1A output: Disconnected
                 ; 0007 0281 // OC1B output: Disconnected
                 ; 0007 0282 // OC1C output: Disconnected
                 ; 0007 0283 // Noise Canceler: Off
                 ; 0007 0284 // Input Capture on Falling Edge
                 ; 0007 0285 // Timer Period: 0.4 ms
                 ; 0007 0286 // Timer1 Overflow Interrupt: On
                 ; 0007 0287 // Input Capture Interrupt: Off
                 ; 0007 0288 // Compare A Match Interrupt: Off
                 ; 0007 0289 // Compare B Match Interrupt: Off
                 ; 0007 028A // Compare C Match Interrupt: Off
                 ; 0007 028B #if 0
                 ; 0007 028C TCCR1A=0x00;
                 ; 0007 028D TCCR1B= 0x01;
                 ; 0007 028E TCNT1H=0xE7;
                 ; 0007 028F TCNT1L=0x00;
                 ; 0007 0290 #else
                 ; 0007 0291  TCCR1A=0x00;
0007d8 940e 0d87 	CALL SUBOPT_0x49
                 ; 0007 0292  TCCR1B=0x01;
                 ; 0007 0293  TCNT1H=0xC1;
0007da ece1      	LDI  R30,LOW(193)
0007db bded      	OUT  0x2D,R30
                 ; 0007 0294  TCNT1L=0x80;
0007dc e8e0      	LDI  R30,LOW(128)
0007dd bdec      	OUT  0x2C,R30
                 ; 0007 0295 #endif
                 ; 0007 0296 ICR1H=0x00;
0007de e0e0      	LDI  R30,LOW(0)
0007df bde7      	OUT  0x27,R30
                 ; 0007 0297 ICR1L=0x00;
0007e0 bde6      	OUT  0x26,R30
                 ; 0007 0298 OCR1AH=0x00;
0007e1 bdeb      	OUT  0x2B,R30
                 ; 0007 0299 OCR1AL=0x00;
0007e2 bdea      	OUT  0x2A,R30
                 ; 0007 029A OCR1BH=0x00;
0007e3 bde9      	OUT  0x29,R30
                 ; 0007 029B OCR1BL=0x00;
0007e4 bde8      	OUT  0x28,R30
                 ; 0007 029C OCR1CH=0x00;
0007e5 93e0 0079 	STS  121,R30
                 ; 0007 029D OCR1CL=0x00;
0007e7 93e0 0078 	STS  120,R30
                 ; 0007 029E 
                 ; 0007 029F    // Timer(s)/Counter(s) Interrupt(s) initialization
                 ; 0007 02A0    TIMSK=0x05;
0007e9 e0e5      	LDI  R30,LOW(5)
0007ea bfe7      	OUT  0x37,R30
                 ; 0007 02A1    ETIMSK=0x00;
0007eb e0e0      	LDI  R30,LOW(0)
0007ec 93e0 007d 	STS  125,R30
                 ; 0007 02A2 
                 ; 0007 02A3 
                 ; 0007 02A4 // USART0 initialization
                 ; 0007 02A5 // Communication Parameters: 8 Data, 1 Stop, No Parity
                 ; 0007 02A6 // USART0 Receiver: On
                 ; 0007 02A7 // USART0 Transmitter: On
                 ; 0007 02A8 // USART0 Mode: Asynchronous
                 ; 0007 02A9 // USART0 Baud Rate: 38400 (Double Speed Mode)
                 ; 0007 02AA    UCSR0A=0x02;
0007ee e0e2      	LDI  R30,LOW(2)
0007ef b9eb      	OUT  0xB,R30
                 ; 0007 02AB    UCSR0B=0x98;
0007f0 e9e8      	LDI  R30,LOW(152)
0007f1 b9ea      	OUT  0xA,R30
                 ; 0007 02AC    UCSR0C=0x06;
0007f2 e0e6      	LDI  R30,LOW(6)
0007f3 93e0 0095 	STS  149,R30
                 ; 0007 02AD    UBRR0H=0x00;
0007f5 e0e0      	LDI  R30,LOW(0)
0007f6 93e0 0090 	STS  144,R30
                 ; 0007 02AE    UBRR0L=0x33;
0007f8 e3e3      	LDI  R30,LOW(51)
0007f9 b9e9      	OUT  0x9,R30
                 ; 0007 02AF 
                 ; 0007 02B0    // USART1 initialization
                 ; 0007 02B1    // Communication Parameters: 8 Data, 1 Stop, No Parity
                 ; 0007 02B2    // USART1 Receiver: On
                 ; 0007 02B3    // USART1 Transmitter: On
                 ; 0007 02B4    // USART1 Mode: Asynchronous
                 ; 0007 02B5    // USART1 Baud Rate: 57600 (Double Speed Mode)
                 ; 0007 02B6    UCSR1A=0x02;
0007fa e0e2      	LDI  R30,LOW(2)
0007fb 93e0 009b 	STS  155,R30
                 ; 0007 02B7    UCSR1B=0x98;
0007fd e9e8      	LDI  R30,LOW(152)
0007fe 93e0 009a 	STS  154,R30
                 ; 0007 02B8    UCSR1C=0x06;
000800 e0e6      	LDI  R30,LOW(6)
000801 93e0 009d 	STS  157,R30
                 ; 0007 02B9    UBRR1H=0x00;
000803 e0e0      	LDI  R30,LOW(0)
000804 93e0 0098 	STS  152,R30
                 ; 0007 02BA    UBRR1L=0x22;
000806 e2e2      	LDI  R30,LOW(34)
000807 93e0 0099 	STS  153,R30
                 ; 0007 02BB 
                 ; 0007 02BC    // ADC initialization
                 ; 0007 02BD    // ADC Clock frequency: 1000.000 kHz
                 ; 0007 02BE    // ADC Voltage Reference: AREF pin
                 ; 0007 02BF    ADMUX  = 0x00 & 0xff;
000809 e0e0      	LDI  R30,LOW(0)
00080a b9e7      	OUT  0x7,R30
                 ; 0007 02C0    ADCSRA = 0x84;
00080b e8e4      	LDI  R30,LOW(132)
00080c b9e6      	OUT  0x6,R30
                 ; 0007 02C1 }
00080d 9508      	RET
                 ; .FEND
                 ;
                 ;void InitData(void)
                 ; 0007 02C4 {
                 _InitData:
                 ; .FSTART _InitData
                 ; 0007 02C5    gCurMode = CUR_INIT;
00080e e0e0      	LDI  R30,LOW(0)
00080f 93e0 051b 	STS  _gCurMode,R30
                 ; 0007 02C6    gVoltage=100;
000811 e6e4      	LDI  R30,LOW(100)
000812 e0f0      	LDI  R31,HIGH(100)
000813 93e0 0508 	STS  _gVoltage,R30
000815 93f0 0509 	STS  _gVoltage+1,R31
                 ; 0007 02C7    gMode=0;
000817 e0e0      	LDI  R30,LOW(0)
000818 93e0 050a 	STS  _gMode,R30
                 ; 0007 02C8    gRunFlag = FALSE;
00081a 93e0 050b 	STS  _gRunFlag,R30
                 ; 0007 02C9    gDepth=0;
00081c 940e 0b93 	CALL SUBOPT_0xD
                 ; 0007 02CA    gSpeed=1;
00081e e0e1      	LDI  R30,LOW(1)
00081f e0f0      	LDI  R31,HIGH(1)
000820 93e0 0510 	STS  _gSpeed,R30
000822 93f0 0511 	STS  _gSpeed+1,R31
                 ; 0007 02CB    gFlag=0;
000824 e0e0      	LDI  R30,LOW(0)
000825 93e0 0512 	STS  _gFlag,R30
                 ; 0007 02CC    gError = (1<<ERROR_NOTLCD);
000827 e4e0      	LDI  R30,LOW(64)
000828 93e0 0513 	STS  _gError,R30
                 ; 0007 02CD    gDose = 0;
00082a 940e 0b66 	CALL SUBOPT_0x7
                 ; 0007 02CE 
                 ; 0007 02CF    // A B C D
                 ; 0007 02D0    // - - + -
                 ; 0007 02D1    // - - - +
                 ; 0007 02D2    // + - - -
                 ; 0007 02D3    // - + - -
                 ; 0007 02D4    gElMatrix[0] = 0x02;
00082c 940e 0d8c 	CALL SUBOPT_0x4A
                 ; 0007 02D5    gElMatrix[1] = 0x01;
                 ; 0007 02D6    gElMatrix[2] = 0x08;
                 ; 0007 02D7    gElMatrix[3] = 0x04;
                 ; 0007 02D8 }
00082e 9508      	RET
                 ; .FEND
                 ;void InitSettingData(void)
                 ; 0007 02DA {
                 _InitSettingData:
                 ; .FSTART _InitSettingData
                 ; 0007 02DB    DAC7611_WriteVoltage(gVoltage);
00082f 940e 0b7e 	CALL SUBOPT_0xA
000831 940e 014d 	CALL _DAC7611_WriteVoltage
                 ; 0007 02DC }
000833 9508      	RET
                 ; .FEND
                 ;
                 ;void SystemInit( void )
                 ; 0007 02DF {
                 _SystemInit:
                 ; .FSTART _SystemInit
                 ; 0007 02E0    PortInit();
000834 df7e      	RCALL _PortInit
                 ; 0007 02E1    InitData();
000835 dfd8      	RCALL _InitData
                 ; 0007 02E2 
                 ; 0007 02E3    LoadInEeprom();
000836 d096      	RCALL _LoadInEeprom
                 ; 0007 02E4 
                 ; 0007 02E5    DAC7611_init(  );
000837 940e 0149 	CALL _DAC7611_init
                 ; 0007 02E6 
                 ; 0007 02E7    InitSettingData();
000839 dff5      	RCALL _InitSettingData
                 ; 0007 02E8 
                 ; 0007 02E9    gGenMode = PINB.0?TRUE:FALSE;
00083a 9bb0      	SBIS 0x16,0
00083b c002      	RJMP _0xE009B
00083c e0e1      	LDI  R30,LOW(1)
00083d c001      	RJMP _0xE009C
                 _0xE009B:
00083e e0e0      	LDI  R30,LOW(0)
                 _0xE009C:
00083f 93e0 0783 	STS  _gGenMode,R30
                 ; 0007 02EA 
                 ; 0007 02EB    if( gGenMode==TRUE )
000841 91a0 0783 	LDS  R26,_gGenMode
000843 30a1      	CPI  R26,LOW(0x1)
000844 f499      	BRNE _0xE009E
                 ; 0007 02EC    {
                 ; 0007 02ED      HIGH_PGM2_LED;
000845 9add      	SBI  0x1B,5
                 ; 0007 02EE      // A B C D
                 ; 0007 02EF      // + + - -
                 ; 0007 02F0      // + - + -
                 ; 0007 02F1      // + - - +
                 ; 0007 02F2      // + - + -
                 ; 0007 02F3      gElMatrix[0] = 0x0C;
000846 e0ec      	LDI  R30,LOW(12)
000847 93e0 0500 	STS  _gElMatrix,R30
                 ; 0007 02F4      gElMatrix[1] = 0x0A;
000849 e0ea      	LDI  R30,LOW(10)
                +
00084a 93e0 0501+STS _gElMatrix + ( 1 ) , R30
                 	__PUTB1MN _gElMatrix,1
                 ; 0007 02F5      gElMatrix[2] = 0x09;
00084c e0e9      	LDI  R30,LOW(9)
                +
00084d 93e0 0502+STS _gElMatrix + ( 2 ) , R30
                 	__PUTB1MN _gElMatrix,2
                 ; 0007 02F6      gElMatrix[3] = 0x0A;
00084f e0ea      	LDI  R30,LOW(10)
                +
000850 93e0 0503+STS _gElMatrix + ( 3 ) , R30
                 	__PUTB1MN _gElMatrix,3
                 ; 0007 02F7 
                 ; 0007 02F8      TCCR1A=0x00;
000852 940e 0d87 	CALL SUBOPT_0x49
                 ; 0007 02F9      TCCR1B=0x01;
                 ; 0007 02FA      TCNT1H=0xE7;
000854 eee7      	LDI  R30,LOW(231)
000855 bded      	OUT  0x2D,R30
                 ; 0007 02FB      TCNT1L=0x00;
000856 e0e0      	LDI  R30,LOW(0)
000857 c008      	RJMP _0xE0102
                 ; 0007 02FC    }
                 ; 0007 02FD    else
                 _0xE009E:
                 ; 0007 02FE    {
                 ; 0007 02FF      //TCCR1B= 0x02;
                 ; 0007 0300      HIGH_PGM1_LED;
000858 9adc      	SBI  0x1B,4
                 ; 0007 0301 
                 ; 0007 0302      // A B C D
                 ; 0007 0303      // - - + -
                 ; 0007 0304      // - - - +
                 ; 0007 0305      // + - - -
                 ; 0007 0306      // - + - -
                 ; 0007 0307      gElMatrix[0] = 0x02;
000859 940e 0d8c 	CALL SUBOPT_0x4A
                 ; 0007 0308      gElMatrix[1] = 0x01;
                 ; 0007 0309      gElMatrix[2] = 0x08;
                 ; 0007 030A      gElMatrix[3] = 0x04;
                 ; 0007 030B 
                 ; 0007 030C      #if 0  //10ms
                 ; 0007 030D         TCCR1A=0x00;
                 ; 0007 030E         TCCR1B=0x02;
                 ; 0007 030F         TCNT1H=0xB1;
                 ; 0007 0310         TCNT1L=0xE0;
                 ; 0007 0311     #else   //1ms
                 ; 0007 0312         TCCR1A=0x00;
00085b 940e 0d87 	CALL SUBOPT_0x49
                 ; 0007 0313         TCCR1B=0x01;
                 ; 0007 0314         TCNT1H=0xC1;
00085d ece1      	LDI  R30,LOW(193)
00085e bded      	OUT  0x2D,R30
                 ; 0007 0315         TCNT1L=0x80;
00085f e8e0      	LDI  R30,LOW(128)
                 _0xE0102:
000860 bdec      	OUT  0x2C,R30
                 ; 0007 0316     #endif
                 ; 0007 0317 
                 ; 0007 0318 
                 ; 0007 0319      /*
                 ; 0007 031A      TCCR1A=0x00;
                 ; 0007 031B      TCCR1B=0x02;
                 ; 0007 031C      TCNT1H=0xB1;
                 ; 0007 031D      TCNT1L=0xE0;
                 ; 0007 031E      */
                 ; 0007 031F    }
                 ; 0007 0320 }
000861 9508      	RET
                 ; .FEND
                 ;
                 ;
                 ;BYTE WaitEvent( void )
                 ; 0007 0324 {
                 _WaitEvent:
                 ; .FSTART _WaitEvent
                 ; 0007 0325 
                 ; 0007 0326     while ( 1 )
                 _0xE00A4:
                 ; 0007 0327     {
                 ; 0007 0328        if( IPC_Get_RxCount0() >=  sizeof( IPC_HEADER ) )
000862 940e 05b6 	CALL _IPC_Get_RxCount0
000864 30e7      	CPI  R30,LOW(0x7)
000865 f020      	BRLO _0xE00A7
                 ; 0007 0329        {
                 ; 0007 032A            goldTime1ms = gTime1ms;
000866 940e 0d99 	CALL SUBOPT_0x4B
                 ; 0007 032B            return EVN_RCVUART0;
000868 e0e1      	LDI  R30,LOW(1)
000869 9508      	RET
                 ; 0007 032C        }
                 ; 0007 032D        else if( IPC_Get_RxCount1() >=  sizeof( IPC_HEADER ) )
                 _0xE00A7:
00086a 940e 054f 	CALL _IPC_Get_RxCount1
00086c 30e7      	CPI  R30,LOW(0x7)
00086d f020      	BRLO _0xE00A9
                 ; 0007 032E        {
                 ; 0007 032F            goldTime1ms = gTime1ms;
00086e 940e 0d99 	CALL SUBOPT_0x4B
                 ; 0007 0330            return EVN_RCVUART1;
000870 e0e2      	LDI  R30,LOW(2)
000871 9508      	RET
                 ; 0007 0331        }
                 ; 0007 0332        else if( (gTime1ms-goldTime1ms) > 300 ) // 50=200ms
                 _0xE00A9:
000872 91a0 0504 	LDS  R26,_goldTime1ms
000874 91b0 0505 	LDS  R27,_goldTime1ms+1
000876 91e0 0506 	LDS  R30,_gTime1ms
000878 91f0 0507 	LDS  R31,_gTime1ms+1
00087a 1bea      	SUB  R30,R26
00087b 0bfb      	SBC  R31,R27
00087c 32ed      	CPI  R30,LOW(0x12D)
00087d e0a1      	LDI  R26,HIGH(0x12D)
00087e 07fa      	CPC  R31,R26
00087f f020      	BRLO _0xE00AB
                 ; 0007 0333        {
                 ; 0007 0334          /* if( (gTime1ms- gOldUartTime1ms) > 6000 )
                 ; 0007 0335           {
                 ; 0007 0336              gOldUartTime1ms = gTime1ms;
                 ; 0007 0337              if( IPC_Get_RxCount1() > 0 )
                 ; 0007 0338              {
                 ; 0007 0339                 IPC_ResetCount1();
                 ; 0007 033A              }
                 ; 0007 033B           }
                 ; 0007 033C           */
                 ; 0007 033D           goldTime1ms = gTime1ms;
000880 940e 0d99 	CALL SUBOPT_0x4B
                 ; 0007 033E 
                 ; 0007 033F           return EVN_TIMEOVER;
000882 e0e3      	LDI  R30,LOW(3)
000883 9508      	RET
                 ; 0007 0340        }
                 ; 0007 0341     }
                 _0xE00AB:
000884 cfdd      	RJMP _0xE00A4
                 ; 0007 0342 }
                 ; .FEND
                 ;
                 ;void SaveInEeprom( void )
                 ; 0007 0345 {
                 _SaveInEeprom:
                 ; .FSTART _SaveInEeprom
                 ; 0007 0346    EEPROM_BODY mEDat;
                 ; 0007 0347 
                 ; 0007 0348    memset((void *)&mEDat,0 ,sizeof( EEPROM_BODY));
000885 972b      	SBIW R28,11
                 ;	mEDat -> Y+0
000886 01fe      	MOVW R30,R28
000887 93fa      	ST   -Y,R31
000888 93ea      	ST   -Y,R30
000889 e0e0      	LDI  R30,LOW(0)
00088a 93ea      	ST   -Y,R30
00088b e0ab      	LDI  R26,LOW(11)
00088c e0b0      	LDI  R27,0
00088d 940e 0b30 	CALL _memset
                 ; 0007 0349 
                 ; 0007 034A    mEDat.AkFlag = 'A';
00088f e4e1      	LDI  R30,LOW(65)
000890 83e8      	ST   Y,R30
                 ; 0007 034B    mEDat.Run  = gRunFlag?1:0;
000891 91e0 050b 	LDS  R30,_gRunFlag
000893 30e0      	CPI  R30,0
000894 f011      	BREQ _0xE00AC
000895 e0e1      	LDI  R30,LOW(1)
000896 c001      	RJMP _0xE00AD
                 _0xE00AC:
000897 e0e0      	LDI  R30,LOW(0)
                 _0xE00AD:
000898 83ea      	STD  Y+2,R30
                 ; 0007 034C    mEDat.Dose1 = (BYTE)((gDose>>8)&0xff);
000899 91e0 050c 	LDS  R30,_gDose
00089b 91f0 050d 	LDS  R31,_gDose+1
00089d 940e 0fb7 	CALL __ASRW8
00089f 83eb      	STD  Y+3,R30
                 ; 0007 034D    mEDat.Dose2 = (BYTE)(gDose&0xff);
0008a0 91e0 050c 	LDS  R30,_gDose
0008a2 83ec      	STD  Y+4,R30
                 ; 0007 034E    mEDat.Voltage = gVoltage ;
0008a3 91e0 0508 	LDS  R30,_gVoltage
0008a5 83ed      	STD  Y+5,R30
                 ; 0007 034F    mEDat.Depth = gDepth;
0008a6 91e0 050e 	LDS  R30,_gDepth
0008a8 83ee      	STD  Y+6,R30
                 ; 0007 0350    mEDat.Speed = gSpeed;
0008a9 91e0 0510 	LDS  R30,_gSpeed
0008ab 83ef      	STD  Y+7,R30
                 ; 0007 0351    mEDat.Flag  = gFlag;
0008ac 91e0 0512 	LDS  R30,_gFlag
0008ae 87e8      	STD  Y+8,R30
                 ; 0007 0352    mEDat.Map1  = (gElMatrix[0]<<4)&0xf0 | gElMatrix[1]&0x0f;
0008af 91e0 0500 	LDS  R30,_gElMatrix
0008b1 95e2      	SWAP R30
0008b2 7fe0      	ANDI R30,LOW(0xF0)
0008b3 2fae      	MOV  R26,R30
                +
0008b4 91e0 0501+LDS R30 , _gElMatrix + ( 1 )
                 	__GETB1MN _gElMatrix,1
0008b6 70ef      	ANDI R30,LOW(0xF)
0008b7 2bea      	OR   R30,R26
0008b8 87e9      	STD  Y+9,R30
                 ; 0007 0353    mEDat.Map2  = (gElMatrix[2]<<4)&0xf0 | gElMatrix[3]&0x0f;
                +
0008b9 91e0 0502+LDS R30 , _gElMatrix + ( 2 )
                 	__GETB1MN _gElMatrix,2
0008bb 95e2      	SWAP R30
0008bc 7fe0      	ANDI R30,LOW(0xF0)
0008bd 2fae      	MOV  R26,R30
                +
0008be 91e0 0503+LDS R30 , _gElMatrix + ( 3 )
                 	__GETB1MN _gElMatrix,3
0008c0 70ef      	ANDI R30,LOW(0xF)
0008c1 2bea      	OR   R30,R26
0008c2 87ea      	STD  Y+10,R30
                 ; 0007 0354    E2pWriteLen((BYTE*)&mEDat, E_EP_MODE, sizeof( EEPROM_BODY));
0008c3 01fe      	MOVW R30,R28
0008c4 93fa      	ST   -Y,R31
0008c5 93ea      	ST   -Y,R30
0008c6 e0ea      	LDI  R30,LOW(10)
0008c7 93ea      	ST   -Y,R30
0008c8 e0ab      	LDI  R26,LOW(11)
0008c9 940e 0129 	CALL _E2pWriteLen
                 ; 0007 0355 }
0008cb 962b      	ADIW R28,11
0008cc 9508      	RET
                 ; .FEND
                 ;
                 ;void LoadInEeprom( void )
                 ; 0007 0358 {
                 _LoadInEeprom:
                 ; .FSTART _LoadInEeprom
                 ; 0007 0359    BYTE mData[20];
                 ; 0007 035A    LPEEPROM_BODY mEDat;
                 ; 0007 035B 
                 ; 0007 035C    memset((void *)&mData,0 ,20 );
0008cd 9764      	SBIW R28,20
0008ce 931a      	ST   -Y,R17
0008cf 930a      	ST   -Y,R16
                 ;	mData -> Y+2
                 ;	*mEDat -> R16,R17
0008d0 01fe      	MOVW R30,R28
0008d1 9632      	ADIW R30,2
0008d2 93fa      	ST   -Y,R31
0008d3 93ea      	ST   -Y,R30
0008d4 e0e0      	LDI  R30,LOW(0)
0008d5 93ea      	ST   -Y,R30
0008d6 e1a4      	LDI  R26,LOW(20)
0008d7 e0b0      	LDI  R27,0
0008d8 940e 0b30 	CALL _memset
                 ; 0007 035D    E2pReadLen( mData, E_EP_MODE, sizeof( EEPROM_BODY));
0008da 01fe      	MOVW R30,R28
0008db 9632      	ADIW R30,2
0008dc 93fa      	ST   -Y,R31
0008dd 93ea      	ST   -Y,R30
0008de e0ea      	LDI  R30,LOW(10)
0008df 93ea      	ST   -Y,R30
0008e0 e0ab      	LDI  R26,LOW(11)
0008e1 940e 0109 	CALL _E2pReadLen
                 ; 0007 035E    mEDat =(LPEEPROM_BODY)mData ;
0008e3 01fe      	MOVW R30,R28
0008e4 9632      	ADIW R30,2
0008e5 018f      	MOVW R16,R30
                 ; 0007 035F 
                 ; 0007 0360    if( mEDat->AkFlag == 'A' )
0008e6 01d8      	MOVW R26,R16
0008e7 91ac      	LD   R26,X
0008e8 34a1      	CPI  R26,LOW(0x41)
0008e9 f009      	BREQ PC+2
0008ea c073      	RJMP _0xE00AF
                 ; 0007 0361    {
                 ; 0007 0362       gMode = 0; //= mEDat->Mode;
0008eb e0e0      	LDI  R30,LOW(0)
0008ec 93e0 050a 	STS  _gMode,R30
                 ; 0007 0363       //gRunFlag = mEDat->Run?TRUE:FALSE;
                 ; 0007 0364       gDose = (int)mEDat->Dose1<<8|mEDat->Dose2;
0008ee 01f8      	MOVW R30,R16
0008ef 81e3      	LDD  R30,Z+3
0008f0 2ffe      	MOV  R31,R30
0008f1 e0e0      	LDI  R30,0
0008f2 01df      	MOVW R26,R30
0008f3 01f8      	MOVW R30,R16
0008f4 81e4      	LDD  R30,Z+4
0008f5 e0f0      	LDI  R31,0
0008f6 2bea      	OR   R30,R26
0008f7 2bfb      	OR   R31,R27
0008f8 940e 0b61 	CALL SUBOPT_0x6
                 ; 0007 0365       if( gDose < 0 ) gDose = 0;
0008fa 91a0 050d 	LDS  R26,_gDose+1
0008fc 23aa      	TST  R26
0008fd f412      	BRPL _0xE00B0
0008fe 940e 0b66 	CALL SUBOPT_0x7
                 ; 0007 0366       if( gDose > 3 ) gDose = 3;
                 _0xE00B0:
000900 91a0 050c 	LDS  R26,_gDose
000902 91b0 050d 	LDS  R27,_gDose+1
000904 9714      	SBIW R26,4
000905 f024      	BRLT _0xE00B1
000906 e0e3      	LDI  R30,LOW(3)
000907 e0f0      	LDI  R31,HIGH(3)
000908 940e 0b61 	CALL SUBOPT_0x6
                 ; 0007 0367 
                 ; 0007 0368       gVoltage = mEDat->Voltage;
                 _0xE00B1:
00090a 01f8      	MOVW R30,R16
00090b 81e5      	LDD  R30,Z+5
00090c 940e 0b6c 	CALL SUBOPT_0x8
                 ; 0007 0369       if( gVoltage < 60 ) gVoltage = 60;
00090e f414      	BRGE _0xE00B2
00090f 940e 0b77 	CALL SUBOPT_0x9
                 ; 0007 036A       if( gVoltage > 120 ) gVoltage = 120;
                 _0xE00B2:
000911 940e 0b7e 	CALL SUBOPT_0xA
000913 37a9      	CPI  R26,LOW(0x79)
000914 e0e0      	LDI  R30,HIGH(0x79)
000915 07be      	CPC  R27,R30
000916 f014      	BRLT _0xE00B3
000917 940e 0b83 	CALL SUBOPT_0xB
                 ; 0007 036B 
                 ; 0007 036C       gDepth = mEDat->Depth;
                 _0xE00B3:
000919 01f8      	MOVW R30,R16
00091a 81e6      	LDD  R30,Z+6
00091b 940e 0b8a 	CALL SUBOPT_0xC
                 ; 0007 036D       if( gDepth < 0 ) gDepth = 0;
00091d f412      	BRPL _0xE00B4
00091e 940e 0b93 	CALL SUBOPT_0xD
                 ; 0007 036E       if( gDepth > 3 ) gDepth = 3;
                 _0xE00B4:
000920 91a0 050e 	LDS  R26,_gDepth
000922 91b0 050f 	LDS  R27,_gDepth+1
000924 9714      	SBIW R26,4
000925 f014      	BRLT _0xE00B5
000926 940e 0b99 	CALL SUBOPT_0xE
                 ; 0007 036F 
                 ; 0007 0370       gSpeed = mEDat->Speed;
                 _0xE00B5:
000928 01f8      	MOVW R30,R16
000929 81e7      	LDD  R30,Z+7
00092a 940e 0ba0 	CALL SUBOPT_0xF
                 ; 0007 0371       if( gSpeed < 0 ) gSpeed = 0;
00092c f42a      	BRPL _0xE00B6
00092d e0e0      	LDI  R30,LOW(0)
00092e 93e0 0510 	STS  _gSpeed,R30
000930 93e0 0511 	STS  _gSpeed+1,R30
                 ; 0007 0372       if( gSpeed > 2 ) gSpeed = 2;
                 _0xE00B6:
000932 91a0 0510 	LDS  R26,_gSpeed
000934 91b0 0511 	LDS  R27,_gSpeed+1
000936 9713      	SBIW R26,3
000937 f014      	BRLT _0xE00B7
000938 940e 0ba9 	CALL SUBOPT_0x10
                 ; 0007 0373 
                 ; 0007 0374       gFlag = mEDat->Flag;
                 _0xE00B7:
00093a 01f8      	MOVW R30,R16
00093b 85e0      	LDD  R30,Z+8
00093c 93e0 0512 	STS  _gFlag,R30
                 ; 0007 0375       gElMatrix[0] = (mEDat->Map1>>4)&0x0f;
00093e 01f8      	MOVW R30,R16
00093f 85e1      	LDD  R30,Z+9
000940 95e2      	SWAP R30
000941 70ef      	ANDI R30,LOW(0xF)
000942 93e0 0500 	STS  _gElMatrix,R30
                 ; 0007 0376       gElMatrix[1] = mEDat->Map1&0x0f;
000944 01f8      	MOVW R30,R16
000945 85a1      	LDD  R26,Z+9
000946 e0ef      	LDI  R30,LOW(15)
000947 23ea      	AND  R30,R26
                +
000948 93e0 0501+STS _gElMatrix + ( 1 ) , R30
                 	__PUTB1MN _gElMatrix,1
                 ; 0007 0377       gElMatrix[2] = (mEDat->Map2>>4)&0x0f;
00094a 01f8      	MOVW R30,R16
00094b 85e2      	LDD  R30,Z+10
00094c 95e2      	SWAP R30
00094d 70ef      	ANDI R30,LOW(0xF)
                +
00094e 93e0 0502+STS _gElMatrix + ( 2 ) , R30
                 	__PUTB1MN _gElMatrix,2
                 ; 0007 0378       gElMatrix[3] = mEDat->Map2&0x0f;
000950 01f8      	MOVW R30,R16
000951 85a2      	LDD  R26,Z+10
000952 e0ef      	LDI  R30,LOW(15)
000953 23ea      	AND  R30,R26
                +
000954 93e0 0503+STS _gElMatrix + ( 3 ) , R30
                 	__PUTB1MN _gElMatrix,3
                 ; 0007 0379 
                 ; 0007 037A       if( gVoltage > 50 ) LOW_VOLRY;
000956 940e 0b7e 	CALL SUBOPT_0xA
000958 97d3      	SBIW R26,51
000959 f014      	BRLT _0xE00B8
00095a 9897      	CBI  0x12,7
                 ; 0007 037B       else  HIGH_VOLRY;
00095b c001      	RJMP _0xE00BB
                 _0xE00B8:
00095c 9a97      	SBI  0x12,7
                 ; 0007 037C    }
                 _0xE00BB:
                 ; 0007 037D    else
00095d c002      	RJMP _0xE00BE
                 _0xE00AF:
                 ; 0007 037E    {
                 ; 0007 037F       InitData();
00095e deaf      	RCALL _InitData
                 ; 0007 0380       SaveInEeprom();
00095f df25      	RCALL _SaveInEeprom
                 ; 0007 0381    }
                 _0xE00BE:
                 ; 0007 0382 }
000960 8119      	LDD  R17,Y+1
000961 8108      	LDD  R16,Y+0
000962 9666      	ADIW R28,22
000963 9508      	RET
                 ; .FEND
                 ;
                 ;void ADCProcessor( void )
                 ; 0007 0385 {
                 _ADCProcessor:
                 ; .FSTART _ADCProcessor
                 ; 0007 0386    // 0: Heat Protect
                 ; 0007 0387    // 1: output voltage
                 ; 0007 0388    // 2: elect current
                 ; 0007 0389    int mIndexVol=0;
                 ; 0007 038A    int mVol;
                 ; 0007 038B    int mTemp;
                 ; 0007 038C    float mCalvol;
                 ; 0007 038D    mVol= read_adc( gAdcLoc );
000964 9724      	SBIW R28,4
000965 940e 1002 	CALL __SAVELOCR6
                 ;	mIndexVol -> R16,R17
                 ;	mVol -> R18,R19
                 ;	mTemp -> R20,R21
                 ;	mCalvol -> Y+6
                +
000967 e000     +LDI R16 , LOW ( 0 )
000968 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
000969 91a0 0773 	LDS  R26,_gAdcLoc
00096b 940e 05ea 	CALL _read_adc
00096d 019f      	MOVW R18,R30
                 ; 0007 038E 
                 ; 0007 038F    if( gAdcLoc == 0 )
00096e 91e0 0773 	LDS  R30,_gAdcLoc
000970 91f0 0774 	LDS  R31,_gAdcLoc+1
000972 9730      	SBIW R30,0
000973 f481      	BRNE _0xE00BF
                 ; 0007 0390    {
                 ; 0007 0391       if( mVol > 25)
                +
000974 312a     +CPI R18 , LOW ( 26 )
000975 e0e0     +LDI R30 , HIGH ( 26 )
000976 073e     +CPC R19 , R30
                 	__CPWRN 18,19,26
000977 f034      	BRLT _0xE00C0
                 ; 0007 0392       {
                 ; 0007 0393          gError |= (1<<ERROR_HEATSINK);  //2.5V
000978 91e0 0513 	LDS  R30,_gError
00097a 61e0      	ORI  R30,0x10
00097b 940e 0ccf 	CALL SUBOPT_0x2E
                 ; 0007 0394          gCurMode =  CUR_ERROR;
                 ; 0007 0395       }
                 ; 0007 0396       else
00097d c005      	RJMP _0xE00C1
                 _0xE00C0:
                 ; 0007 0397       {
                 ; 0007 0398          gError &= ~(1<<ERROR_HEATSINK);  //2.5V
00097e 91e0 0513 	LDS  R30,_gError
000980 7eef      	ANDI R30,0xEF
000981 93e0 0513 	STS  _gError,R30
                 ; 0007 0399       }
                 _0xE00C1:
                 ; 0007 039A    }
                 ; 0007 039B    else if( gAdcLoc == 1 )
000983 c10f      	RJMP _0xE00C2
                 _0xE00BF:
000984 940e 0da2 	CALL SUBOPT_0x4C
000986 9711      	SBIW R26,1
000987 f009      	BREQ PC+2
000988 c0d5      	RJMP _0xE00C3
                 ; 0007 039C    {
                 ; 0007 039D       if( gMode == MODE_READY && gFlag == FLAG_VOLADJ )
000989 91a0 050a 	LDS  R26,_gMode
00098b 30a1      	CPI  R26,LOW(0x1)
00098c f421      	BRNE _0xE00C5
00098d 91a0 0512 	LDS  R26,_gFlag
00098f 30a1      	CPI  R26,LOW(0x1)
000990 f009      	BREQ _0xE00C6
                 _0xE00C5:
000991 c0c6      	RJMP _0xE00C4
                 _0xE00C6:
                 ; 0007 039E       {
                 ; 0007 039F 
                 ; 0007 03A0         if( gVoltage> 50 )
000992 940e 0b7e 	CALL SUBOPT_0xA
000994 97d3      	SBIW R26,51
000995 f40c      	BRGE PC+2
000996 c05d      	RJMP _0xE00C7
                 ; 0007 03A1         {
                 ; 0007 03A2            if( gVolChkCount > 0 )
000997 940e 0da7 	CALL SUBOPT_0x4D
000999 f41c      	BRGE _0xE00C8
                 ; 0007 03A3            {
                 ; 0007 03A4               gVolChkCount--;
00099a 940e 0dae 	CALL SUBOPT_0x4E
                 ; 0007 03A5            }
                 ; 0007 03A6            else   //2*600ms = 1.2sec
00099c c056      	RJMP _0xE00C9
                 _0xE00C8:
                 ; 0007 03A7            {
                 ; 0007 03A8               if(gVoltage < 20 ) mIndexVol = 0;
00099d 940e 0b7e 	CALL SUBOPT_0xA
00099f 9754      	SBIW R26,20
0009a0 f41c      	BRGE _0xE00CA
                +
0009a1 e000     +LDI R16 , LOW ( 0 )
0009a2 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 ; 0007 03A9               else  mIndexVol = (gVoltage-20)/10;
0009a3 c005      	RJMP _0xE00CB
                 _0xE00CA:
0009a4 940e 0b7e 	CALL SUBOPT_0xA
0009a6 940e 0b4a 	CALL SUBOPT_0x2
0009a8 018f      	MOVW R16,R30
                 ; 0007 03AA 
                 ; 0007 03AB               mCalvol = DacArray[mIndexVol];
                 _0xE00CB:
0009a9 940e 0db6 	CALL SUBOPT_0x4F
                 ; 0007 03AC 
                 ; 0007 03AD               //gReadVol =(int)(60.0f+(float)mVol*2.2f);
                 ; 0007 03AE 
                 ; 0007 03AF               if( (float)mVol > (mCalvol-mCalvol*0.2f) &&
                 ; 0007 03B0                   (float)mVol < (mCalvol+mCalvol*0.2f) )
0009ab 937f      	PUSH R23
0009ac 936f      	PUSH R22
0009ad 93ff      	PUSH R31
0009ae 93ef      	PUSH R30
0009af 940e 0dc4 	CALL SUBOPT_0x50
0009b1 940e 0dc9 	CALL SUBOPT_0x51
0009b3 940e 0ff1 	CALL __SWAPD12
0009b5 940e 0e83 	CALL __SUBF12
0009b7 91af      	POP  R26
0009b8 91bf      	POP  R27
0009b9 918f      	POP  R24
0009ba 919f      	POP  R25
0009bb 940e 0f6d 	CALL __CMPF12
0009bd f009      	BREQ PC+2
0009be f408      	BRCC PC+2
0009bf c011      	RJMP _0xE00CD
0009c0 940e 0b50 	CALL SUBOPT_0x3
0009c2 937f      	PUSH R23
0009c3 936f      	PUSH R22
0009c4 93ff      	PUSH R31
0009c5 93ef      	PUSH R30
0009c6 940e 0dd0 	CALL SUBOPT_0x52
0009c8 940e 0e8a 	CALL __ADDF12
0009ca 91af      	POP  R26
0009cb 91bf      	POP  R27
0009cc 918f      	POP  R24
0009cd 919f      	POP  R25
0009ce 940e 0f6d 	CALL __CMPF12
0009d0 f008      	BRLO _0xE00CE
                 _0xE00CD:
0009d1 c014      	RJMP _0xE00CC
                 _0xE00CE:
                 ; 0007 03B1               {
                 ; 0007 03B2 
                 ; 0007 03B3                  gFlag = FLAG_READY;
0009d2 940e 0dd2 	CALL SUBOPT_0x53
                 ; 0007 03B4                  if( gError & (1<<ERROR_VOL) )
0009d4 f059      	BREQ _0xE00CF
                 ; 0007 03B5                  {
                 ; 0007 03B6                      gVolAdjCount++; //300ms
0009d5 940e 0dd9 	CALL SUBOPT_0x54
                 ; 0007 03B7                      if( gVolAdjCount > 3 )  //300ms*3
0009d7 940e 0ddc 	CALL SUBOPT_0x55
0009d9 f02c      	BRLT _0xE00D0
                 ; 0007 03B8                      {
                 ; 0007 03B9                         gVolAdjCount = 0;
0009da 940e 0de2 	CALL SUBOPT_0x56
                 ; 0007 03BA                         gError &= ~(1<<ERROR_VOL);  //2.5V
0009dc 7fee      	ANDI R30,0xFE
0009dd 93e0 0513 	STS  _gError,R30
                 ; 0007 03BB                      }
                 ; 0007 03BC                  }
                 _0xE00D0:
                 ; 0007 03BD                  else
0009df c005      	RJMP _0xE00D1
                 _0xE00CF:
                 ; 0007 03BE                  {
                 ; 0007 03BF                     gError &= ~(1<<ERROR_VOL);  //2.5V
0009e0 91e0 0513 	LDS  R30,_gError
0009e2 7fee      	ANDI R30,0xFE
0009e3 93e0 0513 	STS  _gError,R30
                 ; 0007 03C0                  }
                 _0xE00D1:
                 ; 0007 03C1               }
                 ; 0007 03C2               else
0009e5 c00d      	RJMP _0xE00D2
                 _0xE00CC:
                 ; 0007 03C3               {
                 ; 0007 03C4                  gFlag = FLAG_VOLADJ;
0009e6 e0e1      	LDI  R30,LOW(1)
0009e7 93e0 0512 	STS  _gFlag,R30
                 ; 0007 03C5                  gVolAdjCount++; //300ms
0009e9 940e 0dd9 	CALL SUBOPT_0x54
                 ; 0007 03C6                  if( gVolAdjCount > 3 )  //300ms*3
0009eb 940e 0ddc 	CALL SUBOPT_0x55
0009ed f02c      	BRLT _0xE00D3
                 ; 0007 03C7                 {
                 ; 0007 03C8                     gVolAdjCount = 0;
0009ee 940e 0de2 	CALL SUBOPT_0x56
                 ; 0007 03C9                     gError |= (1<<ERROR_VOL);
0009f0 60e1      	ORI  R30,1
0009f1 940e 0ccf 	CALL SUBOPT_0x2E
                 ; 0007 03CA                     gCurMode =  CUR_ERROR;
                 ; 0007 03CB                 }
                 ; 0007 03CC               }
                 _0xE00D3:
                 _0xE00D2:
                 ; 0007 03CD            }
                 _0xE00C9:
                 ; 0007 03CE          }
                 ; 0007 03CF          else
0009f3 c05a      	RJMP _0xE00D4
                 _0xE00C7:
                 ; 0007 03D0          {
                 ; 0007 03D1            if( gVolChkCount > 0 )
0009f4 940e 0da7 	CALL SUBOPT_0x4D
0009f6 f41c      	BRGE _0xE00D5
                 ; 0007 03D2            {
                 ; 0007 03D3               gVolChkCount--;
0009f7 940e 0dae 	CALL SUBOPT_0x4E
                 ; 0007 03D4            }
                 ; 0007 03D5            else
0009f9 c054      	RJMP _0xE00D6
                 _0xE00D5:
                 ; 0007 03D6            {
                 ; 0007 03D7               if(gVoltage < 20 ) mIndexVol = 0;
0009fa 940e 0b7e 	CALL SUBOPT_0xA
0009fc 9754      	SBIW R26,20
0009fd f41c      	BRGE _0xE00D7
                +
0009fe e000     +LDI R16 , LOW ( 0 )
0009ff e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 ; 0007 03D8               else  mIndexVol = (gVoltage-20)/10;
000a00 c005      	RJMP _0xE00D8
                 _0xE00D7:
000a01 940e 0b7e 	CALL SUBOPT_0xA
000a03 940e 0b4a 	CALL SUBOPT_0x2
000a05 018f      	MOVW R16,R30
                 ; 0007 03D9 
                 ; 0007 03DA               mCalvol = DacArray[mIndexVol];
                 _0xE00D8:
000a06 940e 0db6 	CALL SUBOPT_0x4F
                 ; 0007 03DB 
                 ; 0007 03DC              // mTemp = LowVolAdj[gVoltage/10-2];
                 ; 0007 03DD              // gReadVol =(int)(mTemp+20.0f+(float)mVol*0.68f);
                 ; 0007 03DE               if( (float)mVol > (mCalvol-mCalvol*0.2f) &&
                 ; 0007 03DF                   (float)mVol < (mCalvol+mCalvol*0.2f) )
000a08 937f      	PUSH R23
000a09 936f      	PUSH R22
000a0a 93ff      	PUSH R31
000a0b 93ef      	PUSH R30
000a0c 940e 0dd0 	CALL SUBOPT_0x52
000a0e 940e 0ff1 	CALL __SWAPD12
000a10 940e 0e83 	CALL __SUBF12
000a12 91af      	POP  R26
000a13 91bf      	POP  R27
000a14 918f      	POP  R24
000a15 919f      	POP  R25
000a16 940e 0f6d 	CALL __CMPF12
000a18 f009      	BREQ PC+2
000a19 f408      	BRCC PC+2
000a1a c011      	RJMP _0xE00DA
000a1b 940e 0b50 	CALL SUBOPT_0x3
000a1d 937f      	PUSH R23
000a1e 936f      	PUSH R22
000a1f 93ff      	PUSH R31
000a20 93ef      	PUSH R30
000a21 940e 0dd0 	CALL SUBOPT_0x52
000a23 940e 0e8a 	CALL __ADDF12
000a25 91af      	POP  R26
000a26 91bf      	POP  R27
000a27 918f      	POP  R24
000a28 919f      	POP  R25
000a29 940e 0f6d 	CALL __CMPF12
000a2b f008      	BRLO _0xE00DB
                 _0xE00DA:
000a2c c014      	RJMP _0xE00D9
                 _0xE00DB:
                 ; 0007 03E0               {
                 ; 0007 03E1                  gFlag = FLAG_READY;
000a2d 940e 0dd2 	CALL SUBOPT_0x53
                 ; 0007 03E2                  if( gError & (1<<ERROR_VOL) )
000a2f f059      	BREQ _0xE00DC
                 ; 0007 03E3                  {
                 ; 0007 03E4                     gVolAdjCount++; //300ms
000a30 940e 0dd9 	CALL SUBOPT_0x54
                 ; 0007 03E5                     if( gVolAdjCount > 3 )  //300ms*3
000a32 940e 0ddc 	CALL SUBOPT_0x55
000a34 f02c      	BRLT _0xE00DD
                 ; 0007 03E6                     {
                 ; 0007 03E7                       gVolAdjCount = 0;
000a35 940e 0de2 	CALL SUBOPT_0x56
                 ; 0007 03E8                       gError &= ~(1<<ERROR_VOL);  //2.5V
000a37 7fee      	ANDI R30,0xFE
000a38 93e0 0513 	STS  _gError,R30
                 ; 0007 03E9                     }
                 ; 0007 03EA                  }
                 _0xE00DD:
                 ; 0007 03EB                  else
000a3a c005      	RJMP _0xE00DE
                 _0xE00DC:
                 ; 0007 03EC                  {
                 ; 0007 03ED                    gError &= ~(1<<ERROR_VOL);  //2.5V
000a3b 91e0 0513 	LDS  R30,_gError
000a3d 7fee      	ANDI R30,0xFE
000a3e 93e0 0513 	STS  _gError,R30
                 ; 0007 03EE                  }
                 _0xE00DE:
                 ; 0007 03EF               }
                 ; 0007 03F0               else
000a40 c00d      	RJMP _0xE00DF
                 _0xE00D9:
                 ; 0007 03F1               {
                 ; 0007 03F2                 gFlag = FLAG_VOLADJ;
000a41 e0e1      	LDI  R30,LOW(1)
000a42 93e0 0512 	STS  _gFlag,R30
                 ; 0007 03F3                 gVolAdjCount++; //300ms
000a44 940e 0dd9 	CALL SUBOPT_0x54
                 ; 0007 03F4                 if( gVolAdjCount > 3 )  //300ms*3
000a46 940e 0ddc 	CALL SUBOPT_0x55
000a48 f02c      	BRLT _0xE00E0
                 ; 0007 03F5                 {
                 ; 0007 03F6                    gVolAdjCount = 0;
000a49 940e 0de2 	CALL SUBOPT_0x56
                 ; 0007 03F7                    gError |= (1<<ERROR_VOL);
000a4b 60e1      	ORI  R30,1
000a4c 940e 0ccf 	CALL SUBOPT_0x2E
                 ; 0007 03F8                    gCurMode =  CUR_ERROR;
                 ; 0007 03F9                 }
                 ; 0007 03FA               }
                 _0xE00E0:
                 _0xE00DF:
                 ; 0007 03FB            }
                 _0xE00D6:
                 ; 0007 03FC          }
                 _0xE00D4:
                 ; 0007 03FD 
                 ; 0007 03FE          if( IN_FET_SEN )
000a4e 9b84      	SBIS 0x10,4
000a4f c007      	RJMP _0xE00E1
                 ; 0007 03FF          {
                 ; 0007 0400             PORTC = 0x00;
000a50 e0e0      	LDI  R30,LOW(0)
000a51 bbe5      	OUT  0x15,R30
                 ; 0007 0401             gError |= (1<<ERROR_VOL);
000a52 91e0 0513 	LDS  R30,_gError
000a54 60e1      	ORI  R30,1
000a55 940e 0ccf 	CALL SUBOPT_0x2E
                 ; 0007 0402             gCurMode =  CUR_ERROR;
                 ; 0007 0403          }
                 ; 0007 0404 
                 ; 0007 0405       }
                 _0xE00E1:
                 ; 0007 0406       else
000a57 c005      	RJMP _0xE00E2
                 _0xE00C4:
                 ; 0007 0407       {
                 ; 0007 0408           gVolAdjCount = 0; //2020-09-04
000a58 e0e0      	LDI  R30,LOW(0)
000a59 93e0 0781 	STS  _gVolAdjCount,R30
000a5b 93e0 0782 	STS  _gVolAdjCount+1,R30
                 ; 0007 0409       }
                 _0xE00E2:
                 ; 0007 040A    }
                 ; 0007 040B    else if( gAdcLoc == 2 )
000a5d c035      	RJMP _0xE00E3
                 _0xE00C3:
000a5e 940e 0da2 	CALL SUBOPT_0x4C
000a60 9712      	SBIW R26,2
000a61 f589      	BRNE _0xE00E4
                 ; 0007 040C    {
                 ; 0007 040D       if( gRunFlag==TRUE && gElCompletFlag == TRUE )
000a62 91a0 050b 	LDS  R26,_gRunFlag
000a64 30a1      	CPI  R26,LOW(0x1)
000a65 f421      	BRNE _0xE00E6
000a66 91a0 0518 	LDS  R26,_gElCompletFlag
000a68 30a1      	CPI  R26,LOW(0x1)
000a69 f009      	BREQ _0xE00E7
                 _0xE00E6:
000a6a c028      	RJMP _0xE00E5
                 _0xE00E7:
                 ; 0007 040E       {
                 ; 0007 040F          gRunFlag = FALSE;
000a6b e0e0      	LDI  R30,LOW(0)
000a6c 93e0 050b 	STS  _gRunFlag,R30
                 ; 0007 0410          if( mVol > 25)
                +
000a6e 312a     +CPI R18 , LOW ( 26 )
000a6f e0e0     +LDI R30 , HIGH ( 26 )
000a70 073e     +CPC R19 , R30
                 	__CPWRN 18,19,26
000a71 f0dc      	BRLT _0xE00E8
                 ; 0007 0411          {
                 ; 0007 0412             gError &= ~(1<<ERROR_ELOUT);  //2.5V
000a72 91e0 0513 	LDS  R30,_gError
000a74 7fed      	ANDI R30,0xFD
000a75 93e0 0513 	STS  _gError,R30
                 ; 0007 0413 
                 ; 0007 0414             gElCount++;
000a77 e1a9      	LDI  R26,LOW(_gElCount)
000a78 e0b5      	LDI  R27,HIGH(_gElCount)
000a79 940e 0d09 	CALL SUBOPT_0x35
                 ; 0007 0415             if( gElCount > 999 ) gElCount = 999;
000a7b 91a0 0519 	LDS  R26,_gElCount
000a7d 91b0 051a 	LDS  R27,_gElCount+1
000a7f 3ea8      	CPI  R26,LOW(0x3E8)
000a80 e0e3      	LDI  R30,HIGH(0x3E8)
000a81 07be      	CPC  R27,R30
000a82 f024      	BRLT _0xE00E9
000a83 eee7      	LDI  R30,LOW(999)
000a84 e0f3      	LDI  R31,HIGH(999)
000a85 940e 0bb0 	CALL SUBOPT_0x11
                 ; 0007 0416             HIGH_COMPLETE_LED;
                 _0xE00E9:
000a87 91e0 0062 	LDS  R30,98
000a89 68e0      	ORI  R30,0x80
000a8a 93e0 0062 	STS  98,R30
                 ; 0007 0417          }
                 ; 0007 0418          else
000a8c c005      	RJMP _0xE00EA
                 _0xE00E8:
                 ; 0007 0419          {
                 ; 0007 041A             gError |= (1<<ERROR_ELOUT);  //2.5V
000a8d 91e0 0513 	LDS  R30,_gError
000a8f 60e2      	ORI  R30,2
000a90 940e 0ccf 	CALL SUBOPT_0x2E
                 ; 0007 041B             gCurMode =  CUR_ERROR;
                 ; 0007 041C 
                 ; 0007 041D            // LOW_COMPLETE_LED;
                 ; 0007 041E          }
                 _0xE00EA:
                 ; 0007 041F          HIGH_SH;
000a92 9ac6      	SBI  0x18,6
                 ; 0007 0420       }
                 ; 0007 0421    }
                 _0xE00E5:
                 ; 0007 0422    gAdcLoc++;
                 _0xE00E4:
                 _0xE00E3:
                 _0xE00C2:
000a93 e7a3      	LDI  R26,LOW(_gAdcLoc)
000a94 e0b7      	LDI  R27,HIGH(_gAdcLoc)
000a95 940e 0d09 	CALL SUBOPT_0x35
                 ; 0007 0423    if( gAdcLoc > 2 ) gAdcLoc = 0;
000a97 940e 0da2 	CALL SUBOPT_0x4C
000a99 9713      	SBIW R26,3
000a9a f02c      	BRLT _0xE00ED
000a9b e0e0      	LDI  R30,LOW(0)
000a9c 93e0 0773 	STS  _gAdcLoc,R30
000a9e 93e0 0774 	STS  _gAdcLoc+1,R30
                 ; 0007 0424 }
                 _0xE00ED:
000aa0 940e 1009 	CALL __LOADLOCR6
000aa2 962a      	ADIW R28,10
000aa3 9508      	RET
                 ; .FEND
                 ;
                 ;void DisplayLed( void )
                 ; 0007 0427 {
                 _DisplayLed:
                 ; .FSTART _DisplayLed
                 ; 0007 0428     if( gError > ERROR_NO )
000aa4 91a0 0513 	LDS  R26,_gError
000aa6 30a1      	CPI  R26,LOW(0x1)
000aa7 f030      	BRLO _0xE00EE
                 ; 0007 0429     {
                 ; 0007 042A        HIGH_WARRING_LED;
000aa8 91e0 0062 	LDS  R30,98
000aaa 64e0      	ORI  R30,0x40
000aab 93e0 0062 	STS  98,R30
                 ; 0007 042B        LOW_COMPLETE_LED;
000aad c00d      	RJMP _0xE0103
                 ; 0007 042C     }
                 ; 0007 042D     else
                 _0xE00EE:
                 ; 0007 042E     {
                 ; 0007 042F        LOW_WARRING_LED;
000aae 91e0 0062 	LDS  R30,98
000ab0 7bef      	ANDI R30,0xBF
000ab1 93e0 0062 	STS  98,R30
                 ; 0007 0430 
                 ; 0007 0431        if( gFlag == FLAG_COMPLETE )
000ab3 91a0 0512 	LDS  R26,_gFlag
000ab5 30a4      	CPI  R26,LOW(0x4)
000ab6 f421      	BRNE _0xE00F0
                 ; 0007 0432              HIGH_COMPLETE_LED;
000ab7 91e0 0062 	LDS  R30,98
000ab9 68e0      	ORI  R30,0x80
000aba c003      	RJMP _0xE0104
                 ; 0007 0433        else  LOW_COMPLETE_LED;
                 _0xE00F0:
                 _0xE0103:
000abb 91e0 0062 	LDS  R30,98
000abd 77ef      	ANDI R30,0x7F
                 _0xE0104:
000abe 93e0 0062 	STS  98,R30
                 ; 0007 0434     }
                 ; 0007 0435 }
000ac0 9508      	RET
                 ; .FEND
                 ;void UserProcessor( void )
                 ; 0007 0437 {
                 _UserProcessor:
                 ; .FSTART _UserProcessor
                 ; 0007 0438    if( gCurMode == CUR_INIT )
000ac1 91e0 051b 	LDS  R30,_gCurMode
000ac3 30e0      	CPI  R30,0
000ac4 f4a9      	BRNE _0xE00F2
                 ; 0007 0439    {
                 ; 0007 043A       DAC7611_WriteVoltage(0);
000ac5 e0a0      	LDI  R26,LOW(0)
000ac6 e0b0      	LDI  R27,0
000ac7 940e 0cab 	CALL SUBOPT_0x2A
                 ; 0007 043B       LOW_PWM;
000ac9 7fe7      	ANDI R30,0XF7
000aca 93e0 0065 	STS  101,R30
                 ; 0007 043C       LOW_OUTRY;
000acc 91e0 0065 	LDS  R30,101
000ace 7eef      	ANDI R30,0xEF
000acf 93e0 0065 	STS  101,R30
                 ; 0007 043D       gMode = MODE_STOP;
000ad1 e0e0      	LDI  R30,LOW(0)
000ad2 93e0 050a 	STS  _gMode,R30
                 ; 0007 043E       gFlag = FLAG_STADNBY;
000ad4 93e0 0512 	STS  _gFlag,R30
                 ; 0007 043F 
                 ; 0007 0440       gCurMode = CUR_OK;
000ad6 e0e1      	LDI  R30,LOW(1)
000ad7 93e0 051b 	STS  _gCurMode,R30
                 ; 0007 0441 
                 ; 0007 0442      // LOW_COMPLETE_LED;
                 ; 0007 0443      // LOW_WARRING_LED;
                 ; 0007 0444    }
                 ; 0007 0445    else if( gCurMode == CUR_OK )
000ad9 c018      	RJMP _0xE00F3
                 _0xE00F2:
000ada 91a0 051b 	LDS  R26,_gCurMode
000adc 30a1      	CPI  R26,LOW(0x1)
000add f419      	BRNE _0xE00F4
                 ; 0007 0446    {
                 ; 0007 0447        ADCProcessor();
000ade de85      	RCALL _ADCProcessor
                 ; 0007 0448        DisplayLed();
000adf dfc4      	RCALL _DisplayLed
                 ; 0007 0449    }
                 ; 0007 044A    else if( gCurMode == CUR_ERROR )
000ae0 c011      	RJMP _0xE00F5
                 _0xE00F4:
000ae1 91a0 051b 	LDS  R26,_gCurMode
000ae3 30a2      	CPI  R26,LOW(0x2)
000ae4 f469      	BRNE _0xE00F6
                 ; 0007 044B    {
                 ; 0007 044C        gCurMode = CUR_INIT;
000ae5 e0e0      	LDI  R30,LOW(0)
000ae6 93e0 051b 	STS  _gCurMode,R30
                 ; 0007 044D        // gInitCount = 0;
                 ; 0007 044E        LOW_COMPLETE_LED;
000ae8 91e0 0062 	LDS  R30,98
000aea 77ef      	ANDI R30,0x7F
000aeb 93e0 0062 	STS  98,R30
                 ; 0007 044F        HIGH_WARRING_LED;
000aed 91e0 0062 	LDS  R30,98
000aef 64e0      	ORI  R30,0x40
000af0 93e0 0062 	STS  98,R30
                 ; 0007 0450    }
                 ; 0007 0451 }
                 _0xE00F6:
                 _0xE00F5:
                 _0xE00F3:
000af2 9508      	RET
                 ; .FEND
                 ;
                 ;void main()
                 ; 0007 0454 {
                 _main:
                 ; .FSTART _main
                 ; 0007 0455    BYTE wEvent;
                 ; 0007 0456    int mTimeUart0,mTimeUart1;
                 ; 0007 0457 
                 ; 0007 0458    SystemInit( );
                 ;	wEvent -> R17
                 ;	mTimeUart0 -> R18,R19
                 ;	mTimeUart1 -> R20,R21
000af3 dd40      	RCALL _SystemInit
                 ; 0007 0459 
                 ; 0007 045A    mTimeUart0 = mTimeUart1 = 0;
000af4 e0e0      	LDI  R30,LOW(0)
000af5 e0f0      	LDI  R31,HIGH(0)
000af6 01af      	MOVW R20,R30
000af7 019f      	MOVW R18,R30
                 ; 0007 045B    // Global enable interrupts
                 ; 0007 045C    #asm("sei");
000af8 9478      	sei
                 ; 0007 045D 
                 ; 0007 045E    while ( TRUE )
                 _0xE00F7:
                 ; 0007 045F    {
                 ; 0007 0460       wEvent = WaitEvent();
000af9 dd68      	RCALL _WaitEvent
000afa 2f1e      	MOV  R17,R30
                 ; 0007 0461       if( wEvent == EVN_RCVUART0 )
000afb 3011      	CPI  R17,1
000afc f451      	BRNE _0xE00FA
                 ; 0007 0462       {
                 ; 0007 0463           IPC_RunProcess0( );  //handle
000afd 940e 04a7 	CALL _IPC_RunProcess0
                 ; 0007 0464           mTimeUart0 = 0;
                +
000aff e020     +LDI R18 , LOW ( 0 )
000b00 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 ; 0007 0465           gError &= ~(1<<ERROR_NOTHANDLE);
000b01 91e0 0513 	LDS  R30,_gError
000b03 7def      	ANDI R30,0xDF
000b04 93e0 0513 	STS  _gError,R30
                 ; 0007 0466       }
                 ; 0007 0467       else if( wEvent == EVN_RCVUART1 )
000b06 c027      	RJMP _0xE00FB
                 _0xE00FA:
000b07 3012      	CPI  R17,2
000b08 f451      	BRNE _0xE00FC
                 ; 0007 0468       {
                 ; 0007 0469           IPC_RunProcess1( );  //LCD Pannel
000b09 940e 0347 	CALL _IPC_RunProcess1
                 ; 0007 046A           mTimeUart1 = 0;
                +
000b0b e040     +LDI R20 , LOW ( 0 )
000b0c e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 ; 0007 046B           gError &= ~(1<<ERROR_NOTLCD);
000b0d 91e0 0513 	LDS  R30,_gError
000b0f 7bef      	ANDI R30,0xBF
000b10 93e0 0513 	STS  _gError,R30
                 ; 0007 046C       }
                 ; 0007 046D       else if(wEvent == EVN_TIMEOVER )
000b12 c01b      	RJMP _0xE00FD
                 _0xE00FC:
000b13 3013      	CPI  R17,3
000b14 f4c9      	BRNE _0xE00FE
                 ; 0007 046E       {
                 ; 0007 046F           UserProcessor();
000b15 dfab      	RCALL _UserProcessor
                 ; 0007 0470 
                 ; 0007 0471           if( ++mTimeUart0 > 7 ) //2.1sec
000b16 01f9      	MOVW R30,R18
000b17 9631      	ADIW R30,1
000b18 019f      	MOVW R18,R30
000b19 9738      	SBIW R30,8
000b1a f03c      	BRLT _0xE00FF
                 ; 0007 0472           {
                 ; 0007 0473              mTimeUart0 = 0;
                +
000b1b e020     +LDI R18 , LOW ( 0 )
000b1c e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 ; 0007 0474              gError |= (1<<ERROR_NOTHANDLE);
000b1d 91e0 0513 	LDS  R30,_gError
000b1f 62e0      	ORI  R30,0x20
000b20 940e 0ccf 	CALL SUBOPT_0x2E
                 ; 0007 0475              gCurMode = CUR_ERROR;
                 ; 0007 0476           }
                 ; 0007 0477           if( ++mTimeUart1 > 7 ) //2.1sec
                 _0xE00FF:
000b22 01fa      	MOVW R30,R20
000b23 9631      	ADIW R30,1
000b24 01af      	MOVW R20,R30
000b25 9738      	SBIW R30,8
000b26 f03c      	BRLT _0xE0100
                 ; 0007 0478           {
                 ; 0007 0479              mTimeUart1 = 0;
                +
000b27 e040     +LDI R20 , LOW ( 0 )
000b28 e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 ; 0007 047A              gError |= (1<<ERROR_NOTLCD);
000b29 91e0 0513 	LDS  R30,_gError
000b2b 64e0      	ORI  R30,0x40
000b2c 940e 0ccf 	CALL SUBOPT_0x2E
                 ; 0007 047B              gCurMode = CUR_ERROR;
                 ; 0007 047C           }
                 ; 0007 047D       }
                 _0xE0100:
                 ; 0007 047E    }
                 _0xE00FE:
                 _0xE00FD:
                 _0xE00FB:
000b2e cfca      	RJMP _0xE00F7
                 ; 0007 047F }
                 _0xE0101:
000b2f cfff      	RJMP _0xE0101
                 ; .FEND
                 ;
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 
                 	.CSEG
                 
                 	.CSEG
                 _memset:
                 ; .FSTART _memset
000b30 93ba      	ST   -Y,R27
000b31 93aa      	ST   -Y,R26
000b32 81b9          ldd  r27,y+1
000b33 81a8          ld   r26,y
000b34 9610          adiw r26,0
000b35 f031          breq memset1
000b36 81fc          ldd  r31,y+4
000b37 81eb          ldd  r30,y+3
000b38 816a          ldd  r22,y+2
                 memset0:
000b39 9361          st   z+,r22
000b3a 9711          sbiw r26,1
000b3b f7e9          brne memset0
                 memset1:
000b3c 81eb          ldd  r30,y+3
000b3d 81fc          ldd  r31,y+4
000b3e 9625      	ADIW R28,5
000b3f 9508      	RET
                 ; .FEND
                 
                 	.CSEG
                 
                 	.CSEG
                 
                 	.CSEG
                 
                 	.DSEG
                 
                 	.CSEG
                 
                 	.DSEG
                 _gElMatrix:
000500           	.BYTE 0x4
                 _goldTime1ms:
000504           	.BYTE 0x2
                 _gTime1ms:
000506           	.BYTE 0x2
                 _gVoltage:
000508           	.BYTE 0x2
                 _gMode:
00050a           	.BYTE 0x1
                 _gRunFlag:
00050b           	.BYTE 0x1
                 _gDose:
00050c           	.BYTE 0x2
                 _gDepth:
00050e           	.BYTE 0x2
                 _gSpeed:
000510           	.BYTE 0x2
                 _gFlag:
000512           	.BYTE 0x1
                 _gError:
000513           	.BYTE 0x1
                 _gMotorPos1:
000514           	.BYTE 0x2
                 _gMotorPos2:
000516           	.BYTE 0x2
                 _gElCompletFlag:
000518           	.BYTE 0x1
                 _gElCount:
000519           	.BYTE 0x2
                 _gCurMode:
00051b           	.BYTE 0x1
                 _gReadyActionFlag:
00051c           	.BYTE 0x1
                 _gVolChkCount:
00051d           	.BYTE 0x2
                 _IPC1Rcvfun:
00051f           	.BYTE 0x18
                 _IPC1Sndfun:
000537           	.BYTE 0x18
                 _IPC0Rcvfun:
00054f           	.BYTE 0x18
                 _IPC0Sndfun:
000567           	.BYTE 0x18
                 _rx_buffer0:
00057f           	.BYTE 0xFA
                 _rx_buffer1:
000679           	.BYTE 0xFA
                 _gAdcLoc:
000773           	.BYTE 0x2
                 _gElLoc:
000775           	.BYTE 0x2
                 _gCurState:
000777           	.BYTE 0x2
                 _gCalValue0:
000779           	.BYTE 0x2
                 _gCalValue1:
00077b           	.BYTE 0x2
                 _gDutyOff:
00077d           	.BYTE 0x2
                 _gShift:
00077f           	.BYTE 0x2
                 _gVolAdjCount:
000781           	.BYTE 0x2
                 _gGenMode:
000783           	.BYTE 0x1
                 __seed_G104:
000784           	.BYTE 0x4
                 
                 	.CSEG
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x0:
000b40 931a      	ST   -Y,R17
000b41 930a      	ST   -Y,R16
                +
000b42 e000     +LDI R16 , LOW ( 0 )
000b43 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
000b44 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x1:
000b45 93ba      	ST   -Y,R27
000b46 93aa      	ST   -Y,R26
000b47 940e 1004 	CALL __SAVELOCR4
000b49 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x2:
000b4a 9754      	SBIW R26,20
000b4b e0ea      	LDI  R30,LOW(10)
000b4c e0f0      	LDI  R31,HIGH(10)
000b4d 940e 0fd4 	CALL __DIVW21
000b4f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x3:
000b50 01f9      	MOVW R30,R18
000b51 940e 0fbc 	CALL __CWD1
000b53 940e 0e50 	CALL __CDF1
000b55 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x4:
000b56 93ba      	ST   -Y,R27
000b57 93aa      	ST   -Y,R26
000b58 931a      	ST   -Y,R17
000b59 81e9      	LDD  R30,Y+1
000b5a 81fa      	LDD  R31,Y+1+1
000b5b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x5:
000b5c 93ba      	ST   -Y,R27
000b5d 93aa      	ST   -Y,R26
000b5e 81e8      	LD   R30,Y
000b5f 81f9      	LDD  R31,Y+1
000b60 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x6:
000b61 93e0 050c 	STS  _gDose,R30
000b63 93f0 050d 	STS  _gDose+1,R31
000b65 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x7:
000b66 e0e0      	LDI  R30,LOW(0)
000b67 93e0 050c 	STS  _gDose,R30
000b69 93e0 050d 	STS  _gDose+1,R30
000b6b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x8:
000b6c e0f0      	LDI  R31,0
000b6d 93e0 0508 	STS  _gVoltage,R30
000b6f 93f0 0509 	STS  _gVoltage+1,R31
000b71 91a0 0508 	LDS  R26,_gVoltage
000b73 91b0 0509 	LDS  R27,_gVoltage+1
000b75 97dc      	SBIW R26,60
000b76 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x9:
000b77 e3ec      	LDI  R30,LOW(60)
000b78 e0f0      	LDI  R31,HIGH(60)
000b79 93e0 0508 	STS  _gVoltage,R30
000b7b 93f0 0509 	STS  _gVoltage+1,R31
000b7d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:17 WORDS
                 SUBOPT_0xA:
000b7e 91a0 0508 	LDS  R26,_gVoltage
000b80 91b0 0509 	LDS  R27,_gVoltage+1
000b82 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0xB:
000b83 e7e8      	LDI  R30,LOW(120)
000b84 e0f0      	LDI  R31,HIGH(120)
000b85 93e0 0508 	STS  _gVoltage,R30
000b87 93f0 0509 	STS  _gVoltage+1,R31
000b89 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xC:
000b8a e0f0      	LDI  R31,0
000b8b 93e0 050e 	STS  _gDepth,R30
000b8d 93f0 050f 	STS  _gDepth+1,R31
000b8f 91a0 050f 	LDS  R26,_gDepth+1
000b91 23aa      	TST  R26
000b92 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xD:
000b93 e0e0      	LDI  R30,LOW(0)
000b94 93e0 050e 	STS  _gDepth,R30
000b96 93e0 050f 	STS  _gDepth+1,R30
000b98 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0xE:
000b99 e0e3      	LDI  R30,LOW(3)
000b9a e0f0      	LDI  R31,HIGH(3)
000b9b 93e0 050e 	STS  _gDepth,R30
000b9d 93f0 050f 	STS  _gDepth+1,R31
000b9f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xF:
000ba0 e0f0      	LDI  R31,0
000ba1 93e0 0510 	STS  _gSpeed,R30
000ba3 93f0 0511 	STS  _gSpeed+1,R31
000ba5 91a0 0511 	LDS  R26,_gSpeed+1
000ba7 23aa      	TST  R26
000ba8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x10:
000ba9 e0e2      	LDI  R30,LOW(2)
000baa e0f0      	LDI  R31,HIGH(2)
000bab 93e0 0510 	STS  _gSpeed,R30
000bad 93f0 0511 	STS  _gSpeed+1,R31
000baf 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x11:
000bb0 93e0 0519 	STS  _gElCount,R30
000bb2 93f0 051a 	STS  _gElCount+1,R31
000bb4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x12:
000bb5 93ba      	ST   -Y,R27
000bb6 93aa      	ST   -Y,R26
000bb7 931a      	ST   -Y,R17
000bb8 930a      	ST   -Y,R16
000bb9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x13:
000bba 2fe1      	MOV  R30,R17
000bbb e0a1      	LDI  R26,LOW(1)
000bbc 940e 0f99 	CALL __LSLB12
000bbe 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:61 WORDS
                 SUBOPT_0x14:
000bbf 93ba      	ST   -Y,R27
000bc0 93aa      	ST   -Y,R26
000bc1 81a8      	LD   R26,Y
000bc2 81b9      	LDD  R27,Y+1
000bc3 9612      	ADIW R26,2
000bc4 e8e0      	LDI  R30,LOW(128)
000bc5 93ec      	ST   X,R30
000bc6 81a8      	LD   R26,Y
000bc7 81b9      	LDD  R27,Y+1
000bc8 9613      	ADIW R26,3
000bc9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x15:
000bca 93ec      	ST   X,R30
000bcb 91e0 050a 	LDS  R30,_gMode
                +
000bcd 81a8     +LDD R26 , Y + 0
000bce 81b9     +LDD R27 , Y + 0 + 1
000bcf 9614     +ADIW R26 , 4
000bd0 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000bd1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:45 WORDS
                 SUBOPT_0x16:
000bd2 81e8      	LD   R30,Y
000bd3 81f9      	LDD  R31,Y+1
000bd4 93fa      	ST   -Y,R31
000bd5 93ea      	ST   -Y,R30
000bd6 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:93 WORDS
                 SUBOPT_0x17:
000bd7 e0a5      	LDI  R26,LOW(5)
000bd8 e0b0      	LDI  R27,0
000bd9 940e 032e 	CALL _MakeCrc
                +
000bdb 81a8     +LDD R26 , Y + 0
000bdc 81b9     +LDD R27 , Y + 0 + 1
000bdd 9615     +ADIW R26 , 5
000bde 93ec     +ST X , R30
                 	__PUTB1SNS 0,5
000bdf cff2      	RJMP SUBOPT_0x16
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x18:
000be0 e0e1      	LDI  R30,LOW(1)
000be1 93ec      	ST   X,R30
000be2 91e0 050b 	LDS  R30,_gRunFlag
                +
000be4 81a8     +LDD R26 , Y + 0
000be5 81b9     +LDD R27 , Y + 0 + 1
000be6 9614     +ADIW R26 , 4
000be7 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000be8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:67 WORDS
                 SUBOPT_0x19:
000be9 93ba      	ST   -Y,R27
000bea 93aa      	ST   -Y,R26
000beb 81a8      	LD   R26,Y
000bec 81b9      	LDD  R27,Y+1
000bed 9612      	ADIW R26,2
000bee e8e0      	LDI  R30,LOW(128)
000bef 93ec      	ST   X,R30
000bf0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x1A:
000bf1 91e0 050c 	LDS  R30,_gDose
000bf3 91f0 050d 	LDS  R31,_gDose+1
000bf5 940e 0fb7 	CALL __ASRW8
                +
000bf7 81a8     +LDD R26 , Y + 0
000bf8 81b9     +LDD R27 , Y + 0 + 1
000bf9 9613     +ADIW R26 , 3
000bfa 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
000bfb 91e0 050c 	LDS  R30,_gDose
                +
000bfd 81a8     +LDD R26 , Y + 0
000bfe 81b9     +LDD R27 , Y + 0 + 1
000bff 9614     +ADIW R26 , 4
000c00 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000c01 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x1B:
000c02 91e0 0508 	LDS  R30,_gVoltage
000c04 91f0 0509 	LDS  R31,_gVoltage+1
000c06 940e 0fb7 	CALL __ASRW8
                +
000c08 81a8     +LDD R26 , Y + 0
000c09 81b9     +LDD R27 , Y + 0 + 1
000c0a 9613     +ADIW R26 , 3
000c0b 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
000c0c 91e0 0508 	LDS  R30,_gVoltage
                +
000c0e 81a8     +LDD R26 , Y + 0
000c0f 81b9     +LDD R27 , Y + 0 + 1
000c10 9614     +ADIW R26 , 4
000c11 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000c12 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x1C:
000c13 91e0 050e 	LDS  R30,_gDepth
000c15 91f0 050f 	LDS  R31,_gDepth+1
000c17 940e 0fb7 	CALL __ASRW8
                +
000c19 81a8     +LDD R26 , Y + 0
000c1a 81b9     +LDD R27 , Y + 0 + 1
000c1b 9613     +ADIW R26 , 3
000c1c 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
000c1d 91e0 050e 	LDS  R30,_gDepth
                +
000c1f 81a8     +LDD R26 , Y + 0
000c20 81b9     +LDD R27 , Y + 0 + 1
000c21 9614     +ADIW R26 , 4
000c22 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000c23 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x1D:
000c24 91e0 0510 	LDS  R30,_gSpeed
000c26 91f0 0511 	LDS  R31,_gSpeed+1
000c28 940e 0fb7 	CALL __ASRW8
                +
000c2a 81a8     +LDD R26 , Y + 0
000c2b 81b9     +LDD R27 , Y + 0 + 1
000c2c 9613     +ADIW R26 , 3
000c2d 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
000c2e 91e0 0510 	LDS  R30,_gSpeed
                +
000c30 81a8     +LDD R26 , Y + 0
000c31 81b9     +LDD R27 , Y + 0 + 1
000c32 9614     +ADIW R26 , 4
000c33 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000c34 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x1E:
000c35 91e0 0519 	LDS  R30,_gElCount
000c37 91f0 051a 	LDS  R31,_gElCount+1
000c39 940e 0fb7 	CALL __ASRW8
                +
000c3b 81a8     +LDD R26 , Y + 0
000c3c 81b9     +LDD R27 , Y + 0 + 1
000c3d 9613     +ADIW R26 , 3
000c3e 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
000c3f 91e0 0519 	LDS  R30,_gElCount
                +
000c41 81a8     +LDD R26 , Y + 0
000c42 81b9     +LDD R27 , Y + 0 + 1
000c43 9614     +ADIW R26 , 4
000c44 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000c45 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1F:
                +
000c46 81a8     +LDD R26 , Y + 0
000c47 81b9     +LDD R27 , Y + 0 + 1
000c48 9613     +ADIW R26 , 3
000c49 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
000c4a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x20:
000c4b 91e0 0512 	LDS  R30,_gFlag
                +
000c4d 81a8     +LDD R26 , Y + 0
000c4e 81b9     +LDD R27 , Y + 0 + 1
000c4f 9614     +ADIW R26 , 4
000c50 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000c51 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x21:
                +
000c52 81a8     +LDD R26 , Y + 0
000c53 81b9     +LDD R27 , Y + 0 + 1
000c54 9614     +ADIW R26 , 4
000c55 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
000c56 cf7b      	RJMP SUBOPT_0x16
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x22:
000c57 976e      	SBIW R28,30
000c58 940e 1002 	CALL __SAVELOCR6
000c5a 01fe      	MOVW R30,R28
000c5b 9636      	ADIW R30,6
000c5c 93fa      	ST   -Y,R31
000c5d 93ea      	ST   -Y,R30
000c5e e0a7      	LDI  R26,LOW(7)
000c5f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x23:
000c60 2f1e      	MOV  R17,R30
000c61 01fe      	MOVW R30,R28
000c62 9636      	ADIW R30,6
000c63 01af      	MOVW R20,R30
000c64 01fe      	MOVW R30,R28
000c65 9636      	ADIW R30,6
000c66 93fa      	ST   -Y,R31
000c67 93ea      	ST   -Y,R30
000c68 e0a5      	LDI  R26,LOW(5)
000c69 e0b0      	LDI  R27,0
000c6a 940e 032e 	CALL _MakeCrc
000c6c 2f0e      	MOV  R16,R30
000c6d 01fa      	MOVW R30,R20
000c6e 8135      	LDD  R19,Z+5
000c6f 3017      	CPI  R17,7
000c70 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x24:
000c71 93fa      	ST   -Y,R31
000c72 93ea      	ST   -Y,R30
000c73 e8a1      	LDI  R26,LOW(129)
000c74 940c 036b 	JMP  _IPC_Send_Response1
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:26 WORDS
                 SUBOPT_0x25:
000c76 93aa      	ST   -Y,R26
000c77 931a      	ST   -Y,R17
000c78 930a      	ST   -Y,R16
                +
000c79 810b     +LDD R16 , Y + 3
000c7a 811c     +LDD R17 , Y + 3 + 1
                 	__GETWRS 16,17,3
000c7b 81ea      	LDD  R30,Y+2
                +
000c7c 01d8     +MOVW R26 , R16
000c7d 9612     +ADIW R26 , 2
000c7e 93ec     +ST X , R30
                 	__PUTB1RNS 16,2
000c7f 01d8      	MOVW R26,R16
000c80 9613      	ADIW R26,3
000c81 e0e0      	LDI  R30,LOW(0)
000c82 93ec      	ST   X,R30
000c83 01d8      	MOVW R26,R16
000c84 9614      	ADIW R26,4
000c85 93ec      	ST   X,R30
000c86 931a      	ST   -Y,R17
000c87 930a      	ST   -Y,R16
000c88 e0a5      	LDI  R26,LOW(5)
000c89 e0b0      	LDI  R27,0
000c8a 940e 032e 	CALL _MakeCrc
                +
000c8c 01d8     +MOVW R26 , R16
000c8d 9615     +ADIW R26 , 5
000c8e 93ec     +ST X , R30
                 	__PUTB1RNS 16,5
000c8f 81eb      	LDD  R30,Y+3
000c90 81fc      	LDD  R31,Y+3+1
000c91 93fa      	ST   -Y,R31
000c92 93ea      	ST   -Y,R30
000c93 e0a7      	LDI  R26,LOW(7)
000c94 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x26:
                +
000c95 810a     +LDD R16 , Y + 2
000c96 811b     +LDD R17 , Y + 2 + 1
                 	__GETWRS 16,17,2
000c97 01f8      	MOVW R30,R16
000c98 81a2      	LDD  R26,Z+2
000c99 30ac      	CPI  R26,LOW(0xC)
000c9a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x27:
000c9b e0f0      	LDI  R31,0
000c9c 0fee      	LSL  R30
000c9d 1fff      	ROL  R31
000c9e 0fae      	ADD  R26,R30
000c9f 1fbf      	ADC  R27,R31
000ca0 940e 0fe7 	CALL __GETW1P
000ca2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x28:
000ca3 81ea      	LDD  R30,Y+2
000ca4 81fb      	LDD  R31,Y+2+1
000ca5 93fa      	ST   -Y,R31
000ca6 93ea      	ST   -Y,R30
000ca7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x29:
000ca8 81ea      	LDD  R30,Y+2
000ca9 81fb      	LDD  R31,Y+2+1
000caa cfc6      	RJMP SUBOPT_0x24
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x2A:
000cab 940e 014d 	CALL _DAC7611_WriteVoltage
000cad 91e0 0065 	LDS  R30,101
000caf 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2B:
000cb0 e0e0      	LDI  R30,LOW(0)
000cb1 bbe5      	OUT  0x15,R30
000cb2 e0a0      	LDI  R26,LOW(0)
000cb3 e0b0      	LDI  R27,0
000cb4 cff6      	RJMP SUBOPT_0x2A
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x2C:
000cb5 7fe7      	ANDI R30,0XF7
000cb6 93e0 0065 	STS  101,R30
000cb8 91e0 0065 	LDS  R30,101
000cba 7eef      	ANDI R30,0xEF
000cbb 93e0 0065 	STS  101,R30
000cbd e0e0      	LDI  R30,LOW(0)
000cbe 93e0 0512 	STS  _gFlag,R30
000cc0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
                 SUBOPT_0x2D:
000cc1 81ea      	LDD  R30,Y+2
000cc2 81fb      	LDD  R31,Y+2+1
000cc3 81e3      	LDD  R30,Z+3
000cc4 2ffe      	MOV  R31,R30
000cc5 e0e0      	LDI  R30,0
000cc6 01df      	MOVW R26,R30
000cc7 81ea      	LDD  R30,Y+2
000cc8 81fb      	LDD  R31,Y+2+1
000cc9 81e4      	LDD  R30,Z+4
000cca e0f0      	LDI  R31,0
000ccb 2bea      	OR   R30,R26
000ccc 2bfb      	OR   R31,R27
000ccd 018f      	MOVW R16,R30
000cce 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:18 WORDS
                 SUBOPT_0x2E:
000ccf 93e0 0513 	STS  _gError,R30
000cd1 e0e2      	LDI  R30,LOW(2)
000cd2 93e0 051b 	STS  _gCurMode,R30
000cd4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x2F:
000cd5 e0e0      	LDI  R30,LOW(0)
000cd6 93ec      	ST   X,R30
000cd7 81a8      	LD   R26,Y
000cd8 81b9      	LDD  R27,Y+1
000cd9 9614      	ADIW R26,4
000cda 93ec      	ST   X,R30
000cdb 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x30:
000cdc 93ea      	ST   -Y,R30
000cdd 93fa      	ST   -Y,R31
000cde b7ef      	IN   R30,SREG
000cdf 93ea      	ST   -Y,R30
000ce0 931a      	ST   -Y,R17
000ce1 930a      	ST   -Y,R16
000ce2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x31:
000ce3 93aa      	ST   -Y,R26
000ce4 940e 1004 	CALL __SAVELOCR4
000ce6 e010      	LDI  R17,0
000ce7 e000      	LDI  R16,0
                +
000ce8 9120 0506+LDS R18 , 0 + ( _gTime1ms )
000cea 9130 0507+LDS R19 , 0 + ( _gTime1ms ) + 1
                 	__GETWRMN 18,19,0,_gTime1ms
000cec 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x32:
000ced 2fe1      	MOV  R30,R17
000cee 81ad      	LDD  R26,Y+5
000cef 81be      	LDD  R27,Y+5+1
000cf0 e0f0      	LDI  R31,0
000cf1 0fea      	ADD  R30,R26
000cf2 1ffb      	ADC  R31,R27
000cf3 8300      	ST   Z,R16
000cf4 5f1f      	SUBI R17,-1
000cf5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x33:
000cf6 91a0 0506 	LDS  R26,_gTime1ms
000cf8 91b0 0507 	LDS  R27,_gTime1ms+1
000cfa 1ba2      	SUB  R26,R18
000cfb 0bb3      	SBC  R27,R19
000cfc 3ba9      	CPI  R26,LOW(0xBB9)
000cfd e0eb      	LDI  R30,HIGH(0xBB9)
000cfe 07be      	CPC  R27,R30
000cff 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x34:
000d00 2fe1      	MOV  R30,R17
000d01 5f1f      	SUBI R17,-1
000d02 81aa      	LDD  R26,Y+2
000d03 81bb      	LDD  R27,Y+2+1
000d04 e0f0      	LDI  R31,0
000d05 0fae      	ADD  R26,R30
000d06 1fbf      	ADC  R27,R31
000d07 91ac      	LD   R26,X
000d08 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 19 TIMES, CODE SIZE REDUCTION:51 WORDS
                 SUBOPT_0x35:
000d09 91ed      	LD   R30,X+
000d0a 91fd      	LD   R31,X+
000d0b 9631      	ADIW R30,1
000d0c 93fe      	ST   -X,R31
000d0d 93ee      	ST   -X,R30
000d0e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x36:
000d0f 91e0 0775 	LDS  R30,_gElLoc
000d11 91f0 0776 	LDS  R31,_gElLoc+1
000d13 50e0      	SUBI R30,LOW(-_gElMatrix)
000d14 4ffb      	SBCI R31,HIGH(-_gElMatrix)
000d15 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x37:
000d16 e7af      	LDI  R26,LOW(_gShift)
000d17 e0b7      	LDI  R27,HIGH(_gShift)
000d18 cff0      	RJMP SUBOPT_0x35
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x38:
000d19 91a0 077f 	LDS  R26,_gShift
000d1b 91b0 0780 	LDS  R27,_gShift+1
000d1d 9714      	SBIW R26,4
000d1e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x39:
000d1f e0e0      	LDI  R30,LOW(0)
000d20 93e0 077f 	STS  _gShift,R30
000d22 93e0 0780 	STS  _gShift+1,R30
000d24 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x3A:
000d25 91e0 077f 	LDS  R30,_gShift
000d27 e0a8      	LDI  R26,LOW(8)
000d28 940e 0fa1 	CALL __LSRB12
000d2a 91a0 0779 	LDS  R26,_gCalValue0
000d2c 2bea      	OR   R30,R26
000d2d bbe5      	OUT  0x15,R30
000d2e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3B:
000d2f e0e1      	LDI  R30,LOW(1)
000d30 e0f0      	LDI  R31,HIGH(1)
000d31 93e0 0777 	STS  _gCurState,R30
000d33 93f0 0778 	STS  _gCurState+1,R31
000d35 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 17 TIMES, CODE SIZE REDUCTION:29 WORDS
                 SUBOPT_0x3C:
000d36 91a0 0777 	LDS  R26,_gCurState
000d38 91b0 0778 	LDS  R27,_gCurState+1
000d3a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3D:
000d3b e0e2      	LDI  R30,LOW(2)
000d3c e0f0      	LDI  R31,HIGH(2)
000d3d 93e0 0777 	STS  _gCurState,R30
000d3f 93f0 0778 	STS  _gCurState+1,R31
000d41 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3E:
000d42 e0e3      	LDI  R30,LOW(3)
000d43 e0f0      	LDI  R31,HIGH(3)
000d44 93e0 0777 	STS  _gCurState,R30
000d46 93f0 0778 	STS  _gCurState+1,R31
000d48 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3F:
000d49 e0e4      	LDI  R30,LOW(4)
000d4a e0f0      	LDI  R31,HIGH(4)
000d4b 93e0 0777 	STS  _gCurState,R30
000d4d 93f0 0778 	STS  _gCurState+1,R31
000d4f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x40:
000d50 e0e5      	LDI  R30,LOW(5)
000d51 e0f0      	LDI  R31,HIGH(5)
000d52 93e0 0777 	STS  _gCurState,R30
000d54 93f0 0778 	STS  _gCurState+1,R31
000d56 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x41:
000d57 e0e0      	LDI  R30,LOW(0)
000d58 93e0 077d 	STS  _gDutyOff,R30
000d5a 93e0 077e 	STS  _gDutyOff+1,R30
000d5c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x42:
000d5d e0e6      	LDI  R30,LOW(6)
000d5e e0f0      	LDI  R31,HIGH(6)
000d5f 93e0 0777 	STS  _gCurState,R30
000d61 93f0 0778 	STS  _gCurState+1,R31
000d63 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x43:
000d64 e7ad      	LDI  R26,LOW(_gDutyOff)
000d65 e0b7      	LDI  R27,HIGH(_gDutyOff)
000d66 cfa2      	RJMP SUBOPT_0x35
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x44:
000d67 91a0 077d 	LDS  R26,_gDutyOff
000d69 91b0 077e 	LDS  R27,_gDutyOff+1
000d6b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x45:
000d6c e0e0      	LDI  R30,LOW(0)
000d6d 93e0 0777 	STS  _gCurState,R30
000d6f 93e0 0778 	STS  _gCurState+1,R30
000d71 e7a5      	LDI  R26,LOW(_gElLoc)
000d72 e0b7      	LDI  R27,HIGH(_gElLoc)
000d73 cf95      	RJMP SUBOPT_0x35
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x46:
000d74 e0e0      	LDI  R30,LOW(0)
000d75 bbe5      	OUT  0x15,R30
000d76 93e0 0775 	STS  _gElLoc,R30
000d78 93e0 0776 	STS  _gElLoc+1,R30
000d7a e0e1      	LDI  R30,LOW(1)
000d7b 93e0 0518 	STS  _gElCompletFlag,R30
000d7d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x47:
000d7e 91e0 0779 	LDS  R30,_gCalValue0
000d80 bbe5      	OUT  0x15,R30
000d81 cfe2      	RJMP SUBOPT_0x43
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x48:
000d82 93e0 0777 	STS  _gCurState,R30
000d84 93f0 0778 	STS  _gCurState+1,R31
000d86 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x49:
000d87 e0e0      	LDI  R30,LOW(0)
000d88 bdef      	OUT  0x2F,R30
000d89 e0e1      	LDI  R30,LOW(1)
000d8a bdee      	OUT  0x2E,R30
000d8b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x4A:
000d8c e0e2      	LDI  R30,LOW(2)
000d8d 93e0 0500 	STS  _gElMatrix,R30
000d8f e0e1      	LDI  R30,LOW(1)
                +
000d90 93e0 0501+STS _gElMatrix + ( 1 ) , R30
                 	__PUTB1MN _gElMatrix,1
000d92 e0e8      	LDI  R30,LOW(8)
                +
000d93 93e0 0502+STS _gElMatrix + ( 2 ) , R30
                 	__PUTB1MN _gElMatrix,2
000d95 e0e4      	LDI  R30,LOW(4)
                +
000d96 93e0 0503+STS _gElMatrix + ( 3 ) , R30
                 	__PUTB1MN _gElMatrix,3
000d98 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x4B:
000d99 91e0 0506 	LDS  R30,_gTime1ms
000d9b 91f0 0507 	LDS  R31,_gTime1ms+1
000d9d 93e0 0504 	STS  _goldTime1ms,R30
000d9f 93f0 0505 	STS  _goldTime1ms+1,R31
000da1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4C:
000da2 91a0 0773 	LDS  R26,_gAdcLoc
000da4 91b0 0774 	LDS  R27,_gAdcLoc+1
000da6 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4D:
000da7 91a0 051d 	LDS  R26,_gVolChkCount
000da9 91b0 051e 	LDS  R27,_gVolChkCount+1
000dab 940e 0ffe 	CALL __CPW02
000dad 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x4E:
000dae e1ad      	LDI  R26,LOW(_gVolChkCount)
000daf e0b5      	LDI  R27,HIGH(_gVolChkCount)
000db0 91ed      	LD   R30,X+
000db1 91fd      	LD   R31,X+
000db2 9731      	SBIW R30,1
000db3 93fe      	ST   -X,R31
000db4 93ee      	ST   -X,R30
000db5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0x4F:
000db6 01f8      	MOVW R30,R16
000db7 e9ac      	LDI  R26,LOW(_DacArray*2)
000db8 e0b0      	LDI  R27,HIGH(_DacArray*2)
000db9 940e 0fb2 	CALL __LSLW2
000dbb 0fea      	ADD  R30,R26
000dbc 1ffb      	ADC  R31,R27
000dbd 940e 0feb 	CALL __GETD1PF
                +
000dbf 83ee     +STD Y + 6 , R30
000dc0 83ff     +STD Y + 6 + 1 , R31
000dc1 8768     +STD Y + 6 + 2 , R22
000dc2 8779     +STD Y + 6 + 3 , R23
                 	__PUTD1S 6
000dc3 cd8c      	RJMP SUBOPT_0x3
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x50:
                +
000dc4 81ae     +LDD R26 , Y + 6
000dc5 81bf     +LDD R27 , Y + 6 + 1
000dc6 8588     +LDD R24 , Y + 6 + 2
000dc7 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
000dc8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x51:
                +
000dc9 eced     +LDI R30 , LOW ( 0x3E4CCCCD )
000dca ecfc     +LDI R31 , HIGH ( 0x3E4CCCCD )
000dcb e46c     +LDI R22 , BYTE3 ( 0x3E4CCCCD )
000dcc e37e     +LDI R23 , BYTE4 ( 0x3E4CCCCD )
                 	__GETD1N 0x3E4CCCCD
000dcd 940e 0eda 	CALL __MULF12
000dcf cff4      	RJMP SUBOPT_0x50
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x52:
000dd0 dff3      	RCALL SUBOPT_0x50
000dd1 cff7      	RJMP SUBOPT_0x51
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x53:
000dd2 e0e2      	LDI  R30,LOW(2)
000dd3 93e0 0512 	STS  _gFlag,R30
000dd5 91e0 0513 	LDS  R30,_gError
000dd7 70e1      	ANDI R30,LOW(0x1)
000dd8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x54:
000dd9 e8a1      	LDI  R26,LOW(_gVolAdjCount)
000dda e0b7      	LDI  R27,HIGH(_gVolAdjCount)
000ddb cf2d      	RJMP SUBOPT_0x35
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x55:
000ddc 91a0 0781 	LDS  R26,_gVolAdjCount
000dde 91b0 0782 	LDS  R27,_gVolAdjCount+1
000de0 9714      	SBIW R26,4
000de1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x56:
000de2 e0e0      	LDI  R30,LOW(0)
000de3 93e0 0781 	STS  _gVolAdjCount,R30
000de5 93e0 0782 	STS  _gVolAdjCount+1,R30
000de7 91e0 0513 	LDS  R30,_gError
000de9 9508      	RET
                 
                 
                 	.CSEG
                 __ROUND_REPACK:
000dea 2355      	TST  R21
000deb f442      	BRPL __REPACK
000dec 3850      	CPI  R21,0x80
000ded f411      	BRNE __ROUND_REPACK0
000dee ffe0      	SBRS R30,0
000def c004      	RJMP __REPACK
                 __ROUND_REPACK0:
000df0 9631      	ADIW R30,1
000df1 1f69      	ADC  R22,R25
000df2 1f79      	ADC  R23,R25
000df3 f06b      	BRVS __REPACK1
                 
                 __REPACK:
000df4 e850      	LDI  R21,0x80
000df5 2757      	EOR  R21,R23
000df6 f411      	BRNE __REPACK0
000df7 935f      	PUSH R21
000df8 c0cf      	RJMP __ZERORES
                 __REPACK0:
000df9 3f5f      	CPI  R21,0xFF
000dfa f031      	BREQ __REPACK1
000dfb 0f66      	LSL  R22
000dfc 0c00      	LSL  R0
000dfd 9557      	ROR  R21
000dfe 9567      	ROR  R22
000dff 2f75      	MOV  R23,R21
000e00 9508      	RET
                 __REPACK1:
000e01 935f      	PUSH R21
000e02 2000      	TST  R0
000e03 f00a      	BRMI __REPACK2
000e04 c0cf      	RJMP __MAXRES
                 __REPACK2:
000e05 c0c8      	RJMP __MINRES
                 
                 __UNPACK:
000e06 e850      	LDI  R21,0x80
000e07 2e19      	MOV  R1,R25
000e08 2215      	AND  R1,R21
000e09 0f88      	LSL  R24
000e0a 1f99      	ROL  R25
000e0b 2795      	EOR  R25,R21
000e0c 0f55      	LSL  R21
000e0d 9587      	ROR  R24
                 
                 __UNPACK1:
000e0e e850      	LDI  R21,0x80
000e0f 2e07      	MOV  R0,R23
000e10 2205      	AND  R0,R21
000e11 0f66      	LSL  R22
000e12 1f77      	ROL  R23
000e13 2775      	EOR  R23,R21
000e14 0f55      	LSL  R21
000e15 9567      	ROR  R22
000e16 9508      	RET
                 
                 __CFD1U:
000e17 9468      	SET
000e18 c001      	RJMP __CFD1U0
                 __CFD1:
000e19 94e8      	CLT
                 __CFD1U0:
000e1a 935f      	PUSH R21
000e1b dff2      	RCALL __UNPACK1
000e1c 3870      	CPI  R23,0x80
000e1d f018      	BRLO __CFD10
000e1e 3f7f      	CPI  R23,0xFF
000e1f f408      	BRCC __CFD10
000e20 c0a7      	RJMP __ZERORES
                 __CFD10:
000e21 e156      	LDI  R21,22
000e22 1b57      	SUB  R21,R23
000e23 f4aa      	BRPL __CFD11
000e24 9551      	NEG  R21
000e25 3058      	CPI  R21,8
000e26 f40e      	BRTC __CFD19
000e27 3059      	CPI  R21,9
                 __CFD19:
000e28 f030      	BRLO __CFD17
000e29 efef      	SER  R30
000e2a efff      	SER  R31
000e2b ef6f      	SER  R22
000e2c e77f      	LDI  R23,0x7F
000e2d f977      	BLD  R23,7
000e2e c01a      	RJMP __CFD15
                 __CFD17:
000e2f 2777      	CLR  R23
000e30 2355      	TST  R21
000e31 f0b9      	BREQ __CFD15
                 __CFD18:
000e32 0fee      	LSL  R30
000e33 1fff      	ROL  R31
000e34 1f66      	ROL  R22
000e35 1f77      	ROL  R23
000e36 955a      	DEC  R21
000e37 f7d1      	BRNE __CFD18
000e38 c010      	RJMP __CFD15
                 __CFD11:
000e39 2777      	CLR  R23
                 __CFD12:
000e3a 3058      	CPI  R21,8
000e3b f028      	BRLO __CFD13
000e3c 2fef      	MOV  R30,R31
000e3d 2ff6      	MOV  R31,R22
000e3e 2f67      	MOV  R22,R23
000e3f 5058      	SUBI R21,8
000e40 cff9      	RJMP __CFD12
                 __CFD13:
000e41 2355      	TST  R21
000e42 f031      	BREQ __CFD15
                 __CFD14:
000e43 9576      	LSR  R23
000e44 9567      	ROR  R22
000e45 95f7      	ROR  R31
000e46 95e7      	ROR  R30
000e47 955a      	DEC  R21
000e48 f7d1      	BRNE __CFD14
                 __CFD15:
000e49 2000      	TST  R0
000e4a f40a      	BRPL __CFD16
000e4b d145      	RCALL __ANEGD1
                 __CFD16:
000e4c 915f      	POP  R21
000e4d 9508      	RET
                 
                 __CDF1U:
000e4e 9468      	SET
000e4f c001      	RJMP __CDF1U0
                 __CDF1:
000e50 94e8      	CLT
                 __CDF1U0:
000e51 9730      	SBIW R30,0
000e52 4060      	SBCI R22,0
000e53 4070      	SBCI R23,0
000e54 f0b1      	BREQ __CDF10
000e55 2400      	CLR  R0
000e56 f026      	BRTS __CDF11
000e57 2377      	TST  R23
000e58 f412      	BRPL __CDF11
000e59 9400      	COM  R0
000e5a d136      	RCALL __ANEGD1
                 __CDF11:
000e5b 2e17      	MOV  R1,R23
000e5c e17e      	LDI  R23,30
000e5d 2011      	TST  R1
                 __CDF12:
000e5e f032      	BRMI __CDF13
000e5f 957a      	DEC  R23
000e60 0fee      	LSL  R30
000e61 1fff      	ROL  R31
000e62 1f66      	ROL  R22
000e63 1c11      	ROL  R1
000e64 cff9      	RJMP __CDF12
                 __CDF13:
000e65 2fef      	MOV  R30,R31
000e66 2ff6      	MOV  R31,R22
000e67 2d61      	MOV  R22,R1
000e68 935f      	PUSH R21
000e69 df8a      	RCALL __REPACK
000e6a 915f      	POP  R21
                 __CDF10:
000e6b 9508      	RET
                 
                 __SWAPACC:
000e6c 934f      	PUSH R20
000e6d 01af      	MOVW R20,R30
000e6e 01fd      	MOVW R30,R26
000e6f 01da      	MOVW R26,R20
000e70 01ab      	MOVW R20,R22
000e71 01bc      	MOVW R22,R24
000e72 01ca      	MOVW R24,R20
000e73 2d40      	MOV  R20,R0
000e74 2c01      	MOV  R0,R1
000e75 2e14      	MOV  R1,R20
000e76 914f      	POP  R20
000e77 9508      	RET
                 
                 __UADD12:
000e78 0fea      	ADD  R30,R26
000e79 1ffb      	ADC  R31,R27
000e7a 1f68      	ADC  R22,R24
000e7b 9508      	RET
                 
                 __NEGMAN1:
000e7c 95e0      	COM  R30
000e7d 95f0      	COM  R31
000e7e 9560      	COM  R22
000e7f 5fef      	SUBI R30,-1
000e80 4fff      	SBCI R31,-1
000e81 4f6f      	SBCI R22,-1
000e82 9508      	RET
                 
                 __SUBF12:
000e83 935f      	PUSH R21
000e84 df81      	RCALL __UNPACK
000e85 3890      	CPI  R25,0x80
000e86 f171      	BREQ __ADDF129
000e87 e850      	LDI  R21,0x80
000e88 2615      	EOR  R1,R21
                 
000e89 c004      	RJMP __ADDF120
                 
                 __ADDF12:
000e8a 935f      	PUSH R21
000e8b df7a      	RCALL __UNPACK
000e8c 3890      	CPI  R25,0x80
000e8d f139      	BREQ __ADDF129
                 
                 __ADDF120:
000e8e 3870      	CPI  R23,0x80
000e8f f121      	BREQ __ADDF128
                 __ADDF121:
000e90 2f57      	MOV  R21,R23
000e91 1b59      	SUB  R21,R25
000e92 f12b      	BRVS __ADDF1211
000e93 f412      	BRPL __ADDF122
000e94 dfd7      	RCALL __SWAPACC
000e95 cffa      	RJMP __ADDF121
                 __ADDF122:
000e96 3158      	CPI  R21,24
000e97 f018      	BRLO __ADDF123
000e98 27aa      	CLR  R26
000e99 27bb      	CLR  R27
000e9a 2788      	CLR  R24
                 __ADDF123:
000e9b 3058      	CPI  R21,8
000e9c f028      	BRLO __ADDF124
000e9d 2fab      	MOV  R26,R27
000e9e 2fb8      	MOV  R27,R24
000e9f 2788      	CLR  R24
000ea0 5058      	SUBI R21,8
000ea1 cff9      	RJMP __ADDF123
                 __ADDF124:
000ea2 2355      	TST  R21
000ea3 f029      	BREQ __ADDF126
                 __ADDF125:
000ea4 9586      	LSR  R24
000ea5 95b7      	ROR  R27
000ea6 95a7      	ROR  R26
000ea7 955a      	DEC  R21
000ea8 f7d9      	BRNE __ADDF125
                 __ADDF126:
000ea9 2d50      	MOV  R21,R0
000eaa 2551      	EOR  R21,R1
000eab f072      	BRMI __ADDF127
000eac dfcb      	RCALL __UADD12
000ead f438      	BRCC __ADDF129
000eae 9567      	ROR  R22
000eaf 95f7      	ROR  R31
000eb0 95e7      	ROR  R30
000eb1 9573      	INC  R23
000eb2 f413      	BRVC __ADDF129
000eb3 c020      	RJMP __MAXRES
                 __ADDF128:
000eb4 dfb7      	RCALL __SWAPACC
                 __ADDF129:
000eb5 df3e      	RCALL __REPACK
000eb6 915f      	POP  R21
000eb7 9508      	RET
                 __ADDF1211:
000eb8 f7d8      	BRCC __ADDF128
000eb9 cffb      	RJMP __ADDF129
                 __ADDF127:
000eba 1bea      	SUB  R30,R26
000ebb 0bfb      	SBC  R31,R27
000ebc 0b68      	SBC  R22,R24
000ebd f051      	BREQ __ZERORES
000ebe f410      	BRCC __ADDF1210
000ebf 9400      	COM  R0
000ec0 dfbb      	RCALL __NEGMAN1
                 __ADDF1210:
000ec1 2366      	TST  R22
000ec2 f392      	BRMI __ADDF129
000ec3 0fee      	LSL  R30
000ec4 1fff      	ROL  R31
000ec5 1f66      	ROL  R22
000ec6 957a      	DEC  R23
000ec7 f7cb      	BRVC __ADDF1210
                 
                 __ZERORES:
000ec8 27ee      	CLR  R30
000ec9 27ff      	CLR  R31
000eca 2766      	CLR  R22
000ecb 2777      	CLR  R23
000ecc 915f      	POP  R21
000ecd 9508      	RET
                 
                 __MINRES:
000ece efef      	SER  R30
000ecf efff      	SER  R31
000ed0 e76f      	LDI  R22,0x7F
000ed1 ef7f      	SER  R23
000ed2 915f      	POP  R21
000ed3 9508      	RET
                 
                 __MAXRES:
000ed4 efef      	SER  R30
000ed5 efff      	SER  R31
000ed6 e76f      	LDI  R22,0x7F
000ed7 e77f      	LDI  R23,0x7F
000ed8 915f      	POP  R21
000ed9 9508      	RET
                 
                 __MULF12:
000eda 935f      	PUSH R21
000edb df2a      	RCALL __UNPACK
000edc 3870      	CPI  R23,0x80
000edd f351      	BREQ __ZERORES
000ede 3890      	CPI  R25,0x80
000edf f341      	BREQ __ZERORES
000ee0 2401      	EOR  R0,R1
000ee1 9408      	SEC
000ee2 1f79      	ADC  R23,R25
000ee3 f423      	BRVC __MULF124
000ee4 f31c      	BRLT __ZERORES
                 __MULF125:
000ee5 2000      	TST  R0
000ee6 f33a      	BRMI __MINRES
000ee7 cfec      	RJMP __MAXRES
                 __MULF124:
000ee8 920f      	PUSH R0
000ee9 931f      	PUSH R17
000eea 932f      	PUSH R18
000eeb 933f      	PUSH R19
000eec 934f      	PUSH R20
000eed 2711      	CLR  R17
000eee 2722      	CLR  R18
000eef 2799      	CLR  R25
000ef0 9f68      	MUL  R22,R24
000ef1 01a0      	MOVW R20,R0
000ef2 9f8f      	MUL  R24,R31
000ef3 2d30      	MOV  R19,R0
000ef4 0d41      	ADD  R20,R1
000ef5 1f59      	ADC  R21,R25
000ef6 9f6b      	MUL  R22,R27
000ef7 0d30      	ADD  R19,R0
000ef8 1d41      	ADC  R20,R1
000ef9 1f59      	ADC  R21,R25
000efa 9f8e      	MUL  R24,R30
000efb d027      	RCALL __MULF126
000efc 9fbf      	MUL  R27,R31
000efd d025      	RCALL __MULF126
000efe 9f6a      	MUL  R22,R26
000eff d023      	RCALL __MULF126
000f00 9fbe      	MUL  R27,R30
000f01 d01d      	RCALL __MULF127
000f02 9faf      	MUL  R26,R31
000f03 d01b      	RCALL __MULF127
000f04 9fae      	MUL  R26,R30
000f05 0d11      	ADD  R17,R1
000f06 1f29      	ADC  R18,R25
000f07 1f39      	ADC  R19,R25
000f08 1f49      	ADC  R20,R25
000f09 1f59      	ADC  R21,R25
000f0a 2fe3      	MOV  R30,R19
000f0b 2ff4      	MOV  R31,R20
000f0c 2f65      	MOV  R22,R21
000f0d 2f52      	MOV  R21,R18
000f0e 914f      	POP  R20
000f0f 913f      	POP  R19
000f10 912f      	POP  R18
000f11 911f      	POP  R17
000f12 900f      	POP  R0
000f13 2366      	TST  R22
000f14 f02a      	BRMI __MULF122
000f15 0f55      	LSL  R21
000f16 1fee      	ROL  R30
000f17 1fff      	ROL  R31
000f18 1f66      	ROL  R22
000f19 c002      	RJMP __MULF123
                 __MULF122:
000f1a 9573      	INC  R23
000f1b f24b      	BRVS __MULF125
                 __MULF123:
000f1c decd      	RCALL __ROUND_REPACK
000f1d 915f      	POP  R21
000f1e 9508      	RET
                 
                 __MULF127:
000f1f 0d10      	ADD  R17,R0
000f20 1d21      	ADC  R18,R1
000f21 1f39      	ADC  R19,R25
000f22 c002      	RJMP __MULF128
                 __MULF126:
000f23 0d20      	ADD  R18,R0
000f24 1d31      	ADC  R19,R1
                 __MULF128:
000f25 1f49      	ADC  R20,R25
000f26 1f59      	ADC  R21,R25
000f27 9508      	RET
                 
                 __DIVF21:
000f28 935f      	PUSH R21
000f29 dedc      	RCALL __UNPACK
000f2a 3870      	CPI  R23,0x80
000f2b f421      	BRNE __DIVF210
000f2c 2011      	TST  R1
                 __DIVF211:
000f2d f40a      	BRPL __DIVF219
000f2e cf9f      	RJMP __MINRES
                 __DIVF219:
000f2f cfa4      	RJMP __MAXRES
                 __DIVF210:
000f30 3890      	CPI  R25,0x80
000f31 f409      	BRNE __DIVF218
                 __DIVF217:
000f32 cf95      	RJMP __ZERORES
                 __DIVF218:
000f33 2401      	EOR  R0,R1
000f34 9408      	SEC
000f35 0b97      	SBC  R25,R23
000f36 f41b      	BRVC __DIVF216
000f37 f3d4      	BRLT __DIVF217
000f38 2000      	TST  R0
000f39 cff3      	RJMP __DIVF211
                 __DIVF216:
000f3a 2f79      	MOV  R23,R25
000f3b 931f      	PUSH R17
000f3c 932f      	PUSH R18
000f3d 933f      	PUSH R19
000f3e 934f      	PUSH R20
000f3f 2411      	CLR  R1
000f40 2711      	CLR  R17
000f41 2722      	CLR  R18
000f42 2733      	CLR  R19
000f43 2744      	CLR  R20
000f44 2755      	CLR  R21
000f45 e290      	LDI  R25,32
                 __DIVF212:
000f46 17ae      	CP   R26,R30
000f47 07bf      	CPC  R27,R31
000f48 0786      	CPC  R24,R22
000f49 0741      	CPC  R20,R17
000f4a f030      	BRLO __DIVF213
000f4b 1bae      	SUB  R26,R30
000f4c 0bbf      	SBC  R27,R31
000f4d 0b86      	SBC  R24,R22
000f4e 0b41      	SBC  R20,R17
000f4f 9408      	SEC
000f50 c001      	RJMP __DIVF214
                 __DIVF213:
000f51 9488      	CLC
                 __DIVF214:
000f52 1f55      	ROL  R21
000f53 1f22      	ROL  R18
000f54 1f33      	ROL  R19
000f55 1c11      	ROL  R1
000f56 1faa      	ROL  R26
000f57 1fbb      	ROL  R27
000f58 1f88      	ROL  R24
000f59 1f44      	ROL  R20
000f5a 959a      	DEC  R25
000f5b f751      	BRNE __DIVF212
000f5c 01f9      	MOVW R30,R18
000f5d 2d61      	MOV  R22,R1
000f5e 914f      	POP  R20
000f5f 913f      	POP  R19
000f60 912f      	POP  R18
000f61 911f      	POP  R17
000f62 2366      	TST  R22
000f63 f032      	BRMI __DIVF215
000f64 0f55      	LSL  R21
000f65 1fee      	ROL  R30
000f66 1fff      	ROL  R31
000f67 1f66      	ROL  R22
000f68 957a      	DEC  R23
000f69 f243      	BRVS __DIVF217
                 __DIVF215:
000f6a de7f      	RCALL __ROUND_REPACK
000f6b 915f      	POP  R21
000f6c 9508      	RET
                 
                 __CMPF12:
000f6d 2399      	TST  R25
000f6e f09a      	BRMI __CMPF120
000f6f 2377      	TST  R23
000f70 f042      	BRMI __CMPF121
000f71 1797      	CP   R25,R23
000f72 f048      	BRLO __CMPF122
000f73 f429      	BRNE __CMPF121
000f74 17ae      	CP   R26,R30
000f75 07bf      	CPC  R27,R31
000f76 0786      	CPC  R24,R22
000f77 f020      	BRLO __CMPF122
000f78 f031      	BREQ __CMPF123
                 __CMPF121:
000f79 9498      	CLZ
000f7a 9488      	CLC
000f7b 9508      	RET
                 __CMPF122:
000f7c 9498      	CLZ
000f7d 9408      	SEC
000f7e 9508      	RET
                 __CMPF123:
000f7f 9418      	SEZ
000f80 9488      	CLC
000f81 9508      	RET
                 __CMPF120:
000f82 2377      	TST  R23
000f83 f7c2      	BRPL __CMPF122
000f84 1797      	CP   R25,R23
000f85 f398      	BRLO __CMPF121
000f86 f7a9      	BRNE __CMPF122
000f87 17ea      	CP   R30,R26
000f88 07fb      	CPC  R31,R27
000f89 0768      	CPC  R22,R24
000f8a f388      	BRLO __CMPF122
000f8b f399      	BREQ __CMPF123
000f8c cfec      	RJMP __CMPF121
                 
                 __ANEGW1:
000f8d 95f1      	NEG  R31
000f8e 95e1      	NEG  R30
000f8f 40f0      	SBCI R31,0
000f90 9508      	RET
                 
                 __ANEGD1:
000f91 95f0      	COM  R31
000f92 9560      	COM  R22
000f93 9570      	COM  R23
000f94 95e1      	NEG  R30
000f95 4fff      	SBCI R31,-1
000f96 4f6f      	SBCI R22,-1
000f97 4f7f      	SBCI R23,-1
000f98 9508      	RET
                 
                 __LSLB12:
000f99 23ee      	TST  R30
000f9a 2e0e      	MOV  R0,R30
000f9b 2fea      	MOV  R30,R26
000f9c f019      	BREQ __LSLB12R
                 __LSLB12L:
000f9d 0fee      	LSL  R30
000f9e 940a      	DEC  R0
000f9f f7e9      	BRNE __LSLB12L
                 __LSLB12R:
000fa0 9508      	RET
                 
                 __LSRB12:
000fa1 23ee      	TST  R30
000fa2 2e0e      	MOV  R0,R30
000fa3 2fea      	MOV  R30,R26
000fa4 f019      	BREQ __LSRB12R
                 __LSRB12L:
000fa5 95e6      	LSR  R30
000fa6 940a      	DEC  R0
000fa7 f7e9      	BRNE __LSRB12L
                 __LSRB12R:
000fa8 9508      	RET
                 
                 __LSRW12:
000fa9 23ee      	TST  R30
000faa 2e0e      	MOV  R0,R30
000fab 01fd      	MOVW R30,R26
000fac f021      	BREQ __LSRW12R
                 __LSRW12L:
000fad 95f6      	LSR  R31
000fae 95e7      	ROR  R30
000faf 940a      	DEC  R0
000fb0 f7e1      	BRNE __LSRW12L
                 __LSRW12R:
000fb1 9508      	RET
                 
                 __LSLW2:
000fb2 0fee      	LSL  R30
000fb3 1fff      	ROL  R31
000fb4 0fee      	LSL  R30
000fb5 1fff      	ROL  R31
000fb6 9508      	RET
                 
                 __ASRW8:
000fb7 2fef      	MOV  R30,R31
000fb8 27ff      	CLR  R31
000fb9 fde7      	SBRC R30,7
000fba efff      	SER  R31
000fbb 9508      	RET
                 
                 __CWD1:
000fbc 2f6f      	MOV  R22,R31
000fbd 0f66      	ADD  R22,R22
000fbe 0b66      	SBC  R22,R22
000fbf 2f76      	MOV  R23,R22
000fc0 9508      	RET
                 
                 __DIVW21U:
000fc1 2400      	CLR  R0
000fc2 2411      	CLR  R1
000fc3 e190      	LDI  R25,16
                 __DIVW21U1:
000fc4 0faa      	LSL  R26
000fc5 1fbb      	ROL  R27
000fc6 1c00      	ROL  R0
000fc7 1c11      	ROL  R1
000fc8 1a0e      	SUB  R0,R30
000fc9 0a1f      	SBC  R1,R31
000fca f418      	BRCC __DIVW21U2
000fcb 0e0e      	ADD  R0,R30
000fcc 1e1f      	ADC  R1,R31
000fcd c001      	RJMP __DIVW21U3
                 __DIVW21U2:
000fce 60a1      	SBR  R26,1
                 __DIVW21U3:
000fcf 959a      	DEC  R25
000fd0 f799      	BRNE __DIVW21U1
000fd1 01fd      	MOVW R30,R26
000fd2 01d0      	MOVW R26,R0
000fd3 9508      	RET
                 
                 __DIVW21:
000fd4 d004      	RCALL __CHKSIGNW
000fd5 dfeb      	RCALL __DIVW21U
000fd6 f40e      	BRTC __DIVW211
000fd7 dfb5      	RCALL __ANEGW1
                 __DIVW211:
000fd8 9508      	RET
                 
                 __CHKSIGNW:
000fd9 94e8      	CLT
000fda fff7      	SBRS R31,7
000fdb c002      	RJMP __CHKSW1
000fdc dfb0      	RCALL __ANEGW1
000fdd 9468      	SET
                 __CHKSW1:
000fde ffb7      	SBRS R27,7
000fdf c006      	RJMP __CHKSW2
000fe0 95a0      	COM  R26
000fe1 95b0      	COM  R27
000fe2 9611      	ADIW R26,1
000fe3 f800      	BLD  R0,0
000fe4 9403      	INC  R0
000fe5 fa00      	BST  R0,0
                 __CHKSW2:
000fe6 9508      	RET
                 
                 __GETW1P:
000fe7 91ed      	LD   R30,X+
000fe8 91fc      	LD   R31,X
000fe9 9711      	SBIW R26,1
000fea 9508      	RET
                 
                 __GETD1PF:
000feb 9005      	LPM  R0,Z+
000fec 9015      	LPM  R1,Z+
000fed 9165      	LPM  R22,Z+
000fee 9174      	LPM  R23,Z
000fef 01f0      	MOVW R30,R0
000ff0 9508      	RET
                 
                 __SWAPD12:
000ff1 2e18      	MOV  R1,R24
000ff2 2f86      	MOV  R24,R22
000ff3 2d61      	MOV  R22,R1
000ff4 2e19      	MOV  R1,R25
000ff5 2f97      	MOV  R25,R23
000ff6 2d71      	MOV  R23,R1
                 
                 __SWAPW12:
000ff7 2e1b      	MOV  R1,R27
000ff8 2fbf      	MOV  R27,R31
000ff9 2df1      	MOV  R31,R1
                 
                 __SWAPB12:
000ffa 2e1a      	MOV  R1,R26
000ffb 2fae      	MOV  R26,R30
000ffc 2de1      	MOV  R30,R1
000ffd 9508      	RET
                 
                 __CPW02:
000ffe 2400      	CLR  R0
000fff 160a      	CP   R0,R26
001000 060b      	CPC  R0,R27
001001 9508      	RET
                 
                 __SAVELOCR6:
001002 935a      	ST   -Y,R21
                 __SAVELOCR5:
001003 934a      	ST   -Y,R20
                 __SAVELOCR4:
001004 933a      	ST   -Y,R19
                 __SAVELOCR3:
001005 932a      	ST   -Y,R18
                 __SAVELOCR2:
001006 931a      	ST   -Y,R17
001007 930a      	ST   -Y,R16
001008 9508      	RET
                 
                 __LOADLOCR6:
001009 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
00100a 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
00100b 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
00100c 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
00100d 8119      	LDD  R17,Y+1
00100e 8108      	LD   R16,Y
00100f 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 :  51 r1 :  39 r2 :   0 r3 :   0 r4 :   5 r5 :   5 r6 :   1 r7 :   7 
r8 :   5 r9 :   3 r10:   7 r11:   5 r12:   3 r13:   1 r14:   0 r15:   2 
r16:  97 r17: 101 r18:  31 r19:  29 r20:  37 r21:  67 r22:  65 r23:  55 
r24:  40 r25:  43 r26: 386 r27: 151 r28:  33 r29:   1 r30: 934 r31: 217 
x  :  51 y  : 318 z  :  61 
Registers used: 32 out of 35 (91.4%)

ATmega128 instruction use summary:
.lds  :   0 .lds.l:   0 .sts  :   0 .sts.l:   0 adc   :  27 add   :  18 
adiw  :  59 and   :  10 andi  :  38 asr   :   0 bclr  :   0 bld   :   2 
brbc  :   0 brbs  :   0 brcc  :   7 brcs  :   0 break :   0 breq  :  38 
brge  :  13 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :  21 
brlt  :  35 brmi  :   9 brne  :  80 brpl  :  14 brsh  :  10 brtc  :   2 
brts  :   1 brvc  :   4 brvs  :   4 bset  :   0 bst   :   1 call  : 388 
cbi   :   7 cbr   :   0 clc   :   3 clh   :   0 cli   :   5 cln   :   0 
clr   :  43 cls   :   0 clt   :   3 clv   :   0 clz   :   2 com   :  12 
cp    :  23 cpc   :  22 cpi   :  73 cpse  :   0 dec   :  15 des   :   0 
elpm  :   0 eor   :   7 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   4 
ijmp  :   0 in    :   8 inc   :   9 jmp   :  49 ld    :  61 ldd   : 181 
ldi   : 372 lds   : 164 lpm   :  14 lsl   :  16 lsr   :   4 mov   :  86 
movw  :  91 mul   :   9 muls  :   0 mulsu :   0 neg   :   4 nop   :   1 
or    :  14 ori   :  13 out   :  70 pop   :  44 push  :  44 rcall :  64 
ret   : 140 reti  :   3 rjmp  : 190 rol   :  30 ror   :  13 sbc   :  10 
sbci  :  19 sbi   :  16 sbic  :   2 sbis  :   4 sbiw  :  60 sbr   :   1 
sbrc  :   1 sbrs  :   3 sec   :   4 seh   :   0 sei   :   5 sen   :   0 
ser   :   9 ses   :   0 set   :   3 sev   :   0 sez   :   1 sleep :   0 
spm   :   0 st    : 163 std   :  13 sts   : 163 sub   :   7 subi  :  16 
swap  :  10 tst   :  27 wdr   :   0 
Instructions used: 81 out of 117 (69.2%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x002020   7986    238   8224  131072   6.3%
[.dseg] 0x000100 0x000788      0    648    648    4096  15.8%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 13 warnings
